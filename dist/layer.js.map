{"version":3,"file":"layer.js","sources":["../src/layer.js"],"sourcesContent":["import './leaflet.js'; // a lightly modified version of Leaflet for use as browser module\nimport './mapml.js'; // modified URI to make the function a property of window scope (possibly a bad thing to do).\n\nexport class MapLayer extends HTMLElement {\n  static get observedAttributes() {\n    return ['src', 'label', 'checked', 'hidden', 'opacity'];\n  }\n  /* jshint ignore:start */\n  #hasConnected;\n  /* jshint ignore:end */\n  get src() {\n    return this.hasAttribute('src') ? this.getAttribute('src') : '';\n  }\n\n  set src(val) {\n    if (val) {\n      this.setAttribute('src', val);\n    }\n  }\n  get label() {\n    if (this._layer) return this._layer.getName();\n    else return this.hasAttribute('label') ? this.getAttribute('label') : '';\n  }\n  set label(val) {\n    if (val) {\n      this.setAttribute('label', val);\n    }\n  }\n  get checked() {\n    return this.hasAttribute('checked');\n  }\n\n  set checked(val) {\n    if (val) {\n      this.setAttribute('checked', '');\n    } else {\n      this.removeAttribute('checked');\n    }\n  }\n\n  get hidden() {\n    return this.hasAttribute('hidden');\n  }\n\n  set hidden(val) {\n    if (val) {\n      this.setAttribute('hidden', '');\n    } else {\n      this.removeAttribute('hidden');\n    }\n  }\n\n  get opacity() {\n    // use ?? since 0 is falsy, || would return rhs in that case\n    return +(this._opacity ?? this.getAttribute('opacity'));\n  }\n\n  set opacity(val) {\n    if (+val > 1 || +val < 0) return;\n    this.setAttribute('opacity', val);\n  }\n\n  get extent() {\n    // calculate the bounds of all content, return it.\n    if (this._layer && !this._layer.bounds) {\n      this._layer._calculateBounds();\n    }\n    return this._layer\n      ? Object.assign(\n          M._convertAndFormatPCRS(\n            this._layer.bounds,\n            M[this.getProjection()],\n            this.getProjection()\n          ),\n          { zoom: this._layer.zoomBounds }\n        )\n      : null;\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (this.#hasConnected /* jshint ignore:line */) {\n      switch (name) {\n        case 'label':\n          this._layer.setName(newValue);\n          break;\n        case 'checked':\n          if (typeof newValue === 'string') {\n            this.parentElement._map.addLayer(this._layer);\n          } else {\n            this.parentElement._map.removeLayer(this._layer);\n          }\n          this._layerControlCheckbox.checked = this.checked;\n          this.dispatchEvent(new CustomEvent('map-change'));\n          break;\n        case 'hidden':\n          if (typeof newValue === 'string') {\n            this._layerControl.removeLayer(this._layer);\n          } else {\n            this._layerControl.addOrUpdateOverlay(this._layer, this.label);\n            this._validateDisabled();\n          }\n          break;\n        case 'opacity':\n          if (oldValue !== newValue && this._layer) {\n            this._opacity = newValue;\n            this._layer.changeOpacity(newValue);\n          }\n          break;\n        case 'src':\n          if (oldValue !== newValue) {\n            this._onRemove();\n            if (this.isConnected) {\n              this._onAdd();\n            }\n          }\n      }\n    }\n  }\n\n  constructor() {\n    // Always call super first in constructor\n    super();\n    // this._opacity is used to record the current opacity value (with or without updates),\n    // the initial value of this._opacity should be set as opacity attribute value, if exists, or the default value 1.0\n    this._opacity = this.opacity || 1.0;\n    this._renderingMapContent = M.options.contentPreference;\n    this.attachShadow({ mode: 'open' });\n  }\n  disconnectedCallback() {\n    // if the map-layer node is removed from the dom, the layer should be\n    // removed from the map and the layer control\n    if (this.hasAttribute('data-moving')) return;\n    this._onRemove();\n  }\n\n  _onRemove() {\n    if (this._observer) {\n      this._observer.disconnect();\n    }\n    let l = this._layer,\n      lc = this._layerControl,\n      lchtml = this._layerControlHTML;\n    // remove properties of layer involved in whenReady() logic\n    delete this._layer;\n    delete this._layerControl;\n    delete this._layerControlHTML;\n    delete this._fetchError;\n    this.shadowRoot.innerHTML = '';\n    if (this.src) this.innerHTML = '';\n\n    if (l) {\n      l.off();\n    }\n    // if this layer has never been connected, it will not have a _layer\n    if (l && l._map) {\n      l._map.removeLayer(l);\n    }\n\n    if (lc && !this.hidden) {\n      lc.removeLayer(l);\n    }\n  }\n\n  connectedCallback() {\n    if (this.hasAttribute('data-moving')) return;\n    /* jshint ignore:start */\n    this.#hasConnected = true;\n    /* jshint ignore:end */\n    this._createLayerControlHTML = M._createLayerControlHTML.bind(this);\n    const doConnected = this._onAdd.bind(this);\n    const doRemove = this._onRemove.bind(this);\n    this.parentElement\n      .whenReady()\n      .then(() => {\n        doRemove();\n        doConnected();\n      })\n      .catch((error) => {\n        throw new Error('Map never became ready: ' + error);\n      });\n  }\n\n  _onAdd() {\n    new Promise((resolve, reject) => {\n      this.addEventListener(\n        'changestyle',\n        function (e) {\n          e.stopPropagation();\n          // if user changes the style in layer control\n          if (e.detail) {\n            this._renderingMapContent = e.detail._renderingMapContent;\n            this.src = e.detail.src;\n          }\n        },\n        { once: true }\n      );\n      this.addEventListener(\n        'zoomchangesrc',\n        function (e) {\n          e.stopPropagation();\n          this.src = e.detail.href;\n        },\n        { once: true }\n      );\n      let base = this.baseURI ? this.baseURI : document.baseURI;\n      const headers = new Headers();\n      headers.append('Accept', 'text/mapml');\n      if (this.src) {\n        fetch(this.src, { headers: headers })\n          .then((response) => {\n            if (!response.ok) {\n              throw new Error(`HTTP error! Status: ${response.status}`);\n            }\n            return response.text();\n          })\n          .then((mapml) => {\n            let content = new DOMParser().parseFromString(mapml, 'text/xml');\n            if (\n              content.querySelector('parsererror') ||\n              !content.querySelector('mapml-')\n            ) {\n              // cut short whenReady with the _fetchError property\n              this._fetchError = true;\n              console.log('Error fetching layer content:\\n\\n' + mapml + '\\n');\n              throw new Error('Parser error');\n            }\n            return content;\n          })\n          .then((content) => {\n            this.copyRemoteContentToShadowRoot(content.querySelector('mapml-'));\n            let elements = this.shadowRoot.querySelectorAll('*');\n            let elementsReady = [];\n            for (let i = 0; i < elements.length; i++) {\n              if (elements[i].whenReady)\n                elementsReady.push(elements[i].whenReady());\n            }\n            return Promise.allSettled(elementsReady);\n          })\n          .then(() => {\n            // may throw:\n            this.selectAlternateOrChangeProjection();\n            this.checkForPreferredContent();\n          })\n          .then(() => {\n            this._layer = M.mapMLLayer(new URL(this.src, base).href, this, {\n              projection: this.getProjection(),\n              opacity: this.opacity\n            });\n            this._createLayerControlHTML();\n            this._attachedToMap();\n            // initializing map-features that previously exist\n            this._runMutationObserver(this.shadowRoot.children);\n            this._bindMutationObserver();\n            this._validateDisabled();\n            // re-use 'loadedmetadata' event from HTMLMediaElement inteface, applied\n            // to MapML extent as metadata\n            // Should always be fired at the end of initialization process\n            // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadedmetadata_event\n            // https://maps4html.org/web-map-doc/docs/api/layer-api#events\n            this.dispatchEvent(\n              new CustomEvent('loadedmetadata', { detail: { target: this } })\n            );\n            resolve();\n          })\n          .catch((error) => {\n            reject(error);\n          });\n      } else {\n        let elements = this.querySelectorAll('*');\n        let elementsReady = [];\n        for (let i = 0; i < elements.length; i++) {\n          if (elements[i].whenReady)\n            elementsReady.push(elements[i].whenReady());\n        }\n        Promise.allSettled(elementsReady)\n          .then(() => {\n            // may throw:\n            this.selectAlternateOrChangeProjection();\n            this.checkForPreferredContent();\n          })\n          .then(() => {\n            this._layer = M.mapMLLayer(null, this, {\n              projection: this.getProjection(),\n              opacity: this.opacity\n            });\n            this._createLayerControlHTML();\n            this._attachedToMap();\n            // initializing map-features that previously exist\n            this._runMutationObserver(this.children);\n            this._bindMutationObserver();\n            this._validateDisabled();\n            // re-use 'loadedmetadata' event from HTMLMediaElement inteface, applied\n            // to MapML extent as metadata\n            // Should always be fired at the end of initialization process\n            // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadedmetadata_event\n            // https://maps4html.org/web-map-doc/docs/api/layer-api#events\n            this.dispatchEvent(\n              new CustomEvent('loadedmetadata', { detail: { target: this } })\n            );\n            resolve();\n          })\n          .catch((error) => {\n            reject(error);\n          });\n      }\n    }).catch((e) => {\n      if (e.message === 'changeprojection') {\n        if (e.cause.href) {\n          console.log('Changing layer src to: ' + e.cause.href);\n          this.src = e.cause.href;\n        } else if (e.cause.mapprojection) {\n          console.log(\n            'Changing map projection to match layer: ' + e.cause.mapprojection\n          );\n          this.parentElement.projection = e.cause.mapprojection;\n        }\n      } else if (e.message === 'findmatchingpreferredcontent') {\n        if (e.cause.href) {\n          console.log(\n            'Changing layer to matching preferred content at: ' + e.cause.href\n          );\n          this.src = e.cause.href;\n        }\n      } else if (e.message === 'Failed to fetch') {\n        // cut short whenReady with the _fetchError property\n        this._fetchError = true;\n      } else {\n        console.log(e);\n        this.dispatchEvent(\n          new CustomEvent('error', { detail: { target: this } })\n        );\n      }\n    });\n  }\n\n  selectAlternateOrChangeProjection() {\n    let mapml = this.src ? this.shadowRoot : this;\n    let selectedAlternate =\n      this.getProjection() !== this.parentElement.projection &&\n      mapml.querySelector(\n        'map-link[rel=alternate][projection=' +\n          this.parentElement.projection +\n          '][href]'\n      );\n\n    if (selectedAlternate) {\n      let url = new URL(\n        selectedAlternate.getAttribute('href'),\n        selectedAlternate.getBase()\n      ).href;\n      throw new Error('changeprojection', {\n        cause: { href: url }\n      });\n    }\n    let contentProjection = this.getProjection();\n    if (\n      contentProjection !== this.parentElement.projection &&\n      this.parentElement.layers.length === 1\n    ) {\n      throw new Error('changeprojection', {\n        cause: { mapprojection: contentProjection }\n      });\n    }\n  }\n\n  checkForPreferredContent() {\n    let mapml = this.src ? this.shadowRoot : this;\n    let availablePreferMapContents = mapml.querySelector(\n      `map-link[rel=\"style\"][media=\"prefers-map-content=${this._renderingMapContent}\"][href]`\n    );\n    if (availablePreferMapContents) {\n      // resolve href\n      let url = new URL(\n        availablePreferMapContents.getAttribute('href'),\n        availablePreferMapContents.getBase()\n      ).href;\n      throw new Error('findmatchingpreferredcontent', {\n        cause: { href: url }\n      });\n    }\n  }\n\n  copyRemoteContentToShadowRoot(mapml) {\n    let shadowRoot = this.shadowRoot;\n    // get the map-meta[name=projection/cs/extent/zoom] from map-head of remote mapml, attach them to the shadowroot\n    let frag = document.createDocumentFragment();\n    let elements = mapml.querySelectorAll('map-head > *, map-body > *');\n    for (let i = 0; i < elements.length; i++) {\n      frag.appendChild(elements[i]);\n    }\n    shadowRoot.appendChild(frag);\n  }\n  /**\n   * For \"local\" content, getProjection will use content of \"this\"\n   * For \"remote\" content, you need to pass the shadowRoot to search through\n   */\n  getProjection() {\n    let mapml = this.src ? this.shadowRoot : this;\n    let projection = this.parentElement.projection;\n    if (mapml.querySelector('map-meta[name=projection][content]')) {\n      projection =\n        M._metaContentToObject(\n          mapml\n            .querySelector('map-meta[name=projection]')\n            .getAttribute('content')\n        ).content || projection;\n    } else if (mapml.querySelector('map-extent[units]')) {\n      const getProjectionFrom = (extents) => {\n        let extentProj = extents[0].attributes.units.value;\n        let isMatch = true;\n        for (let i = 0; i < extents.length; i++) {\n          if (extentProj !== extents[i].attributes.units.value) {\n            isMatch = false;\n          }\n        }\n        return isMatch ? extentProj : null;\n      };\n      projection =\n        getProjectionFrom(\n          Array.from(mapml.querySelectorAll('map-extent[units]'))\n        ) || projection;\n    } else {\n      console.log(\n        `A projection was not assigned to the '${mapml.label}' Layer. Please specify a projection for that layer using a map-meta element. See more here - https://maps4html.org/web-map-doc/docs/elements/meta/`\n      );\n    }\n    return projection;\n  }\n  /*\n   * Runs the effects of the mutation observer, which is to add map-features' and\n   * map-extents' leaflet layer implementations to the appropriate container in\n   * the layer-._layer: either as a sub-layer directly in the L.LayerGroup\n   * (MapMLLayer._layer) or as a sub-layer in the MapMLLayer._mapmlvectors\n   * L.FeatureGroup\n   */\n  _runMutationObserver(elementsGroup) {\n    const _addFeatureToMapMLVectors = (feature) => {\n      this.whenReady().then(() => {\n        // the layer extent must change as features are added, this.extent\n        // property only recalculates the bounds and zoomBounds when .bounds\n        // doesn't exist, so delete it to ensure that the extent is reset\n        delete this._layer.bounds;\n        feature.addFeature(this._layer._mapmlvectors);\n      });\n    };\n    const _addStylesheetLink = (mapLink) => {\n      this.whenReady().then(() => {\n        this._layer.appendStyleLink(mapLink);\n      });\n    };\n    const _addStyleElement = (mapStyle) => {\n      this.whenReady().then(() => {\n        this._layer.appendStyleElement(mapStyle);\n      });\n    };\n    const _addExtentElement = (mapExtent) => {\n      this.whenReady().then(() => {\n        // see comment regarding features / extent. Same thing applies to\n        // map-extent\n        delete this._layer.bounds;\n        this._validateDisabled();\n      });\n    };\n    // is this really necessary?  Do we believe that remote mapml documents will\n    // be interactive i.e. script access to their DOM?\n    let root = this.src ? this.shadowRoot : this,\n      pseudo = root instanceof ShadowRoot ? ':host' : ':scope';\n    const _addMetaElement = (mapMeta) => {\n      this.whenReady().then(() => {\n        this._layer._calculateBounds();\n        this._validateDisabled();\n      });\n    };\n    for (let i = 0; i < elementsGroup.length; ++i) {\n      let element = elementsGroup[i];\n      switch (element.nodeName) {\n        case 'MAP-FEATURE':\n          _addFeatureToMapMLVectors(element);\n          break;\n        case 'MAP-LINK':\n          if (element.link && !element.link.isConnected)\n            _addStylesheetLink(element);\n          break;\n        case 'MAP-STYLE':\n          if (element.styleElement && !element.styleElement.isConnected) {\n            _addStyleElement(element);\n          }\n          break;\n        case 'MAP-EXTENT':\n          _addExtentElement(element);\n          break;\n        case 'MAP-META':\n          // to consider: should we only honour the first child map-meta of a\n          // given name value? i.e. run _addMetaElement only for\n          // this.querySelector('map-meta[name=zoom]')\n          // tbd will this do it: element === this.querySelector(`[name=${element.getAttribute('name')}]`)\n          // a no, it will need to take into account src/shadowDom\n          const name =\n            element.hasAttribute('name') &&\n            (element.getAttribute('name').toLowerCase() === 'zoom' ||\n              element.getAttribute('name').toLowerCase() === 'extent');\n          if (\n            name &&\n            element ===\n              root.querySelector(\n                `${pseudo} > [name=${element.getAttribute('name')}]`\n              ) &&\n            element.hasAttribute('content')\n          ) {\n            _addMetaElement(element);\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  /*\n   * Set up a function to watch additions of child elements of layer- or\n   * layer-.shadowRoot and to invoke desired side  effects of those additions\n   * via _runMutationObserver\n   */\n  _bindMutationObserver() {\n    // mutation observer\n    this._observer = new MutationObserver((mutationList) => {\n      for (let mutation of mutationList) {\n        // the attributes changes should be handled by attributeChangedCallback()\n        if (mutation.type === 'childList') {\n          this._runMutationObserver(mutation.addedNodes);\n        }\n      }\n    });\n    this._observer.observe(this.src ? this.shadowRoot : this, {\n      childList: true\n    });\n  }\n  _attachedToMap() {\n    // set i to the position of this layer element in the set of layers\n    var i = 0,\n      position = 1;\n    for (var nodes = this.parentNode.children; i < nodes.length; i++) {\n      if (this.parentNode.children[i].nodeName === 'LAYER-') {\n        if (this.parentNode.children[i] === this) {\n          position = i + 1;\n        } else if (this.parentNode.children[i]._layer) {\n          this.parentNode.children[i]._layer.setZIndex(i + 1);\n        }\n      }\n    }\n    var proj = this.parentNode.projection\n      ? this.parentNode.projection\n      : 'OSMTILE';\n    L.setOptions(this._layer, {\n      zIndex: position,\n      mapprojection: proj,\n      opacity: window.getComputedStyle(this).opacity\n    });\n    // make sure the Leaflet layer has a reference to the map\n    this._layer._map = this.parentNode._map;\n\n    if (this.checked) {\n      this._layer.addTo(this._layer._map);\n    }\n\n    this._layer.on('add remove', this._validateDisabled, this);\n    // toggle the this.disabled attribute depending on whether the layer\n    // is: same prj as map, within view/zoom of map\n    this._layer._map.on('moveend layeradd', this._validateDisabled, this);\n\n    if (this.parentNode._layerControl)\n      this._layerControl = this.parentNode._layerControl;\n    // if controls option is enabled, insert the layer into the overlays array\n    if (this.parentNode._layerControl && !this.hidden) {\n      this._layerControl.addOrUpdateOverlay(this._layer, this.label);\n    }\n\n    // the mapml document associated to this layer can in theory contain many\n    // link[@rel=legend] elements with different @type or other attributes;\n    // currently only support a single link, don't care about type, lang etc.\n    // TODO: add support for full LayerLegend object, and > one link.\n    if (this._layer._legendUrl) {\n      this.legendLinks = [\n        {\n          type: 'application/octet-stream',\n          href: this._layer._legendUrl,\n          rel: 'legend',\n          lang: null,\n          hreflang: null,\n          sizes: null\n        }\n      ];\n    }\n  }\n\n  _validateDisabled() {\n    // setTimeout is necessary to make the validateDisabled happen later than the moveend operations etc.,\n    // to ensure that the validated result is correct\n    setTimeout(() => {\n      let layer = this._layer,\n        map = layer?._map;\n      if (map) {\n        this._validateLayerZoom({ zoom: map.getZoom() });\n        // prerequisite: no inline and remote mapml elements exists at the same time\n        const mapExtents = this.src\n          ? this.shadowRoot.querySelectorAll('map-extent')\n          : this.querySelectorAll('map-extent');\n        let extentLinksReady = [];\n        for (let i = 0; i < mapExtents.length; i++) {\n          extentLinksReady.push(mapExtents[i].whenLinksReady());\n        }\n        Promise.allSettled(extentLinksReady)\n          .then(() => {\n            let disabledExtentCount = 0,\n              totalExtentCount = 0,\n              layerTypes = [\n                '_staticTileLayer',\n                '_mapmlvectors',\n                '_extentLayer'\n              ];\n            for (let j = 0; j < layerTypes.length; j++) {\n              let type = layerTypes[j];\n              if (this.checked) {\n                if (type === '_extentLayer' && mapExtents.length > 0) {\n                  for (let i = 0; i < mapExtents.length; i++) {\n                    totalExtentCount++;\n                    if (mapExtents[i]._validateDisabled())\n                      disabledExtentCount++;\n                  }\n                } else if (layer[type]) {\n                  // not a templated layer\n                  totalExtentCount++;\n                  if (!layer[type].isVisible()) disabledExtentCount++;\n                }\n              }\n            }\n            // if all extents are not visible / disabled, set layer to disabled\n            if (\n              disabledExtentCount === totalExtentCount &&\n              disabledExtentCount !== 0\n            ) {\n              this.setAttribute('disabled', '');\n              this.disabled = true;\n            } else {\n              this.removeAttribute('disabled');\n              this.disabled = false;\n            }\n            this.toggleLayerControlDisabled();\n          })\n          .catch((e) => {\n            console.log(e);\n          });\n      }\n    }, 0);\n  }\n  _validateLayerZoom(e) {\n    // get the min and max zooms from all extents\n    let toZoom = e.zoom;\n    let min = this.extent.zoom.minZoom;\n    let max = this.extent.zoom.maxZoom;\n    let inLink = this.src\n        ? this.shadowRoot.querySelector('map-link[rel=zoomin]')\n        : this.querySelector('map-link[rel=zoomin]'),\n      outLink = this.src\n        ? this.shadowRoot.querySelector('map-link[rel=zoomout]')\n        : this.querySelector('map-link[rel=zoomout]');\n    let targetURL;\n    if (!(min <= toZoom && toZoom <= max)) {\n      if (inLink && toZoom > max) {\n        targetURL = inLink.href;\n      } else if (outLink && toZoom < min) {\n        targetURL = outLink.href;\n      }\n      if (targetURL) {\n        this.dispatchEvent(\n          new CustomEvent('zoomchangesrc', {\n            detail: {\n              href: targetURL\n            }\n          })\n        );\n      }\n    }\n  }\n  // disable/italicize layer control elements based on the layer-.disabled property\n  toggleLayerControlDisabled() {\n    let input = this._layerControlCheckbox,\n      label = this._layerControlLabel,\n      opacityControl = this._opacityControl,\n      opacitySlider = this._opacitySlider,\n      styleControl = this._styles;\n    if (this.disabled) {\n      input.disabled = true;\n      opacitySlider.disabled = true;\n      label.style.fontStyle = 'italic';\n      opacityControl.style.fontStyle = 'italic';\n      if (styleControl) {\n        styleControl.style.fontStyle = 'italic';\n        styleControl.querySelectorAll('input').forEach((i) => {\n          i.disabled = true;\n        });\n      }\n    } else {\n      input.disabled = false;\n      opacitySlider.disabled = false;\n      label.style.fontStyle = 'normal';\n      opacityControl.style.fontStyle = 'normal';\n      if (styleControl) {\n        styleControl.style.fontStyle = 'normal';\n        styleControl.querySelectorAll('input').forEach((i) => {\n          i.disabled = false;\n        });\n      }\n    }\n  }\n  queryable() {\n    let content = this.src ? this.shadowRoot : this;\n    return (\n      content.querySelector('map-extent[checked] > map-link[rel=query]') &&\n      this.checked &&\n      this._layer &&\n      !this.hidden\n    );\n  }\n  getAlternateStyles(styleLinks) {\n    if (styleLinks.length > 1) {\n      var stylesControl = document.createElement('details'),\n        stylesControlSummary = document.createElement('summary');\n      stylesControlSummary.innerText = 'Style';\n      stylesControl.appendChild(stylesControlSummary);\n\n      for (var j = 0; j < styleLinks.length; j++) {\n        stylesControl.appendChild(styleLinks[j].getLayerControlOption());\n        L.DomUtil.addClass(\n          stylesControl,\n          'mapml-layer-item-style mapml-control-layers'\n        );\n      }\n      return stylesControl;\n    }\n  }\n  getOuterHTML() {\n    let tempElement = this.cloneNode(true);\n\n    if (this.hasAttribute('src')) {\n      let newSrc = this._layer.getHref();\n      tempElement.setAttribute('src', newSrc);\n    }\n    if (this.querySelector('map-link')) {\n      let mapLinks = tempElement.querySelectorAll('map-link');\n\n      mapLinks.forEach((mapLink) => {\n        if (mapLink.hasAttribute('href')) {\n          mapLink.setAttribute(\n            'href',\n            decodeURI(\n              new URL(\n                mapLink.attributes.href.value,\n                this.baseURI ? this.baseURI : document.baseURI\n              ).href\n            )\n          );\n        } else if (mapLink.hasAttribute('tref')) {\n          mapLink.setAttribute(\n            'tref',\n            decodeURI(\n              new URL(\n                mapLink.attributes.tref.value,\n                this.baseURI ? this.baseURI : document.baseURI\n              ).href\n            )\n          );\n        }\n      });\n    }\n\n    let outerLayer = tempElement.outerHTML;\n\n    tempElement.remove();\n\n    return outerLayer;\n  }\n\n  zoomTo() {\n    this.whenReady().then(() => {\n      let map = this.parentElement._map,\n        extent = this.extent,\n        tL = extent.topLeft.pcrs,\n        bR = extent.bottomRight.pcrs,\n        layerBounds = L.bounds(\n          L.point(tL.horizontal, tL.vertical),\n          L.point(bR.horizontal, bR.vertical)\n        ),\n        center = map.options.crs.unproject(layerBounds.getCenter(true));\n\n      let maxZoom = extent.zoom.maxZoom,\n        minZoom = extent.zoom.minZoom;\n      map.setView(center, M.getMaxZoom(layerBounds, map, minZoom, maxZoom), {\n        animate: false\n      });\n    });\n  }\n  mapml2geojson(options = {}) {\n    return M.mapml2geojson(this, options);\n  }\n  pasteFeature(feature) {\n    switch (typeof feature) {\n      case 'string':\n        feature.trim();\n        if (\n          feature.slice(0, 12) === '<map-feature' &&\n          feature.slice(-14) === '</map-feature>'\n        ) {\n          this.insertAdjacentHTML('beforeend', feature);\n        }\n        break;\n      case 'object':\n        if (feature.nodeName.toUpperCase() === 'MAP-FEATURE') {\n          this.appendChild(feature);\n        }\n    }\n  }\n  whenReady() {\n    return new Promise((resolve, reject) => {\n      let interval, failureTimer;\n      if (\n        this._layer &&\n        this._layerControlHTML &&\n        (!this.src || this.shadowRoot?.childNodes.length)\n      ) {\n        resolve();\n      } else {\n        let layerElement = this;\n        interval = setInterval(testForLayer, 200, layerElement);\n        failureTimer = setTimeout(layerNotDefined, 5000);\n      }\n      function testForLayer(layerElement) {\n        if (\n          layerElement._layer &&\n          layerElement._layerControlHTML &&\n          (!layerElement.src || layerElement.shadowRoot?.childNodes.length)\n        ) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          resolve();\n        } else if (layerElement._fetchError) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          reject('Error fetching layer content');\n        }\n      }\n      function layerNotDefined() {\n        clearInterval(interval);\n        clearTimeout(failureTimer);\n        reject('Timeout reached waiting for layer to be ready');\n      }\n    });\n  }\n  // check if all child elements are ready\n  whenElemsReady() {\n    let elemsReady = [];\n    let target = this.src ? this.shadowRoot : this;\n    for (let elem of [\n      ...target.querySelectorAll('map-extent'),\n      ...target.querySelectorAll('map-feature')\n    ]) {\n      elemsReady.push(elem.whenReady());\n    }\n    return Promise.allSettled(elemsReady);\n  }\n}\n"],"names":["MapLayer","HTMLElement","observedAttributes","#hasConnected","src","this","hasAttribute","getAttribute","val","setAttribute","label","_layer","getName","checked","removeAttribute","hidden","opacity","_opacity","extent","bounds","_calculateBounds","Object","assign","M","_convertAndFormatPCRS","getProjection","zoom","zoomBounds","attributeChangedCallback","name","oldValue","newValue","setName","parentElement","_map","addLayer","removeLayer","_layerControlCheckbox","dispatchEvent","CustomEvent","_layerControl","addOrUpdateOverlay","_validateDisabled","changeOpacity","_onRemove","isConnected","_onAdd","constructor","super","_renderingMapContent","options","contentPreference","attachShadow","mode","disconnectedCallback","_observer","disconnect","let","l","lc","_layerControlHTML","_fetchError","shadowRoot","innerHTML","off","connectedCallback","_createLayerControlHTML","bind","doConnected","doRemove","whenReady","then","catch","Error","error","Promise","resolve","reject","addEventListener","e","stopPropagation","detail","once","href","base","baseURI","document","headers","Headers","append","fetch","response","ok","status","text","content","DOMParser","parseFromString","mapml","querySelector","console","log","copyRemoteContentToShadowRoot","elements","querySelectorAll","elementsReady","i","length","push","allSettled","selectAlternateOrChangeProjection","checkForPreferredContent","mapMLLayer","URL","projection","_attachedToMap","_runMutationObserver","children","_bindMutationObserver","target","message","cause","mapprojection","selectedAlternate","url","getBase","contentProjection","layers","availablePreferMapContents","frag","createDocumentFragment","appendChild","_metaContentToObject","extentProj","extents","attributes","units","value","isMatch","getProjectionFrom","Array","from","elementsGroup","_addFeatureToMapMLVectors","feature","addFeature","_mapmlvectors","_addStylesheetLink","appendStyleLink","mapLink","_addStyleElement","appendStyleElement","mapStyle","_addExtentElement","root","pseudo","ShadowRoot","_addMetaElement","element","nodeName","link","styleElement","toLowerCase","MutationObserver","mutation","mutationList","type","addedNodes","observe","childList","position","nodes","parentNode","setZIndex","proj","L","setOptions","zIndex","window","getComputedStyle","addTo","on","_legendUrl","legendLinks","rel","lang","hreflang","sizes","setTimeout","layer","map","_validateLayerZoom","getZoom","mapExtents","extentLinksReady","whenLinksReady","disabledExtentCount","totalExtentCount","layerTypes","j","isVisible","disabled","toggleLayerControlDisabled","toZoom","min","minZoom","max","maxZoom","inLink","outLink","targetURL","input","_layerControlLabel","opacityControl","_opacityControl","opacitySlider","_opacitySlider","styleControl","_styles","style","fontStyle","forEach","queryable","getAlternateStyles","styleLinks","stylesControl","createElement","stylesControlSummary","innerText","getLayerControlOption","DomUtil","addClass","getOuterHTML","tempElement","cloneNode","newSrc","getHref","mapLinks","decodeURI","tref","outerLayer","outerHTML","remove","zoomTo","tL","topLeft","pcrs","bR","bottomRight","layerBounds","point","horizontal","vertical","center","crs","unproject","getCenter","setView","getMaxZoom","animate","mapml2geojson","pasteFeature","trim","slice","insertAdjacentHTML","toUpperCase","interval","failureTimer","childNodes","setInterval","layerElement","clearInterval","clearTimeout","whenElemsReady","elemsReady","elem"],"mappings":"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"}