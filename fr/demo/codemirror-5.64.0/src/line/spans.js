import{indexOf,lst}from"../util/misc.js";import{cmp}from"./pos.js";import{sawCollapsedSpans}from"./saw_special_spans.js";import{getLine,isLine,lineNo}from"./utils_line.js";export function MarkedSpan(e,t,n){this.marker=e,this.from=t,this.to=n}export function getMarkedSpanFor(e,t){if(e)for(let n=0;n<e.length;++n){let r=e[n];if(r.marker==t)return r}}export function removeMarkedSpan(e,t){let n;for(let r=0;r<e.length;++r)e[r]!=t&&(n||(n=[])).push(e[r]);return n}export function addMarkedSpan(e,t,n){let r=n&&window.WeakSet&&(n.markedSpans||(n.markedSpans=new WeakSet));r&&r.has(e.markedSpans)?e.markedSpans.push(t):(e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],r&&r.add(e.markedSpans)),t.marker.attachLine(e)}function markedSpansBefore(e,t,n){let r;if(e)for(let l=0;l<e.length;++l){let i=e[l],a=i.marker;if(null==i.from||(a.inclusiveLeft?i.from<=t:i.from<t)||i.from==t&&"bookmark"==a.type&&(!n||!i.marker.insertLeft)){let e=null==i.to||(a.inclusiveRight?i.to>=t:i.to>t);(r||(r=[])).push(new MarkedSpan(a,i.from,e?null:i.to))}}return r}function markedSpansAfter(e,t,n){let r;if(e)for(let l=0;l<e.length;++l){let i=e[l],a=i.marker;if(null==i.to||(a.inclusiveRight?i.to>=t:i.to>t)||i.from==t&&"bookmark"==a.type&&(!n||i.marker.insertLeft)){let e=null==i.from||(a.inclusiveLeft?i.from<=t:i.from<t);(r||(r=[])).push(new MarkedSpan(a,e?null:i.from-t,null==i.to?null:i.to-t))}}return r}export function stretchSpansOverChange(e,t){if(t.full)return null;let n=isLine(e,t.from.line)&&getLine(e,t.from.line).markedSpans,r=isLine(e,t.to.line)&&getLine(e,t.to.line).markedSpans;if(!n&&!r)return null;let l=t.from.ch,i=t.to.ch,a=0==cmp(t.from,t.to),o=markedSpansBefore(n,l,a),f=markedSpansAfter(r,i,a),p=1==t.text.length,m=lst(t.text).length+(p?l:0);if(o)for(let u=0;u<o.length;++u){let e=o[u];if(null==e.to){let t=getMarkedSpanFor(f,e.marker);t?p&&(e.to=null==t.to?null:t.to+m):e.to=l}}if(f)for(let u=0;u<f.length;++u){let e=f[u];if(null!=e.to&&(e.to+=m),null==e.from){getMarkedSpanFor(o,e.marker)||(e.from=m,p&&(o||(o=[])).push(e))}else e.from+=m,p&&(o||(o=[])).push(e)}o&&(o=clearEmptySpans(o)),f&&f!=o&&(f=clearEmptySpans(f));let s=[o];if(!p){let e,n=t.text.length-2;if(n>0&&o)for(let t=0;t<o.length;++t)null==o[t].to&&(e||(e=[])).push(new MarkedSpan(o[t].marker,null,null));for(let t=0;t<n;++t)s.push(e);s.push(f)}return s}function clearEmptySpans(e){for(let t=0;t<e.length;++t){let n=e[t];null!=n.from&&n.from==n.to&&!1!==n.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}export function removeReadOnlyRanges(e,t,n){let r=null;if(e.iter(t.line,n.line+1,(e=>{if(e.markedSpans)for(let t=0;t<e.markedSpans.length;++t){let n=e.markedSpans[t].marker;!n.readOnly||r&&-1!=indexOf(r,n)||(r||(r=[])).push(n)}})),!r)return null;let l=[{from:t,to:n}];for(let i=0;i<r.length;++i){let e=r[i],t=e.find(0);for(let n=0;n<l.length;++n){let r=l[n];if(cmp(r.to,t.from)<0||cmp(r.from,t.to)>0)continue;let i=[n,1],a=cmp(r.from,t.from),o=cmp(r.to,t.to);(a<0||!e.inclusiveLeft&&!a)&&i.push({from:r.from,to:t.from}),(o>0||!e.inclusiveRight&&!o)&&i.push({from:t.to,to:r.to}),l.splice.apply(l,i),n+=i.length-3}}return l}export function detachMarkedSpans(e){let t=e.markedSpans;if(t){for(let n=0;n<t.length;++n)t[n].marker.detachLine(e);e.markedSpans=null}}export function attachMarkedSpans(e,t){if(t){for(let n=0;n<t.length;++n)t[n].marker.attachLine(e);e.markedSpans=t}}function extraLeft(e){return e.inclusiveLeft?-1:0}function extraRight(e){return e.inclusiveRight?1:0}export function compareCollapsedMarkers(e,t){let n=e.lines.length-t.lines.length;if(0!=n)return n;let r=e.find(),l=t.find(),i=cmp(r.from,l.from)||extraLeft(e)-extraLeft(t);if(i)return-i;let a=cmp(r.to,l.to)||extraRight(e)-extraRight(t);return a||t.id-e.id}function collapsedSpanAtSide(e,t){let n,r=sawCollapsedSpans&&e.markedSpans;if(r)for(let l,i=0;i<r.length;++i)l=r[i],l.marker.collapsed&&null==(t?l.from:l.to)&&(!n||compareCollapsedMarkers(n,l.marker)<0)&&(n=l.marker);return n}export function collapsedSpanAtStart(e){return collapsedSpanAtSide(e,!0)}export function collapsedSpanAtEnd(e){return collapsedSpanAtSide(e,!1)}export function collapsedSpanAround(e,t){let n,r=sawCollapsedSpans&&e.markedSpans;if(r)for(let l=0;l<r.length;++l){let e=r[l];e.marker.collapsed&&(null==e.from||e.from<t)&&(null==e.to||e.to>t)&&(!n||compareCollapsedMarkers(n,e.marker)<0)&&(n=e.marker)}return n}export function conflictingCollapsedRange(e,t,n,r,l){let i=getLine(e,t),a=sawCollapsedSpans&&i.markedSpans;if(a)for(let o=0;o<a.length;++o){let e=a[o];if(!e.marker.collapsed)continue;let t=e.marker.find(0),i=cmp(t.from,n)||extraLeft(e.marker)-extraLeft(l),f=cmp(t.to,r)||extraRight(e.marker)-extraRight(l);if(!(i>=0&&f<=0||i<=0&&f>=0)&&(i<=0&&(e.marker.inclusiveRight&&l.inclusiveLeft?cmp(t.to,n)>=0:cmp(t.to,n)>0)||i>=0&&(e.marker.inclusiveRight&&l.inclusiveLeft?cmp(t.from,r)<=0:cmp(t.from,r)<0)))return!0}}export function visualLine(e){let t;for(;t=collapsedSpanAtStart(e);)e=t.find(-1,!0).line;return e}export function visualLineEnd(e){let t;for(;t=collapsedSpanAtEnd(e);)e=t.find(1,!0).line;return e}export function visualLineContinued(e){let t,n;for(;t=collapsedSpanAtEnd(e);)e=t.find(1,!0).line,(n||(n=[])).push(e);return n}export function visualLineNo(e,t){let n=getLine(e,t),r=visualLine(n);return n==r?t:lineNo(r)}export function visualLineEndNo(e,t){if(t>e.lastLine())return t;let n,r=getLine(e,t);if(!lineIsHidden(e,r))return t;for(;n=collapsedSpanAtEnd(r);)r=n.find(1,!0).line;return lineNo(r)+1}export function lineIsHidden(e,t){let n=sawCollapsedSpans&&t.markedSpans;if(n)for(let r,l=0;l<n.length;++l)if(r=n[l],r.marker.collapsed){if(null==r.from)return!0;if(!r.marker.widgetNode&&0==r.from&&r.marker.inclusiveLeft&&lineIsHiddenInner(e,t,r))return!0}}function lineIsHiddenInner(e,t,n){if(null==n.to){let t=n.marker.find(1,!0);return lineIsHiddenInner(e,t.line,getMarkedSpanFor(t.line.markedSpans,n.marker))}if(n.marker.inclusiveRight&&n.to==t.text.length)return!0;for(let r,l=0;l<t.markedSpans.length;++l)if(r=t.markedSpans[l],r.marker.collapsed&&!r.marker.widgetNode&&r.from==n.to&&(null==r.to||r.to!=n.from)&&(r.marker.inclusiveLeft||n.marker.inclusiveRight)&&lineIsHiddenInner(e,t,r))return!0}export function heightAtLine(e){let t=0,n=(e=visualLine(e)).parent;for(let r=0;r<n.lines.length;++r){let l=n.lines[r];if(l==e)break;t+=l.height}for(let r=n.parent;r;n=r,r=n.parent)for(let e=0;e<r.children.length;++e){let l=r.children[e];if(l==n)break;t+=l.height}return t}export function lineLength(e){if(0==e.height)return 0;let t,n=e.text.length,r=e;for(;t=collapsedSpanAtStart(r);){let e=t.find(0,!0);r=e.from.line,n+=e.from.ch-e.to.ch}for(r=e;t=collapsedSpanAtEnd(r);){let e=t.find(0,!0);n-=r.text.length-e.from.ch,r=e.to.line,n+=r.text.length-e.to.ch}return n}export function findMaxLine(e){let t=e.display,n=e.doc;t.maxLine=getLine(n,n.first),t.maxLineLength=lineLength(t.maxLine),t.maxLineChanged=!0,n.iter((e=>{let n=lineLength(e);n>t.maxLineLength&&(t.maxLineLength=n,t.maxLine=e)}))}