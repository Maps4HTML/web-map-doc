{"version":3,"file":"layer.js","sources":["../src/layer.js"],"sourcesContent":["import './leaflet.js'; // a lightly modified version of Leaflet for use as browser module\nimport './mapml.js'; // modified URI to make the function a property of window scope (possibly a bad thing to do).\n\nexport class MapLayer extends HTMLElement {\n  static get observedAttributes() {\n    return ['src', 'label', 'checked', 'hidden', 'opacity'];\n  }\n  get src() {\n    return this.hasAttribute('src') ? this.getAttribute('src') : '';\n  }\n\n  set src(val) {\n    if (val) {\n      this.setAttribute('src', val);\n    }\n  }\n  get label() {\n    return this.hasAttribute('label') ? this.getAttribute('label') : '';\n  }\n  set label(val) {\n    if (val) {\n      this.setAttribute('label', val);\n    }\n  }\n  get checked() {\n    return this.hasAttribute('checked');\n  }\n\n  set checked(val) {\n    if (val) {\n      this.setAttribute('checked', '');\n    } else {\n      this.removeAttribute('checked');\n    }\n  }\n\n  get hidden() {\n    return this.hasAttribute('hidden');\n  }\n\n  set hidden(val) {\n    if (val) {\n      this.setAttribute('hidden', '');\n    } else {\n      this.removeAttribute('hidden');\n    }\n  }\n\n  get opacity() {\n    return this._layer._container.style.opacity || this._layer.options.opacity;\n  }\n\n  set opacity(val) {\n    if (+val > 1 || +val < 0) return;\n    this._layer.changeOpacity(val);\n  }\n\n  constructor() {\n    // Always call super first in constructor\n    super();\n  }\n  disconnectedCallback() {\n    //    console.log('Custom map element removed from page.');\n    // if the map-layer node is removed from the dom, the layer should be\n    // removed from the map and the layer control\n\n    // this is moved up here so that the layer control doesn't respond\n    // to the layer being removed with the _onLayerChange execution\n    // that is set up in _attached:\n    if (this.hasAttribute('data-moving')) return;\n    this._onRemove();\n  }\n\n  _onRemove() {\n    this._removeEvents();\n    if (this._layer._map) {\n      this._layer._map.removeLayer(this._layer);\n    }\n\n    if (this._layerControl && !this.hidden) {\n      this._layerControl.removeLayer(this._layer);\n    }\n\n    if (this.shadowRoot) {\n      this.shadowRoot.innerHTML = '';\n    }\n  }\n\n  connectedCallback() {\n    if (this.hasAttribute('data-moving')) return;\n    this._onAdd();\n  }\n\n  _onAdd() {\n    if (this.getAttribute('src') && !this.shadowRoot) {\n      this.attachShadow({ mode: 'open' });\n    }\n    //creates listener that waits for createmap event, this allows for delayed builds of maps\n    //this allows a safeguard for the case where loading a custom TCRS takes longer than loading mapml-viewer.js/web-map.js\n    this.parentNode.addEventListener(\n      'createmap',\n      () => {\n        this._ready();\n        // if the map has been attached, set this layer up wrt Leaflet map\n        if (this.parentNode._map) {\n          this._attachedToMap();\n        }\n        if (this._layerControl && !this.hidden) {\n          this._layerControl.addOrUpdateOverlay(this._layer, this.label);\n        }\n      },\n      { once: true }\n    ); //listener stops listening after event occurs once\n    //if map is already created then dispatch createmap event, allowing layer to be built\n    if (this.parentNode._map)\n      this.parentNode.dispatchEvent(new CustomEvent('createmap'));\n  }\n\n  adoptedCallback() {\n    //    console.log('Custom map element moved to new page.');\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    switch (name) {\n      case 'label':\n        if (oldValue !== newValue) {\n          this.dispatchEvent(\n            new CustomEvent('labelchanged', { detail: { target: this } })\n          );\n        }\n        break;\n      case 'checked':\n        if (this._layer) {\n          if (typeof newValue === 'string') {\n            this.parentElement._map.addLayer(this._layer);\n          } else {\n            this.parentElement._map.removeLayer(this._layer);\n          }\n          this.dispatchEvent(new Event('change', { bubbles: true }));\n        }\n        break;\n      case 'hidden':\n        var map = this.parentElement && this.parentElement._map;\n        if (map && this.parentElement.controls) {\n          if (typeof newValue === 'string') {\n            if (this._layer) {\n              this.parentElement._layerControl.removeLayer(this._layer);\n            }\n          } else {\n            this._layerControl = this.parentElement._layerControl;\n            this._layerControl.addOrUpdateOverlay(this._layer, this.label);\n            this._validateDisabled();\n          }\n        }\n        break;\n      case 'opacity':\n        if (oldValue !== newValue && this._layer) {\n          this.opacity = newValue;\n        }\n        break;\n      case 'src':\n        if (oldValue !== newValue && this._layer) {\n          this._reload();\n          // the original inline content will not be removed\n          // but has NO EFFECT and works as a fallback\n        }\n    }\n  }\n  // re-load the layer element when the src attribute is changed\n  _reload() {\n    let oldOpacity = this.opacity;\n    // go through the same sequence as if the layer had been removed from\n    // the DOM and re-attached with a new URL source.\n    this._onRemove();\n    if (this.isConnected) {\n      this._onAdd();\n    }\n    this.opacity = oldOpacity;\n  }\n  _onLayerExtentLoad(e) {\n    // the mapml document associated to this layer can in theory contain many\n    // link[@rel=legend] elements with different @type or other attributes;\n    // currently only support a single link, don't care about type, lang etc.\n    // TODO: add support for full LayerLegend object, and > one link.\n    if (this._layer._legendUrl) {\n      this.legendLinks = [\n        {\n          type: 'application/octet-stream',\n          href: this._layer._legendUrl,\n          rel: 'legend',\n          lang: null,\n          hreflang: null,\n          sizes: null\n        }\n      ];\n    }\n    if (this._layer._title) {\n      this.label = this._layer._title;\n    }\n    // make sure local content layer has the chance to set its extent properly\n    // which is important for the layer control and the disabled property\n    if (this._layer._map) {\n      this._layer.fire('attached', this._layer);\n    }\n    // TODO ensure the controls in this._layerControl contain 'live' controls\n    // which control the layer, not potentially the previous style / src\n    if (this._layerControl) {\n      this._layerControl.addOrUpdateOverlay(this._layer, this.label);\n    }\n    if (!this._layer.error) {\n      // re-use 'loadedmetadata' event from HTMLMediaElement inteface, applied\n      // to MapML extent as metadata\n      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadedmetadata_event\n      this.dispatchEvent(\n        new CustomEvent('loadedmetadata', { detail: { target: this } })\n      );\n    } else {\n      this.dispatchEvent(\n        new CustomEvent('error', { detail: { target: this } })\n      );\n    }\n  }\n  _validateDisabled() {\n    setTimeout(() => {\n      let layer = this._layer,\n        map = layer?._map;\n      if (map) {\n        let count = 0,\n          total = 0,\n          layerTypes = [\n            '_staticTileLayer',\n            '_imageLayer',\n            '_mapmlvectors',\n            '_templatedLayer'\n          ];\n        if (layer.validProjection) {\n          for (let j = 0; j < layerTypes.length; j++) {\n            let type = layerTypes[j];\n            if (this.checked && layer[type]) {\n              if (type === '_templatedLayer') {\n                for (let i = 0; i < layer._extent._mapExtents.length; i++) {\n                  for (\n                    let j = 0;\n                    j <\n                    layer._extent._mapExtents[i].templatedLayer._templates\n                      .length;\n                    j++\n                  ) {\n                    if (\n                      layer._extent._mapExtents[i].templatedLayer._templates[j]\n                        .rel === 'query'\n                    )\n                      continue;\n                    total++;\n                    layer._extent._mapExtents[i].removeAttribute('disabled');\n                    layer._extent._mapExtents[i].disabled = false;\n                    if (\n                      !layer._extent._mapExtents[i].templatedLayer._templates[j]\n                        .layer.isVisible\n                    ) {\n                      count++;\n                      layer._extent._mapExtents[i].setAttribute('disabled', '');\n                      layer._extent._mapExtents[i].disabled = true;\n                    }\n                  }\n                }\n              } else {\n                total++;\n                if (!layer[type].isVisible) count++;\n              }\n            }\n          }\n        } else {\n          count = 1;\n          total = 1;\n        }\n\n        if (count === total && count !== 0) {\n          this.setAttribute('disabled', ''); //set a disabled attribute on the layer element\n          this.disabled = true;\n        } else {\n          //might be better not to disable the layer controls, might want to deselect layer even when its out of bounds\n          this.removeAttribute('disabled');\n          this.disabled = false;\n        }\n        map.fire('validate');\n      }\n    }, 0);\n  }\n  getOuterHTML() {\n    let tempElement = this.cloneNode(true);\n\n    if (this.hasAttribute('src')) {\n      let newSrc = this._layer.getHref();\n      tempElement.setAttribute('src', newSrc);\n    }\n    if (this.querySelector('map-link')) {\n      let mapLinks = tempElement.querySelectorAll('map-link');\n\n      mapLinks.forEach((mapLink) => {\n        if (mapLink.hasAttribute('href')) {\n          mapLink.setAttribute(\n            'href',\n            decodeURI(\n              new URL(\n                mapLink.attributes.href.value,\n                this.baseURI ? this.baseURI : document.baseURI\n              ).href\n            )\n          );\n        } else if (mapLink.hasAttribute('tref')) {\n          mapLink.setAttribute(\n            'tref',\n            decodeURI(\n              new URL(\n                mapLink.attributes.tref.value,\n                this.baseURI ? this.baseURI : document.baseURI\n              ).href\n            )\n          );\n        }\n      });\n    }\n\n    let outerLayer = tempElement.outerHTML;\n\n    tempElement.remove();\n\n    return outerLayer;\n  }\n\n  _onLayerChange() {\n    if (this._layer._map) {\n      // can't disable observers, have to set a flag telling it where\n      // the 'event' comes from: either the api or a user click/tap\n      // may not be necessary -> this._apiToggleChecked = false;\n      this.checked = this._layer._map.hasLayer(this._layer);\n    }\n  }\n  _ready() {\n    // the layer might not be attached to a map\n    // so we need a way for non-src based layers to establish what their\n    // zoom range, extent and projection are.  meta elements in content to\n    // allow the author to provide this explicitly are one way, they will\n    // be parsed from the second parameter here\n    // IE 11 did not have a value for this.baseURI for some reason\n    var base = this.baseURI ? this.baseURI : document.baseURI;\n    let opacity_value = this.hasAttribute('opacity')\n      ? this.getAttribute('opacity')\n      : '1.0';\n    this._layer = M.mapMLLayer(\n      this.src ? new URL(this.src, base).href : null,\n      this,\n      {\n        mapprojection: this.parentElement._map.options.projection,\n        opacity: opacity_value\n      }\n    );\n    this._layer.on('extentload', this._onLayerExtentLoad, this);\n    this._setUpEvents();\n  }\n  _attachedToMap() {\n    // set i to the position of this layer element in the set of layers\n    var i = 0,\n      position = 1;\n    for (var nodes = this.parentNode.children; i < nodes.length; i++) {\n      if (this.parentNode.children[i].nodeName === 'LAYER-') {\n        if (this.parentNode.children[i] === this) {\n          position = i + 1;\n        } else if (this.parentNode.children[i]._layer) {\n          this.parentNode.children[i]._layer.setZIndex(i + 1);\n        }\n      }\n    }\n    var proj = this.parentNode.projection\n      ? this.parentNode.projection\n      : 'OSMTILE';\n    L.setOptions(this._layer, {\n      zIndex: position,\n      mapprojection: proj,\n      opacity: window.getComputedStyle(this).opacity\n    });\n    // make sure the Leaflet layer has a reference to the map\n    this._layer._map = this.parentNode._map;\n    // notify the layer that it is attached to a map (layer._map)\n    this._layer.fire('attached');\n\n    if (this.checked) {\n      this._layer.addTo(this._layer._map);\n    }\n\n    // add the handler which toggles the 'checked' property based on the\n    // user checking/unchecking the layer from the layer control\n    // this must be done *after* the layer is actually added to the map\n    this._layer.on('add remove', this._onLayerChange, this);\n    this._layer.on('add remove extentload', this._validateDisabled, this);\n\n    // if controls option is enabled, insert the layer into the overlays array\n    if (this.parentNode._layerControl && !this.hidden) {\n      this._layerControl = this.parentNode._layerControl;\n      this._layerControl.addOrUpdateOverlay(this._layer, this.label);\n    }\n    // toggle the this.disabled attribute depending on whether the layer\n    // is: same prj as map, within view/zoom of map\n    this._layer._map.on('moveend', this._validateDisabled, this);\n    this._layer._map.on('checkdisabled', this._validateDisabled, this);\n    // this is necessary to get the layer control to compare the layer\n    // extents with the map extent & zoom, but it needs to be rethought TODO\n    // for one thing, layers which are checked by the author before\n    // adding to the map are displayed despite that they are not visible\n    // See issue #26\n    //        this._layer._map.fire('moveend');\n  }\n  _removeEvents() {\n    if (this._layer) {\n      this._layer.off();\n    }\n  }\n  _setUpEvents() {\n    this._layer.on(\n      'loadstart',\n      function () {\n        this.dispatchEvent(\n          new CustomEvent('loadstart', { detail: { target: this } })\n        );\n      },\n      this\n    );\n    this._layer.on(\n      'changestyle',\n      function (e) {\n        this.src = e.src;\n        this.dispatchEvent(\n          new CustomEvent('changestyle', { detail: { target: this } })\n        );\n      },\n      this\n    );\n    this._layer.on(\n      'changeprojection',\n      function (e) {\n        this.src = e.href;\n        this.dispatchEvent(\n          new CustomEvent('changeprojection', { detail: { target: this } })\n        );\n      },\n      this\n    );\n  }\n  zoomTo() {\n    if (!this.extent) return;\n    let map = this._layer._map,\n      tL = this.extent.topLeft.pcrs,\n      bR = this.extent.bottomRight.pcrs,\n      layerBounds = L.bounds(\n        L.point(tL.horizontal, tL.vertical),\n        L.point(bR.horizontal, bR.vertical)\n      ),\n      center = map.options.crs.unproject(layerBounds.getCenter(true));\n\n    let maxZoom = this.extent.zoom.maxZoom,\n      minZoom = this.extent.zoom.minZoom;\n    map.setView(center, M.getMaxZoom(layerBounds, map, minZoom, maxZoom), {\n      animate: false\n    });\n  }\n  mapml2geojson(options = {}) {\n    return M.mapml2geojson(this, options);\n  }\n  pasteFeature(feature) {\n    switch (typeof feature) {\n      case 'string':\n        feature.trim();\n        if (\n          feature.slice(0, 12) === '<map-feature' &&\n          feature.slice(-14) === '</map-feature>'\n        ) {\n          this.insertAdjacentHTML('beforeend', feature);\n        }\n        break;\n      case 'object':\n        if (feature.nodeName.toUpperCase() === 'MAP-FEATURE') {\n          this.appendChild(feature);\n        }\n    }\n  }\n}\n"],"names":["MapLayer","HTMLElement","observedAttributes","src","this","hasAttribute","getAttribute","val","setAttribute","label","checked","removeAttribute","hidden","opacity","_layer","_container","style","options","changeOpacity","constructor","super","disconnectedCallback","_onRemove","_removeEvents","_map","removeLayer","_layerControl","shadowRoot","innerHTML","connectedCallback","_onAdd","attachShadow","mode","parentNode","addEventListener","_ready","_attachedToMap","addOrUpdateOverlay","once","dispatchEvent","CustomEvent","adoptedCallback","attributeChangedCallback","name","oldValue","newValue","detail","target","parentElement","addLayer","Event","bubbles","controls","_validateDisabled","_reload","let","oldOpacity","isConnected","_onLayerExtentLoad","e","_legendUrl","legendLinks","type","href","rel","lang","hreflang","sizes","_title","fire","error","setTimeout","layer","map","count","total","layerTypes","validProjection","j","length","i","_extent","_mapExtents","templatedLayer","_templates","disabled","isVisible","getOuterHTML","tempElement","cloneNode","newSrc","getHref","querySelector","mapLinks","querySelectorAll","forEach","mapLink","decodeURI","URL","attributes","value","baseURI","document","tref","outerLayer","outerHTML","remove","_onLayerChange","hasLayer","base","opacity_value","M","mapMLLayer","mapprojection","projection","on","_setUpEvents","position","nodes","children","nodeName","setZIndex","proj","L","setOptions","zIndex","window","getComputedStyle","addTo","off","zoomTo","extent","tL","topLeft","pcrs","bR","bottomRight","layerBounds","bounds","point","horizontal","vertical","center","crs","unproject","getCenter","maxZoom","zoom","minZoom","setView","getMaxZoom","animate","mapml2geojson","pasteFeature","feature","trim","slice","insertAdjacentHTML","toUpperCase","appendChild"],"mappings":"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"}