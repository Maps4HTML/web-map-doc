{"version":3,"file":"layer.js","sources":["../src/layer.js"],"sourcesContent":["import './leaflet.js'; // a lightly modified version of Leaflet for use as browser module\nimport './mapml.js'; // modified URI to make the function a property of window scope (possibly a bad thing to do).\n\nexport class MapLayer extends HTMLElement {\n  static get observedAttributes() {\n    return ['src', 'label', 'checked', 'hidden', 'opacity'];\n  }\n  get src() {\n    return this.hasAttribute('src') ? this.getAttribute('src') : '';\n  }\n\n  set src(val) {\n    if (val) {\n      this.setAttribute('src', val);\n    }\n  }\n  get label() {\n    if (this._layer) return this._layer.getName();\n    else return this.hasAttribute('label') ? this.getAttribute('label') : '';\n  }\n  set label(val) {\n    if (val) {\n      this.setAttribute('label', val);\n    }\n  }\n  get checked() {\n    return this.hasAttribute('checked');\n  }\n\n  set checked(val) {\n    if (val) {\n      this.setAttribute('checked', '');\n    } else {\n      this.removeAttribute('checked');\n    }\n  }\n\n  get hidden() {\n    return this.hasAttribute('hidden');\n  }\n\n  set hidden(val) {\n    if (val) {\n      this.setAttribute('hidden', '');\n    } else {\n      this.removeAttribute('hidden');\n    }\n  }\n\n  get opacity() {\n    // use ?? since 0 is falsy, || would return rhs in that case\n    return +(this._opacity ?? this.getAttribute('opacity'));\n  }\n\n  set opacity(val) {\n    if (+val > 1 || +val < 0) return;\n    this.setAttribute('opacity', val);\n  }\n\n  get extent() {\n    // calculate the bounds of all content, return it.\n    if (!this._layer.bounds) {\n      this._layer._calculateBounds();\n    }\n    return Object.assign(\n      M._convertAndFormatPCRS(\n        this._layer.bounds,\n        this._layer._properties.crs,\n        this._layer._properties.projection\n      ),\n      { zoom: this._layer.zoomBounds }\n    );\n  }\n\n  constructor() {\n    // Always call super first in constructor\n    super();\n  }\n  disconnectedCallback() {\n    // if the map-layer node is removed from the dom, the layer should be\n    // removed from the map and the layer control\n    if (this.hasAttribute('data-moving')) return;\n    this._onRemove();\n  }\n\n  _onRemove() {\n    if (this._layer) {\n      this._layer.off();\n    }\n    // if this layer has never been connected, it will not have a _layer\n    if (this._layer && this._layer._map) {\n      this._layer._map.removeLayer(this._layer);\n    }\n\n    if (this._layerControl && !this.hidden) {\n      this._layerControl.removeLayer(this._layer);\n    }\n    delete this._layer;\n    delete this._fetchError;\n\n    if (this.shadowRoot) {\n      this.shadowRoot.innerHTML = '';\n    }\n  }\n\n  connectedCallback() {\n    if (this.hasAttribute('data-moving')) return;\n    this._createLayerControlHTML = M._createLayerControlHTML.bind(this);\n    // this._opacity is used to record the current opacity value (with or without updates),\n    // the initial value of this._opacity should be set as opacity attribute value, if exists, or the default value 1.0\n    this._opacity = +(this.getAttribute('opacity') || 1.0);\n    const doConnected = this._onAdd.bind(this);\n    this.parentElement\n      .whenReady()\n      .then(() => {\n        doConnected();\n      })\n      .catch(() => {\n        throw new Error('Map never became ready');\n      });\n  }\n\n  _onAdd() {\n    if (this.getAttribute('src') && !this.shadowRoot) {\n      this.attachShadow({ mode: 'open' });\n    }\n    new Promise((resolve, reject) => {\n      this.addEventListener(\n        'changestyle',\n        function (e) {\n          e.stopPropagation();\n          this.src = e.detail.src;\n        },\n        { once: true }\n      );\n      this.addEventListener(\n        'changeprojection',\n        function (e) {\n          e.stopPropagation();\n          reject(e);\n        },\n        { once: true }\n      );\n      let base = this.baseURI ? this.baseURI : document.baseURI;\n\n      const headers = new Headers();\n      headers.append('Accept', 'text/mapml');\n      if (this.src) {\n        fetch(this.src, { headers: headers })\n          .then((response) => {\n            if (!response.ok) {\n              throw new Error(`HTTP error! Status: ${response.status}`);\n            }\n            return response.text();\n          })\n          .then((mapml) => {\n            let content = new DOMParser().parseFromString(mapml, 'text/xml');\n            if (\n              content.querySelector('parsererror') ||\n              !content.querySelector('mapml-')\n            ) {\n              throw new Error('Parser error');\n            }\n            if (this._layer) {\n              this._onRemove();\n            }\n            this._layer = M.mapMLLayer(\n              new URL(this.src, base).href,\n              this,\n              content,\n              {\n                mapprojection: this.parentElement.projection,\n                opacity: this.opacity\n              }\n            );\n            this._createLayerControlHTML();\n            this._attachedToMap();\n            this._validateDisabled();\n            resolve();\n          })\n          .catch((error) => {\n            this._fetchError = true;\n            console.log('Error fetching layer content' + error);\n          });\n      } else {\n        if (this._layer) {\n          this._onRemove();\n        }\n        this._layer = M.mapMLLayer(null, this, null, {\n          mapprojection: this.parentElement.projection,\n          opacity: this.opacity\n        });\n        this._createLayerControlHTML();\n        this._attachedToMap();\n        this._validateDisabled();\n        resolve();\n      }\n    }).catch((e) => {\n      if (e.type === 'changeprojection') {\n        this.src = e.detail.href;\n      } else {\n        console.log(e);\n        this.dispatchEvent(\n          new CustomEvent('error', { detail: { target: this } })\n        );\n      }\n    });\n  }\n  _attachedToMap() {\n    // set i to the position of this layer element in the set of layers\n    var i = 0,\n      position = 1;\n    for (var nodes = this.parentNode.children; i < nodes.length; i++) {\n      if (this.parentNode.children[i].nodeName === 'LAYER-') {\n        if (this.parentNode.children[i] === this) {\n          position = i + 1;\n        } else if (this.parentNode.children[i]._layer) {\n          this.parentNode.children[i]._layer.setZIndex(i + 1);\n        }\n      }\n    }\n    var proj = this.parentNode.projection\n      ? this.parentNode.projection\n      : 'OSMTILE';\n    L.setOptions(this._layer, {\n      zIndex: position,\n      mapprojection: proj,\n      opacity: window.getComputedStyle(this).opacity\n    });\n    // make sure the Leaflet layer has a reference to the map\n    this._layer._map = this.parentNode._map;\n\n    if (this.checked) {\n      this._layer.addTo(this._layer._map);\n    }\n\n    this._layer.on('add remove', this._validateDisabled, this);\n    // toggle the this.disabled attribute depending on whether the layer\n    // is: same prj as map, within view/zoom of map\n    this._layer._map.on('moveend layeradd', this._validateDisabled, this);\n\n    // if controls option is enabled, insert the layer into the overlays array\n    if (this.parentNode._layerControl && !this.hidden) {\n      this._layerControl = this.parentNode._layerControl;\n      this._layerControl.addOrUpdateOverlay(this._layer, this.label);\n    }\n\n    // the mapml document associated to this layer can in theory contain many\n    // link[@rel=legend] elements with different @type or other attributes;\n    // currently only support a single link, don't care about type, lang etc.\n    // TODO: add support for full LayerLegend object, and > one link.\n    if (this._layer._legendUrl) {\n      this.legendLinks = [\n        {\n          type: 'application/octet-stream',\n          href: this._layer._legendUrl,\n          rel: 'legend',\n          lang: null,\n          hreflang: null,\n          sizes: null\n        }\n      ];\n    }\n    // re-use 'loadedmetadata' event from HTMLMediaElement inteface, applied\n    // to MapML extent as metadata\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadedmetadata_event\n    this.dispatchEvent(\n      new CustomEvent('loadedmetadata', { detail: { target: this } })\n    );\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    switch (name) {\n      case 'label':\n        this.whenReady()\n          .then(() => {\n            this._layer.setName(newValue);\n          })\n          .catch((e) => {\n            console.log(e);\n          });\n        break;\n      case 'checked':\n        this.whenReady()\n          .then(() => {\n            if (typeof newValue === 'string') {\n              this.parentElement._map.addLayer(this._layer);\n            } else {\n              this.parentElement._map.removeLayer(this._layer);\n            }\n            this._layerControlCheckbox.checked = this.checked;\n            this.dispatchEvent(new CustomEvent('map-change'));\n          })\n          .catch((e) => {\n            console.log(e);\n          });\n        break;\n      case 'hidden':\n        var map = this.parentElement && this.parentElement._map;\n        if (map && this.parentElement.controls) {\n          if (typeof newValue === 'string') {\n            if (this._layer) {\n              this.parentElement._layerControl.removeLayer(this._layer);\n            }\n          } else {\n            this._layerControl = this.parentElement._layerControl;\n            this._layerControl.addOrUpdateOverlay(this._layer, this.label);\n            this._validateDisabled();\n          }\n        }\n        break;\n      case 'opacity':\n        if (oldValue !== newValue && this._layer) {\n          this._opacity = newValue;\n          this._layer.changeOpacity(newValue);\n        }\n        break;\n      case 'src':\n        if (oldValue !== newValue && this._layer) {\n          this._onRemove();\n          if (this.isConnected) {\n            this._onAdd();\n          }\n          // the original inline content will not be removed\n          // but has NO EFFECT and works as a fallback\n        }\n    }\n  }\n  _validateDisabled() {\n    // setTimeout is necessary to make the validateDisabled happen later than the moveend operations etc.,\n    // to ensure that the validated result is correct\n    setTimeout(() => {\n      let layer = this._layer,\n        map = layer?._map;\n      if (map) {\n        // prerequisite: no inline and remote mapml elements exists at the same time\n        const mapExtents = this.shadowRoot\n          ? this.shadowRoot.querySelectorAll('map-extent')\n          : this.querySelectorAll('map-extent');\n        let disabledExtentCount = 0,\n          totalExtentCount = 0,\n          layerTypes = [\n            '_staticTileLayer',\n            '_imageLayer',\n            '_mapmlvectors',\n            '_templatedLayer'\n          ];\n        if (layer.validProjection) {\n          for (let j = 0; j < layerTypes.length; j++) {\n            let type = layerTypes[j];\n            if (this.checked) {\n              if (type === '_templatedLayer' && mapExtents.length > 0) {\n                for (let i = 0; i < mapExtents.length; i++) {\n                  totalExtentCount++;\n                  if (mapExtents[i]._validateDisabled()) disabledExtentCount++;\n                }\n              } else if (layer[type]) {\n                // not a templated layer\n                totalExtentCount++;\n                if (!layer[type].isVisible) disabledExtentCount++;\n              }\n            }\n          }\n        } else {\n          disabledExtentCount = 1;\n          totalExtentCount = 1;\n        }\n        // if all extents are not visible / disabled, set layer to disabled\n        if (\n          disabledExtentCount === totalExtentCount &&\n          disabledExtentCount !== 0\n        ) {\n          this.setAttribute('disabled', '');\n          this.disabled = true;\n        } else {\n          this.removeAttribute('disabled');\n          this.disabled = false;\n        }\n        this.toggleLayerControlDisabled();\n      }\n    }, 0);\n  }\n\n  // disable/italicize layer control elements based on the layer-.disabled property\n  toggleLayerControlDisabled() {\n    let input = this._layerControlCheckbox,\n      label = this._layerControlLabel,\n      opacityControl = this._opacityControl,\n      opacitySlider = this._opacitySlider,\n      styleControl = this._styles;\n    if (this.disabled) {\n      input.disabled = true;\n      opacitySlider.disabled = true;\n      label.style.fontStyle = 'italic';\n      opacityControl.style.fontStyle = 'italic';\n      if (styleControl) {\n        styleControl.style.fontStyle = 'italic';\n        styleControl.querySelectorAll('input').forEach((i) => {\n          i.disabled = true;\n        });\n      }\n    } else {\n      input.disabled = false;\n      opacitySlider.disabled = false;\n      label.style.fontStyle = 'normal';\n      opacityControl.style.fontStyle = 'normal';\n      if (styleControl) {\n        styleControl.style.fontStyle = 'normal';\n        styleControl.querySelectorAll('input').forEach((i) => {\n          i.disabled = false;\n        });\n      }\n    }\n  }\n\n  getOuterHTML() {\n    let tempElement = this.cloneNode(true);\n\n    if (this.hasAttribute('src')) {\n      let newSrc = this._layer.getHref();\n      tempElement.setAttribute('src', newSrc);\n    }\n    if (this.querySelector('map-link')) {\n      let mapLinks = tempElement.querySelectorAll('map-link');\n\n      mapLinks.forEach((mapLink) => {\n        if (mapLink.hasAttribute('href')) {\n          mapLink.setAttribute(\n            'href',\n            decodeURI(\n              new URL(\n                mapLink.attributes.href.value,\n                this.baseURI ? this.baseURI : document.baseURI\n              ).href\n            )\n          );\n        } else if (mapLink.hasAttribute('tref')) {\n          mapLink.setAttribute(\n            'tref',\n            decodeURI(\n              new URL(\n                mapLink.attributes.tref.value,\n                this.baseURI ? this.baseURI : document.baseURI\n              ).href\n            )\n          );\n        }\n      });\n    }\n\n    let outerLayer = tempElement.outerHTML;\n\n    tempElement.remove();\n\n    return outerLayer;\n  }\n\n  zoomTo() {\n    this.whenElemsReady().then(() => {\n      let map = this.parentElement._map,\n        extent = this.extent,\n        tL = extent.topLeft.pcrs,\n        bR = extent.bottomRight.pcrs,\n        layerBounds = L.bounds(\n          L.point(tL.horizontal, tL.vertical),\n          L.point(bR.horizontal, bR.vertical)\n        ),\n        center = map.options.crs.unproject(layerBounds.getCenter(true));\n\n      let maxZoom = extent.zoom.maxZoom,\n        minZoom = extent.zoom.minZoom;\n      map.setView(center, M.getMaxZoom(layerBounds, map, minZoom, maxZoom), {\n        animate: false\n      });\n    });\n  }\n  mapml2geojson(options = {}) {\n    return M.mapml2geojson(this, options);\n  }\n  pasteFeature(feature) {\n    switch (typeof feature) {\n      case 'string':\n        feature.trim();\n        if (\n          feature.slice(0, 12) === '<map-feature' &&\n          feature.slice(-14) === '</map-feature>'\n        ) {\n          this.insertAdjacentHTML('beforeend', feature);\n        }\n        break;\n      case 'object':\n        if (feature.nodeName.toUpperCase() === 'MAP-FEATURE') {\n          this.appendChild(feature);\n        }\n    }\n  }\n  whenReady() {\n    return new Promise((resolve, reject) => {\n      let interval, failureTimer;\n      if (this._layer && (!this.src || this.shadowRoot?.childNodes.length)) {\n        resolve();\n      } else {\n        let layerElement = this;\n        interval = setInterval(testForLayer, 200, layerElement);\n        failureTimer = setTimeout(layerNotDefined, 5000);\n      }\n      function testForLayer(layerElement) {\n        if (\n          layerElement._layer &&\n          (!layerElement.src || layerElement.shadowRoot?.childNodes.length)\n        ) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          resolve();\n        } else if (layerElement._fetchError) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          reject('Error fetching layer content');\n        }\n      }\n      function layerNotDefined() {\n        clearInterval(interval);\n        clearTimeout(failureTimer);\n        reject('Timeout reached waiting for layer to be ready');\n      }\n    });\n  }\n  // check if all child elements are ready\n  whenElemsReady() {\n    let elemsReady = [];\n    let target = this.shadowRoot || this;\n    for (let elem of [\n      ...target.querySelectorAll('map-extent'),\n      ...target.querySelectorAll('map-feature')\n    ]) {\n      elemsReady.push(elem.whenReady());\n    }\n    return Promise.allSettled(elemsReady);\n  }\n}\n"],"names":["MapLayer","HTMLElement","observedAttributes","src","this","hasAttribute","getAttribute","val","setAttribute","label","_layer","getName","checked","removeAttribute","hidden","opacity","_opacity","extent","bounds","_calculateBounds","Object","assign","M","_convertAndFormatPCRS","_properties","crs","projection","zoom","zoomBounds","constructor","super","disconnectedCallback","_onRemove","off","_map","removeLayer","_layerControl","_fetchError","shadowRoot","innerHTML","connectedCallback","_createLayerControlHTML","bind","doConnected","_onAdd","parentElement","whenReady","then","catch","Error","attachShadow","mode","Promise","resolve","reject","addEventListener","e","stopPropagation","detail","once","let","base","baseURI","document","headers","Headers","append","fetch","response","ok","status","text","content","DOMParser","parseFromString","mapml","querySelector","mapMLLayer","URL","href","mapprojection","_attachedToMap","_validateDisabled","console","log","error","type","dispatchEvent","CustomEvent","target","i","position","nodes","parentNode","children","length","nodeName","setZIndex","proj","L","setOptions","zIndex","window","getComputedStyle","addTo","on","addOrUpdateOverlay","_legendUrl","legendLinks","rel","lang","hreflang","sizes","attributeChangedCallback","name","oldValue","newValue","setName","addLayer","_layerControlCheckbox","controls","changeOpacity","isConnected","setTimeout","layer","mapExtents","querySelectorAll","disabledExtentCount","totalExtentCount","layerTypes","validProjection","j","isVisible","disabled","toggleLayerControlDisabled","input","_layerControlLabel","opacityControl","_opacityControl","opacitySlider","_opacitySlider","styleControl","_styles","style","fontStyle","forEach","getOuterHTML","tempElement","cloneNode","newSrc","getHref","mapLinks","mapLink","decodeURI","attributes","value","tref","outerLayer","outerHTML","remove","zoomTo","whenElemsReady","map","tL","topLeft","pcrs","bR","bottomRight","layerBounds","point","horizontal","vertical","center","options","unproject","getCenter","maxZoom","minZoom","setView","getMaxZoom","animate","mapml2geojson","pasteFeature","feature","trim","slice","insertAdjacentHTML","toUpperCase","appendChild","interval","failureTimer","childNodes","setInterval","layerElement","clearInterval","clearTimeout","elemsReady","elem","push","allSettled"],"mappings":"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"}