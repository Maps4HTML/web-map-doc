{"version":3,"file":"layer.js","sources":["../src/layer.js"],"sourcesContent":["import './leaflet.js'; // a lightly modified version of Leaflet for use as browser module\nimport './mapml.js'; // modified URI to make the function a property of window scope (possibly a bad thing to do).\n\nexport class MapLayer extends HTMLElement {\n  static get observedAttributes() {\n    return ['src', 'label', 'checked', 'hidden', 'opacity'];\n  }\n  get src() {\n    return this.hasAttribute('src') ? this.getAttribute('src') : '';\n  }\n\n  set src(val) {\n    if (val) {\n      this.setAttribute('src', val);\n    }\n  }\n  get label() {\n    if (this._layer) return this._layer.getName();\n    else return this.hasAttribute('label') ? this.getAttribute('label') : '';\n  }\n  set label(val) {\n    if (val) {\n      this.setAttribute('label', val);\n    }\n  }\n  get checked() {\n    return this.hasAttribute('checked');\n  }\n\n  set checked(val) {\n    if (val) {\n      this.setAttribute('checked', '');\n    } else {\n      this.removeAttribute('checked');\n    }\n  }\n\n  get hidden() {\n    return this.hasAttribute('hidden');\n  }\n\n  set hidden(val) {\n    if (val) {\n      this.setAttribute('hidden', '');\n    } else {\n      this.removeAttribute('hidden');\n    }\n  }\n\n  get opacity() {\n    // use ?? since 0 is falsy, || would return rhs in that case\n    return this._opacity ?? this.getAttribute('opacity');\n  }\n\n  set opacity(val) {\n    if (+val > 1 || +val < 0) return;\n    this.setAttribute('opacity', val);\n  }\n\n  constructor() {\n    // Always call super first in constructor\n    super();\n  }\n  disconnectedCallback() {\n    //    console.log('Custom map element removed from page.');\n    // if the map-layer node is removed from the dom, the layer should be\n    // removed from the map and the layer control\n\n    // this is moved up here so that the layer control doesn't respond\n    // to the layer being removed with the _onLayerChange execution\n    // that is set up in _attached:\n    if (this.hasAttribute('data-moving')) return;\n    this._onRemove();\n  }\n\n  _onRemove() {\n    if (this._layer) {\n      this._layer.off();\n    }\n    // if this layer has never been connected, it will not have a _layer\n    if (this._layer && this._layer._map) {\n      this._layer._map.removeLayer(this._layer);\n    }\n\n    if (this._layerControl && !this.hidden) {\n      this._layerControl.removeLayer(this._layer);\n    }\n    delete this._layer;\n\n    if (this.shadowRoot) {\n      this.shadowRoot.innerHTML = '';\n    }\n  }\n\n  connectedCallback() {\n    if (this.hasAttribute('data-moving')) return;\n    const doConnected = this._onAdd.bind(this);\n    this.parentElement\n      .whenReady()\n      .then(() => {\n        doConnected();\n      })\n      .catch(() => {\n        throw new Error('Map never became ready');\n      });\n  }\n\n  _onAdd() {\n    if (this.getAttribute('src') && !this.shadowRoot) {\n      this.attachShadow({ mode: 'open' });\n    }\n    new Promise((resolve, reject) => {\n      this.addEventListener(\n        'changestyle',\n        function (e) {\n          e.stopPropagation();\n          this.src = e.detail.src;\n        },\n        { once: true }\n      );\n      this.addEventListener(\n        'changeprojection',\n        function (e) {\n          e.stopPropagation();\n          reject(e);\n        },\n        { once: true }\n      );\n      let base = this.baseURI ? this.baseURI : document.baseURI;\n\n      const headers = new Headers();\n      headers.append('Accept', 'text/mapml');\n      if (this.src) {\n        fetch(this.src, { headers: headers })\n          .then((response) => {\n            if (!response.ok) {\n              throw new Error(`HTTP error! Status: ${response.status}`);\n            }\n            return response.text();\n          })\n          .then((mapml) => {\n            let content = new DOMParser().parseFromString(mapml, 'text/xml');\n            if (\n              content.querySelector('parsererror') ||\n              !content.querySelector('mapml-')\n            ) {\n              throw new Error('Parser error');\n            }\n            if (this._layer) {\n              this._onRemove();\n            }\n            this._layer = M.mapMLLayer(\n              new URL(this.src, base).href,\n              this,\n              content,\n              {\n                mapprojection: this.parentElement.projection,\n                opacity: this.opacity\n              }\n            );\n            this._attachedToMap();\n            this._validateDisabled();\n            resolve();\n          })\n          .catch((error) => {\n            console.log('Error fetching layer content' + error);\n          });\n      } else {\n        if (this._layer) {\n          this._onRemove();\n        }\n        this._layer = M.mapMLLayer(null, this, null, {\n          mapprojection: this.parentElement.projection,\n          opacity: this.opacity\n        });\n        this._attachedToMap();\n        this._validateDisabled();\n        resolve();\n      }\n    }).catch((e) => {\n      if (e.type === 'changeprojection') {\n        this.src = e.detail.href;\n      } else {\n        console.log(e);\n        this.dispatchEvent(\n          new CustomEvent('error', { detail: { target: this } })\n        );\n      }\n    });\n  }\n  _attachedToMap() {\n    // set i to the position of this layer element in the set of layers\n    var i = 0,\n      position = 1;\n    for (var nodes = this.parentNode.children; i < nodes.length; i++) {\n      if (this.parentNode.children[i].nodeName === 'LAYER-') {\n        if (this.parentNode.children[i] === this) {\n          position = i + 1;\n        } else if (this.parentNode.children[i]._layer) {\n          this.parentNode.children[i]._layer.setZIndex(i + 1);\n        }\n      }\n    }\n    var proj = this.parentNode.projection\n      ? this.parentNode.projection\n      : 'OSMTILE';\n    L.setOptions(this._layer, {\n      zIndex: position,\n      mapprojection: proj,\n      opacity: window.getComputedStyle(this).opacity\n    });\n    // make sure the Leaflet layer has a reference to the map\n    this._layer._map = this.parentNode._map;\n    // notify the layer that it is attached to a map (layer._map)\n    this._layer.fire('attached');\n\n    if (this.checked) {\n      this._layer.addTo(this._layer._map);\n    }\n\n    // add the handler which toggles the 'checked' property based on the\n    // user checking/unchecking the layer from the layer control\n    // this must be done *after* the layer is actually added to the map\n    this._layer.on('add remove', this._onLayerChange, this);\n    this._layer.on('add remove', this._validateDisabled, this);\n    // toggle the this.disabled attribute depending on whether the layer\n    // is: same prj as map, within view/zoom of map\n    this._layer._map.on('moveend layeradd', this._validateDisabled, this);\n\n    // if controls option is enabled, insert the layer into the overlays array\n    if (this.parentNode._layerControl && !this.hidden) {\n      this._layerControl = this.parentNode._layerControl;\n      this._layerControl.addOrUpdateOverlay(this._layer, this.label);\n    }\n\n    // the mapml document associated to this layer can in theory contain many\n    // link[@rel=legend] elements with different @type or other attributes;\n    // currently only support a single link, don't care about type, lang etc.\n    // TODO: add support for full LayerLegend object, and > one link.\n    if (this._layer._legendUrl) {\n      this.legendLinks = [\n        {\n          type: 'application/octet-stream',\n          href: this._layer._legendUrl,\n          rel: 'legend',\n          lang: null,\n          hreflang: null,\n          sizes: null\n        }\n      ];\n    }\n    // re-use 'loadedmetadata' event from HTMLMediaElement inteface, applied\n    // to MapML extent as metadata\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadedmetadata_event\n    this.dispatchEvent(\n      new CustomEvent('loadedmetadata', { detail: { target: this } })\n    );\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    switch (name) {\n      case 'label':\n        this.whenReady().then(() => {\n          this._layer.setName(newValue);\n        });\n        break;\n      case 'checked':\n        if (this._layer) {\n          if (typeof newValue === 'string') {\n            this.parentElement._map.addLayer(this._layer);\n          } else {\n            this.parentElement._map.removeLayer(this._layer);\n          }\n          this.dispatchEvent(new Event('change', { bubbles: true }));\n        }\n        break;\n      case 'hidden':\n        var map = this.parentElement && this.parentElement._map;\n        if (map && this.parentElement.controls) {\n          if (typeof newValue === 'string') {\n            if (this._layer) {\n              this.parentElement._layerControl.removeLayer(this._layer);\n            }\n          } else {\n            this._layerControl = this.parentElement._layerControl;\n            this._layerControl.addOrUpdateOverlay(this._layer, this.label);\n            this._validateDisabled();\n          }\n        }\n        break;\n      case 'opacity':\n        if (oldValue !== newValue && this._layer) {\n          this._opacity = newValue;\n          this._layer.changeOpacity(newValue);\n        }\n        break;\n      case 'src':\n        if (oldValue !== newValue && this._layer) {\n          this._onRemove();\n          if (this.isConnected) {\n            this._onAdd();\n          }\n          // the original inline content will not be removed\n          // but has NO EFFECT and works as a fallback\n        }\n    }\n  }\n  _validateDisabled() {\n    setTimeout(() => {\n      let layer = this._layer,\n        map = layer?._map;\n      if (map) {\n        let count = 0,\n          total = 0,\n          layerTypes = [\n            '_staticTileLayer',\n            '_imageLayer',\n            '_mapmlvectors',\n            '_templatedLayer'\n          ];\n        if (layer.validProjection) {\n          for (let j = 0; j < layerTypes.length; j++) {\n            let type = layerTypes[j];\n            if (this.checked && layer[type]) {\n              if (type === '_templatedLayer') {\n                for (let i = 0; i < layer._properties._mapExtents.length; i++) {\n                  for (\n                    let j = 0;\n                    j <\n                    layer._properties._mapExtents[i].templatedLayer._templates\n                      .length;\n                    j++\n                  ) {\n                    if (\n                      layer._properties._mapExtents[i].templatedLayer\n                        ._templates[j].rel === 'query'\n                    )\n                      continue;\n                    total++;\n                    layer._properties._mapExtents[i].removeAttribute(\n                      'disabled'\n                    );\n                    layer._properties._mapExtents[i].disabled = false;\n                    if (\n                      !layer._properties._mapExtents[i].templatedLayer\n                        ._templates[j].layer.isVisible\n                    ) {\n                      count++;\n                      layer._properties._mapExtents[i].setAttribute(\n                        'disabled',\n                        ''\n                      );\n                      layer._properties._mapExtents[i].disabled = true;\n                    }\n                  }\n                }\n              } else {\n                total++;\n                if (!layer[type].isVisible) count++;\n              }\n            }\n          }\n        } else {\n          count = 1;\n          total = 1;\n        }\n\n        if (count === total && count !== 0) {\n          this.setAttribute('disabled', ''); //set a disabled attribute on the layer element\n          this.disabled = true;\n        } else {\n          //might be better not to disable the layer controls, might want to deselect layer even when its out of bounds\n          this.removeAttribute('disabled');\n          this.disabled = false;\n        }\n        map.fire('validate');\n      }\n    }, 0);\n  }\n  getOuterHTML() {\n    let tempElement = this.cloneNode(true);\n\n    if (this.hasAttribute('src')) {\n      let newSrc = this._layer.getHref();\n      tempElement.setAttribute('src', newSrc);\n    }\n    if (this.querySelector('map-link')) {\n      let mapLinks = tempElement.querySelectorAll('map-link');\n\n      mapLinks.forEach((mapLink) => {\n        if (mapLink.hasAttribute('href')) {\n          mapLink.setAttribute(\n            'href',\n            decodeURI(\n              new URL(\n                mapLink.attributes.href.value,\n                this.baseURI ? this.baseURI : document.baseURI\n              ).href\n            )\n          );\n        } else if (mapLink.hasAttribute('tref')) {\n          mapLink.setAttribute(\n            'tref',\n            decodeURI(\n              new URL(\n                mapLink.attributes.tref.value,\n                this.baseURI ? this.baseURI : document.baseURI\n              ).href\n            )\n          );\n        }\n      });\n    }\n\n    let outerLayer = tempElement.outerHTML;\n\n    tempElement.remove();\n\n    return outerLayer;\n  }\n\n  _onLayerChange() {\n    if (this._layer._map) {\n      // can't disable observers, have to set a flag telling it where\n      // the 'event' comes from: either the api or a user click/tap\n      // may not be necessary -> this._apiToggleChecked = false;\n      this.checked = this._layer._map.hasLayer(this._layer);\n    }\n  }\n  zoomTo() {\n    if (!this.extent) return;\n    let map = this.parentElement._map,\n      tL = this.extent.topLeft.pcrs,\n      bR = this.extent.bottomRight.pcrs,\n      layerBounds = L.bounds(\n        L.point(tL.horizontal, tL.vertical),\n        L.point(bR.horizontal, bR.vertical)\n      ),\n      center = map.options.crs.unproject(layerBounds.getCenter(true));\n\n    let maxZoom = this.extent.zoom.maxZoom,\n      minZoom = this.extent.zoom.minZoom;\n    map.setView(center, M.getMaxZoom(layerBounds, map, minZoom, maxZoom), {\n      animate: false\n    });\n  }\n  mapml2geojson(options = {}) {\n    return M.mapml2geojson(this, options);\n  }\n  pasteFeature(feature) {\n    switch (typeof feature) {\n      case 'string':\n        feature.trim();\n        if (\n          feature.slice(0, 12) === '<map-feature' &&\n          feature.slice(-14) === '</map-feature>'\n        ) {\n          this.insertAdjacentHTML('beforeend', feature);\n        }\n        break;\n      case 'object':\n        if (feature.nodeName.toUpperCase() === 'MAP-FEATURE') {\n          this.appendChild(feature);\n        }\n    }\n  }\n  whenReady() {\n    return new Promise((resolve, reject) => {\n      let interval, failureTimer;\n      if (this._layer) {\n        resolve();\n      } else {\n        let layerElement = this;\n        interval = setInterval(testForLayer, 200, layerElement);\n        failureTimer = setTimeout(layerNotDefined, 5000);\n      }\n      function testForLayer(layerElement) {\n        if (layerElement._layer) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          resolve();\n        }\n      }\n      function layerNotDefined() {\n        clearInterval(interval);\n        clearTimeout(failureTimer);\n        reject('Timeout reached waiting for layer to be ready');\n      }\n    });\n  }\n}\n"],"names":["MapLayer","HTMLElement","observedAttributes","src","this","hasAttribute","getAttribute","val","setAttribute","label","_layer","getName","checked","removeAttribute","hidden","opacity","_opacity","constructor","super","disconnectedCallback","_onRemove","off","_map","removeLayer","_layerControl","shadowRoot","innerHTML","connectedCallback","doConnected","_onAdd","bind","parentElement","whenReady","then","catch","Error","attachShadow","mode","Promise","resolve","reject","addEventListener","e","stopPropagation","detail","once","let","base","baseURI","document","headers","Headers","append","fetch","response","ok","status","text","content","DOMParser","parseFromString","mapml","querySelector","M","mapMLLayer","URL","href","mapprojection","projection","_attachedToMap","_validateDisabled","console","log","error","type","dispatchEvent","CustomEvent","target","i","position","nodes","parentNode","children","length","nodeName","setZIndex","proj","L","setOptions","zIndex","window","getComputedStyle","fire","addTo","on","_onLayerChange","addOrUpdateOverlay","_legendUrl","legendLinks","rel","lang","hreflang","sizes","attributeChangedCallback","name","oldValue","newValue","setName","addLayer","Event","bubbles","controls","changeOpacity","isConnected","setTimeout","layer","map","count","total","layerTypes","validProjection","j","_properties","_mapExtents","templatedLayer","_templates","disabled","isVisible","getOuterHTML","tempElement","cloneNode","newSrc","getHref","mapLinks","querySelectorAll","forEach","mapLink","decodeURI","attributes","value","tref","outerLayer","outerHTML","remove","hasLayer","zoomTo","extent","tL","topLeft","pcrs","bR","bottomRight","layerBounds","bounds","point","horizontal","vertical","center","options","crs","unproject","getCenter","maxZoom","zoom","minZoom","setView","getMaxZoom","animate","mapml2geojson","pasteFeature","feature","trim","slice","insertAdjacentHTML","toUpperCase","appendChild","interval","failureTimer","setInterval","layerElement","clearInterval","clearTimeout"],"mappings":"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"}