{"version":3,"file":"map-extent.js","sources":["../src/map-extent.js"],"sourcesContent":["/* global M */\nexport class MapExtent extends HTMLElement {\n  static get observedAttributes() {\n    return ['checked', 'label', 'opacity', 'hidden'];\n  }\n  get units() {\n    return this.getAttribute('units');\n  }\n\n  get checked() {\n    return this.hasAttribute('checked');\n  }\n\n  set checked(val) {\n    if (val) {\n      this.setAttribute('checked', '');\n    } else {\n      this.removeAttribute('checked');\n    }\n  }\n  get label() {\n    return this.hasAttribute('label')\n      ? this.getAttribute('label')\n      : M.options.locale.dfExtent;\n  }\n  set label(val) {\n    if (val) {\n      this.setAttribute('label', val);\n    }\n  }\n  get opacity() {\n    // use ?? since 0 is falsy, || would return rhs in that case\n    return +(this._opacity ?? this.getAttribute('opacity'));\n  }\n\n  set opacity(val) {\n    if (+val > 1 || +val < 0) return;\n    this.setAttribute('opacity', val);\n  }\n  get hidden() {\n    return this.hasAttribute('hidden');\n  }\n\n  set hidden(val) {\n    if (val) {\n      this.setAttribute('hidden', '');\n    } else {\n      this.removeAttribute('hidden');\n    }\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    this.whenReady()\n      .then(() => {\n        switch (name) {\n          case 'units':\n            if (oldValue !== newValue) {\n              // handle side effects\n            }\n            break;\n          case 'label':\n            if (oldValue !== newValue) {\n              this._layerControlHTML.querySelector(\n                '.mapml-layer-item-name'\n              ).innerHTML = newValue || M.options.locale.dfExtent;\n            }\n            break;\n          case 'checked':\n            this._handleChange();\n            this._calculateBounds();\n            this._layerControlCheckbox.checked = newValue !== null;\n            break;\n          case 'opacity':\n            if (oldValue !== newValue) {\n              this._opacity = newValue;\n              if (this._templatedLayer)\n                this._templatedLayer.changeOpacity(newValue);\n            }\n            break;\n          case 'hidden':\n            if (oldValue !== newValue) {\n              let extentsRootFieldset =\n                this.parentLayer._propertiesGroupAnatomy;\n              let position = Array.from(\n                this.parentNode.querySelectorAll('map-extent:not([hidden])')\n              ).indexOf(this);\n              if (newValue !== null) {\n                // remove from layer control (hide from user)\n                this._layerControlHTML.remove();\n              } else {\n                // insert the extent fieldset into the layer control container in\n                // the calculated position\n                if (position === 0) {\n                  extentsRootFieldset.insertAdjacentElement(\n                    'afterbegin',\n                    this._layerControlHTML\n                  );\n                } else if (position > 0) {\n                  this.parentNode\n                    .querySelectorAll('map-extent:not([hidden])')\n                    [position - 1]._layerControlHTML.insertAdjacentElement(\n                      'afterend',\n                      this._layerControlHTML\n                    );\n                }\n              }\n              this._validateLayerControlContainerHidden();\n            }\n            break;\n        }\n      })\n      .catch((reason) => {\n        console.log(\n          reason,\n          `\\nin mapExtent.attributeChangeCallback when changing attribute ${name}`\n        );\n      });\n  }\n  constructor() {\n    // Always call super first in constructor\n    super();\n  }\n  async connectedCallback() {\n    // this.parentNode.host returns the layer- element when parentNode is\n    // the shadow root\n    this._createLayerControlExtentHTML =\n      M._createLayerControlExtentHTML.bind(this);\n    this.parentLayer =\n      this.parentNode.nodeName.toUpperCase() === 'LAYER-'\n        ? this.parentNode\n        : this.parentNode.host;\n    if (\n      this.hasAttribute('data-moving') ||\n      this.parentLayer.hasAttribute('data-moving')\n    )\n      return;\n    if (\n      this.querySelector('map-link[rel=query], map-link[rel=features]') &&\n      !this.shadowRoot\n    ) {\n      this.attachShadow({ mode: 'open' });\n    }\n    await this.parentLayer.whenReady();\n    // when projection is changed, the parent layer-._layer is created (so whenReady is fulfilled) but then removed,\n    // then the map-extent disconnectedCallback will be triggered by layer-._onRemove() (clear the shadowRoot)\n    // even before connectedCallback is finished\n    // in this case, the microtasks triggered by the fulfillment of the removed MapMLLayer should be stopped as well\n    // !this.isConnected <=> the disconnectedCallback has run before\n    if (!this.isConnected) return;\n    this._layer = this.parentLayer._layer;\n    this._map = this._layer._map;\n    // reset the layer extent\n    delete this.parentLayer.bounds;\n    this._templateVars = this._initTemplateVars(\n      // read map-meta[name=extent] from shadowroot or layer-\n      // querySelector / querySelectorAll on layer- cannot get elements inside its shadowroot\n      this.parentLayer.shadowRoot\n        ? this.parentLayer.shadowRoot.querySelector(\n            'map-extent > map-meta[name=extent]'\n          ) ||\n            this.parentLayer.shadowRoot.querySelector('map-meta[name=extent]')\n        : this.parentLayer.querySelector(\n            'map-extent > map-meta[name=extent]'\n          ) || this.parentLayer.querySelector('map-meta[name=extent]'),\n      this.units,\n      this._layer._content,\n      this._layer.getBase(),\n      this.units === this._layer.options.mapprojection\n    );\n    this._changeHandler = this._handleChange.bind(this);\n    this.parentLayer.addEventListener('map-change', this._changeHandler);\n    // this._opacity is used to record the current opacity value (with or without updates),\n    // the initial value of this._opacity should be set as opacity attribute value, if exists, or the default value 1.0\n    this._opacity = +(this.getAttribute('opacity') || 1.0);\n    this._templatedLayer = M.templatedLayer(this._templateVars, {\n      pane: this._layer._container,\n      opacity: this.opacity,\n      _leafletLayer: this._layer,\n      crs: this._layer._properties.crs,\n      extentZIndex: Array.from(\n        this.parentLayer.querySelectorAll('map-extent')\n      ).indexOf(this),\n      // when a <map-extent> migrates from a remote mapml file and attaches to the shadow of <layer- >\n      // this._properties._mapExtents[i] refers to the <map-extent> in remote mapml\n      extentEl: this._DOMnode || this\n    });\n    // this._layerControlHTML is the fieldset for the extent in the LayerControl\n    this._layerControlHTML = this._createLayerControlExtentHTML();\n    if (!this.hidden)\n      this._layer.addExtentToLayerControl(this._layerControlHTML);\n    this._validateLayerControlContainerHidden();\n    if (this._templatedLayer._queries) {\n      if (!this._layer._properties._queries)\n        this._layer._properties._queries = [];\n      this._layer._properties._queries =\n        this._layer._properties._queries.concat(this._templatedLayer._queries);\n    }\n    this._calculateBounds();\n  }\n  getLayerControlHTML() {\n    return this._layerControlHTML;\n  }\n  _projectionMatch() {\n    return (\n      this.units.toUpperCase() ===\n      this._layer.options.mapprojection.toUpperCase()\n    );\n  }\n  _validateDisabled() {\n    if (!this._templatedLayer) return;\n    const noTemplateVisible = () => {\n      let totalTemplateCount = this._templatedLayer._templates.length,\n        disabledTemplateCount = 0;\n      for (let j = 0; j < this._templatedLayer._templates.length; j++) {\n        if (this._templatedLayer._templates[j].rel === 'query') {\n          continue;\n        }\n        if (!this._templatedLayer._templates[j].layer.isVisible) {\n          disabledTemplateCount++;\n        }\n      }\n      return disabledTemplateCount === totalTemplateCount;\n    };\n    if (!this._projectionMatch() || noTemplateVisible()) {\n      this.setAttribute('disabled', '');\n      this.disabled = true;\n    } else {\n      this.removeAttribute('disabled');\n      this.disabled = false;\n    }\n    this.toggleLayerControlDisabled();\n    return this.disabled;\n  }\n\n  // disable/italicize layer control elements based on the map-extent.disabled property\n  toggleLayerControlDisabled() {\n    let input = this._layerControlCheckbox,\n      label = this._layerControlLabel, // access to the label for the specific map-extent\n      opacityControl = this._opacityControl,\n      opacitySlider = this._opacitySlider,\n      selectDetails = this._selectdetails;\n    if (this.disabled) {\n      // update the status of layerControl\n      input.disabled = true;\n      opacitySlider.disabled = true;\n      label.style.fontStyle = 'italic';\n      opacityControl.style.fontStyle = 'italic';\n      if (selectDetails) {\n        selectDetails.forEach((i) => {\n          i.querySelectorAll('select').forEach((j) => {\n            j.disabled = true;\n            j.style.fontStyle = 'italic';\n          });\n          i.style.fontStyle = 'italic';\n        });\n      }\n    } else {\n      input.disabled = false;\n      opacitySlider.disabled = false;\n      label.style.fontStyle = 'normal';\n      opacityControl.style.fontStyle = 'normal';\n      if (selectDetails) {\n        selectDetails.forEach((i) => {\n          i.querySelectorAll('select').forEach((j) => {\n            j.disabled = false;\n            j.style.fontStyle = 'normal';\n          });\n          i.style.fontStyle = 'normal';\n        });\n      }\n    }\n  }\n\n  _initTemplateVars(metaExtent, projection, mapml, base, projectionMatch) {\n    function transcribe(element) {\n      var select = document.createElement('select');\n      var elementAttrNames = element.getAttributeNames();\n\n      for (let i = 0; i < elementAttrNames.length; i++) {\n        select.setAttribute(\n          elementAttrNames[i],\n          element.getAttribute(elementAttrNames[i])\n        );\n      }\n\n      var options = element.children;\n\n      for (let i = 0; i < options.length; i++) {\n        var option = document.createElement('option');\n        var optionAttrNames = options[i].getAttributeNames();\n\n        for (let j = 0; j < optionAttrNames.length; j++) {\n          option.setAttribute(\n            optionAttrNames[j],\n            options[i].getAttribute(optionAttrNames[j])\n          );\n        }\n\n        option.innerHTML = options[i].innerHTML;\n        select.appendChild(option);\n      }\n      return select;\n    }\n    var templateVars = [];\n    // set up the URL template and associated inputs (which yield variable values when processed)\n    var tlist = this.querySelectorAll(\n        'map-link[rel=tile],map-link[rel=image],map-link[rel=features],map-link[rel=query]'\n      ),\n      varNamesRe = new RegExp('(?:{)(.*?)(?:})', 'g'),\n      zoomInput = this.querySelector('map-input[type=\"zoom\" i]'),\n      includesZoom = false,\n      boundsFallback = {};\n\n    boundsFallback.zoom = 0;\n    if (metaExtent) {\n      let content = M._metaContentToObject(metaExtent.getAttribute('content')),\n        cs;\n\n      boundsFallback.zoom = content.zoom || boundsFallback.zoom;\n\n      let metaKeys = Object.keys(content);\n      for (let i = 0; i < metaKeys.length; i++) {\n        if (!metaKeys[i].includes('zoom')) {\n          cs = M.axisToCS(metaKeys[i].split('-')[2]);\n          break;\n        }\n      }\n      let axes = M.csToAxes(cs);\n      boundsFallback.bounds = M.boundsToPCRSBounds(\n        L.bounds(\n          L.point(\n            +content[`top-left-${axes[0]}`],\n            +content[`top-left-${axes[1]}`]\n          ),\n          L.point(\n            +content[`bottom-right-${axes[0]}`],\n            +content[`bottom-right-${axes[1]}`]\n          )\n        ),\n        boundsFallback.zoom,\n        projection,\n        cs\n      );\n    } else {\n      // for custom projections, M[projection] may not be loaded, so uses M['OSMTILE'] as backup, this code will need to get rerun once projection is changed and M[projection] is available\n      // TODO: This is a temporary fix, _initTemplateVars (or processinitialextent) should not be called when projection of the layer and map do not match, this should be called/reinitialized once the layer projection matches with the map projection\n      let fallbackProjection = M[projection] || M.OSMTILE;\n      boundsFallback.bounds = fallbackProjection.options.crs.pcrs.bounds;\n    }\n\n    for (var i = 0; i < tlist.length; i++) {\n      var t = tlist[i],\n        template = t.getAttribute('tref');\n      t.zoomInput = zoomInput;\n      if (!template) {\n        template = M.BLANK_TT_TREF;\n        let blankInputs = mapml.querySelectorAll('map-input');\n        for (let i of blankInputs) {\n          template += `{${i.getAttribute('name')}}`;\n        }\n      }\n\n      var v,\n        title = t.hasAttribute('title')\n          ? t.getAttribute('title')\n          : 'Query this layer',\n        vcount = template.match(varNamesRe),\n        trel =\n          !t.hasAttribute('rel') ||\n          t.getAttribute('rel').toLowerCase() === 'tile'\n            ? 'tile'\n            : t.getAttribute('rel').toLowerCase(),\n        ttype = !t.hasAttribute('type')\n          ? 'image/*'\n          : t.getAttribute('type').toLowerCase(),\n        inputs = [],\n        tms = t && t.hasAttribute('tms');\n      var zoomBounds = mapml.querySelector('map-meta[name=zoom]')\n        ? M._metaContentToObject(\n            mapml.querySelector('map-meta[name=zoom]').getAttribute('content')\n          )\n        : undefined;\n      while ((v = varNamesRe.exec(template)) !== null) {\n        var varName = v[1],\n          inp = this.querySelector(\n            'map-input[name=' + varName + '],map-select[name=' + varName + ']'\n          );\n        if (inp) {\n          if (\n            inp.hasAttribute('type') &&\n            inp.getAttribute('type') === 'location' &&\n            (!inp.hasAttribute('min') || !inp.hasAttribute('max')) &&\n            inp.hasAttribute('axis') &&\n            !['i', 'j'].includes(inp.getAttribute('axis').toLowerCase())\n          ) {\n            if (\n              zoomInput &&\n              template.includes(`{${zoomInput.getAttribute('name')}}`)\n            ) {\n              zoomInput.setAttribute('value', boundsFallback.zoom);\n            }\n            let axis = inp.getAttribute('axis'),\n              axisBounds = M.convertPCRSBounds(\n                boundsFallback.bounds,\n                boundsFallback.zoom,\n                projection,\n                M.axisToCS(axis)\n              );\n            inp.setAttribute('min', axisBounds.min[M.axisToXY(axis)]);\n            inp.setAttribute('max', axisBounds.max[M.axisToXY(axis)]);\n          }\n\n          inputs.push(inp);\n          includesZoom =\n            includesZoom ||\n            (inp.hasAttribute('type') &&\n              inp.getAttribute('type').toLowerCase() === 'zoom');\n          if (inp.tagName.toLowerCase() === 'map-select') {\n            // use a throwaway div to parse the input from MapML into HTML\n            var div = document.createElement('div');\n            div.insertAdjacentHTML('afterbegin', inp.outerHTML);\n            // parse\n            inp.htmlselect = div.querySelector('map-select');\n            inp.htmlselect = transcribe(inp.htmlselect);\n\n            // this goes into the layer control, so add a listener\n            L.DomEvent.on(inp.htmlselect, 'change', this.redraw, this);\n\n            if (!this._userInputs) {\n              this._userInputs = [];\n            }\n            this._userInputs.push(inp.htmlselect);\n          }\n          // TODO: if this is an input@type=location\n          // get the TCRS min,max attribute values at the identified zoom level\n          // save this information as properties of the mapExtent,\n          // perhaps as a bounds object so that it can be easily used\n          // later by the layer control to determine when to enable\n          // disable the layer for drawing.\n        } else {\n          console.log(\n            'input with name=' +\n              varName +\n              ' not found for template variable of same name'\n          );\n          // no match found, template won't be used\n          break;\n        }\n      }\n      if (\n        (template && vcount.length === inputs.length) ||\n        template === M.BLANK_TT_TREF\n      ) {\n        if (trel === 'query') {\n          this._layer.queryable = true;\n        }\n        if (!includesZoom && zoomInput) {\n          inputs.push(zoomInput);\n        }\n        let step = zoomInput ? zoomInput.getAttribute('step') : 1;\n        if (!step || step === '0' || isNaN(step)) step = 1;\n        // template has a matching input for every variable reference {varref}\n        templateVars.push({\n          template: decodeURI(new URL(template, base)),\n          linkEl: t,\n          title: title,\n          rel: trel,\n          type: ttype,\n          values: inputs,\n          zoomBounds: zoomBounds,\n          boundsFallbackPCRS: { bounds: boundsFallback.bounds },\n          projectionMatch: projectionMatch,\n          projection: this.units || M.FALLBACK_PROJECTION,\n          tms: tms,\n          step: step\n        });\n      }\n    }\n    return templateVars;\n  }\n  redraw() {\n    this._templatedLayer.redraw();\n  }\n\n  _handleChange() {\n    // if the parent layer- is checked, add _templatedLayer to map if map-extent is checked, otherwise remove it\n    if (this.checked && this.parentLayer.checked && !this.disabled) {\n      this._templatedLayer.addTo(this._layer._map);\n      this._templatedLayer.setZIndex(\n        Array.from(this.parentLayer.querySelectorAll('map-extent')).indexOf(\n          this\n        )\n      );\n    } else {\n      this._map.removeLayer(this._templatedLayer);\n    }\n    // change the checkbox in the layer control to match map-extent.checked\n    // doesn't trigger the event handler because it's not user-caused AFAICT\n  }\n  _validateLayerControlContainerHidden() {\n    let extentsFieldset = this.parentLayer._propertiesGroupAnatomy;\n    let nodeToSearch = this.parentLayer.shadowRoot || this.parentLayer;\n    if (\n      nodeToSearch.querySelectorAll('map-extent:not([hidden])').length === 0\n    ) {\n      extentsFieldset.setAttribute('hidden', '');\n    } else {\n      extentsFieldset.removeAttribute('hidden');\n    }\n  }\n  disconnectedCallback() {\n    // in case of projection change, the disconnectedcallback will be triggered by removing layer-._layer even before\n    // map-extent.connectedcallback is finished (because it will wait for the layer- to be ready)\n    // !this._templatedLayer <=> this.connectedCallback has not yet been finished before disconnectedCallback is triggered\n    if (\n      this.hasAttribute('data-moving') ||\n      this.parentLayer.hasAttribute('data-moving') ||\n      !this._templatedLayer\n    )\n      return;\n    this._validateLayerControlContainerHidden();\n    // remove layer control for map-extent from layer control DOM\n    this._layerControlHTML.remove();\n    this._map.removeLayer(this._templatedLayer);\n    this.parentLayer.removeEventListener('map-change', this._changeHandler);\n    delete this._templatedLayer;\n    delete this.parentLayer.bounds;\n  }\n  _calculateBounds() {\n    let bounds = null,\n      zoomMax = 0,\n      zoomMin = 0,\n      maxNativeZoom = 0,\n      minNativeZoom = 0;\n    // bounds should be able to be calculated unconditionally, not depend on map-extent.checked\n    for (let j = 0; j < this._templateVars.length; j++) {\n      let inputData = M._extractInputBounds(this._templateVars[j]);\n      this._templateVars[j].tempExtentBounds = inputData.bounds;\n      this._templateVars[j].extentZoomBounds = inputData.zoomBounds;\n      if (!bounds) {\n        bounds = this._templateVars[j].tempExtentBounds;\n        zoomMax = this._templateVars[j].extentZoomBounds.maxZoom;\n        zoomMin = this._templateVars[j].extentZoomBounds.minZoom;\n        maxNativeZoom = this._templateVars[j].extentZoomBounds.maxNativeZoom;\n        minNativeZoom = this._templateVars[j].extentZoomBounds.minNativeZoom;\n      } else {\n        bounds.extend(this._templateVars[j].tempExtentBounds.min);\n        bounds.extend(this._templateVars[j].tempExtentBounds.max);\n        zoomMax = Math.max(\n          zoomMax,\n          this._templateVars[j].extentZoomBounds.maxZoom\n        );\n        zoomMin = Math.min(\n          zoomMin,\n          this._templateVars[j].extentZoomBounds.minZoom\n        );\n        maxNativeZoom = Math.max(\n          maxNativeZoom,\n          this._templateVars[j].extentZoomBounds.maxNativeZoom\n        );\n        minNativeZoom = Math.min(\n          minNativeZoom,\n          this._templateVars[j].extentZoomBounds.minNativeZoom\n        );\n      }\n    }\n    // cannot be named as layerBounds if we decide to keep the debugoverlay logic\n    this._templatedLayer.bounds = bounds;\n    this._templatedLayer.zoomBounds = {\n      minZoom: zoomMin,\n      maxZoom: zoomMax,\n      maxNativeZoom,\n      minNativeZoom\n    };\n  }\n\n  whenReady() {\n    return new Promise((resolve, reject) => {\n      let interval, failureTimer;\n      if (this._templatedLayer) {\n        resolve();\n      } else {\n        let extentElement = this;\n        interval = setInterval(testForExtent, 300, extentElement);\n        failureTimer = setTimeout(extentNotDefined, 10000);\n      }\n      function testForExtent(extentElement) {\n        if (extentElement._templatedLayer) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          resolve();\n        } else if (!extentElement.isConnected) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          reject('map-extent was disconnected while waiting to be ready');\n        }\n      }\n      function extentNotDefined() {\n        clearInterval(interval);\n        clearTimeout(failureTimer);\n        reject('Timeout reached waiting for extent to be ready');\n      }\n    });\n  }\n}\n"],"names":["MapExtent","HTMLElement","observedAttributes","units","this","getAttribute","checked","hasAttribute","val","setAttribute","removeAttribute","label","M","options","locale","dfExtent","opacity","_opacity","hidden","attributeChangedCallback","name","oldValue","newValue","whenReady","then","_layerControlHTML","querySelector","innerHTML","_handleChange","_calculateBounds","_layerControlCheckbox","_templatedLayer","changeOpacity","let","extentsRootFieldset","parentLayer","_propertiesGroupAnatomy","position","Array","from","parentNode","querySelectorAll","indexOf","remove","insertAdjacentElement","_validateLayerControlContainerHidden","catch","console","log","reason","constructor","super","connectedCallback","_createLayerControlExtentHTML","bind","nodeName","toUpperCase","host","shadowRoot","attachShadow","mode","isConnected","_layer","_map","bounds","_templateVars","_initTemplateVars","_content","getBase","mapprojection","_changeHandler","addEventListener","templatedLayer","pane","_container","_leafletLayer","crs","_properties","extentZIndex","extentEl","_DOMnode","addExtentToLayerControl","_queries","concat","getLayerControlHTML","_projectionMatch","_validateDisabled","noTemplateVisible","totalTemplateCount","_templates","length","disabledTemplateCount","j","rel","layer","isVisible","disabled","toggleLayerControlDisabled","input","_layerControlLabel","opacityControl","_opacityControl","opacitySlider","_opacitySlider","selectDetails","_selectdetails","style","fontStyle","forEach","i","metaExtent","projection","mapml","base","projectionMatch","templateVars","tlist","varNamesRe","RegExp","zoomInput","includesZoom","boundsFallback","zoom","content","_metaContentToObject","cs","metaKeys","Object","keys","includes","axisToCS","split","axes","csToAxes","boundsToPCRSBounds","L","point","fallbackProjection","OSMTILE","pcrs","t","template","BLANK_TT_TREF","title","vcount","match","trel","toLowerCase","ttype","inputs","tms","zoomBounds","undefined","v","exec","div","varName","inp","axis","axisBounds","convertPCRSBounds","min","axisToXY","max","push","tagName","document","createElement","insertAdjacentHTML","outerHTML","htmlselect","element","select","elementAttrNames","getAttributeNames","children","option","optionAttrNames","appendChild","transcribe","DomEvent","on","redraw","_userInputs","queryable","step","isNaN","decodeURI","URL","linkEl","type","values","boundsFallbackPCRS","FALLBACK_PROJECTION","addTo","setZIndex","removeLayer","extentsFieldset","nodeToSearch","disconnectedCallback","removeEventListener","zoomMax","zoomMin","maxNativeZoom","minNativeZoom","inputData","_extractInputBounds","tempExtentBounds","extentZoomBounds","extend","Math","maxZoom","minZoom","Promise","resolve","reject","interval","failureTimer","setInterval","extentElement","clearInterval","clearTimeout","setTimeout"],"mappings":"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"}