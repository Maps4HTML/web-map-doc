{"version":3,"file":"map-extent.js","sources":["../src/map-extent.js"],"sourcesContent":["/* global M */\nexport class MapExtent extends HTMLElement {\n  static get observedAttributes() {\n    return ['checked', 'label', 'opacity', 'hidden'];\n  }\n  /* jshint ignore:start */\n  #hasConnected;\n  /* jshint ignore:end */\n  get units() {\n    return this.getAttribute('units') || M.FALLBACK_PROJECTION;\n  }\n\n  get checked() {\n    return this.hasAttribute('checked');\n  }\n\n  set checked(val) {\n    if (val) {\n      this.setAttribute('checked', '');\n    } else {\n      this.removeAttribute('checked');\n    }\n  }\n  get label() {\n    return this.hasAttribute('label')\n      ? this.getAttribute('label')\n      : M.options.locale.dfExtent;\n  }\n  set label(val) {\n    if (val) {\n      this.setAttribute('label', val);\n    }\n  }\n  get opacity() {\n    // use ?? since 0 is falsy, || would return rhs in that case\n    return +(this._opacity ?? this.getAttribute('opacity'));\n  }\n\n  set opacity(val) {\n    if (+val > 1 || +val < 0) return;\n    this.setAttribute('opacity', val);\n  }\n  get hidden() {\n    return this.hasAttribute('hidden');\n  }\n\n  set hidden(val) {\n    if (val) {\n      this.setAttribute('hidden', '');\n    } else {\n      this.removeAttribute('hidden');\n    }\n  }\n  get extent() {\n    const getExtent = (extent) => {\n      return Object.assign(\n        M._convertAndFormatPCRS(\n          extent._extentLayer.bounds,\n          M[extent.units],\n          extent.units\n        ),\n        { zoom: extent._extentLayer.zoomBounds }\n      );\n    };\n    const getCalculatedExtent = (extent) => {\n      extent._calculateBounds();\n      return getExtent(extent);\n    };\n\n    return this._extentLayer.bounds\n      ? getExtent(this)\n      : getCalculatedExtent(this);\n  }\n\n  getOuterHTML() {\n    let tempElement = this.cloneNode(true);\n\n    if (this.querySelector('map-link')) {\n      let mapLinks = tempElement.querySelectorAll('map-link');\n\n      mapLinks.forEach((mapLink) => {\n        if (mapLink.hasAttribute('href')) {\n          mapLink.setAttribute(\n            'href',\n            decodeURI(\n              new URL(\n                mapLink.attributes.href.value,\n                this.baseURI ? this.baseURI : document.baseURI\n              ).href\n            )\n          );\n        } else if (mapLink.hasAttribute('tref')) {\n          mapLink.setAttribute(\n            'tref',\n            decodeURI(\n              new URL(\n                mapLink.attributes.tref.value,\n                this.baseURI ? this.baseURI : document.baseURI\n              ).href\n            )\n          );\n        }\n      });\n    }\n\n    let outerLayer = tempElement.outerHTML;\n\n    tempElement.remove();\n\n    return outerLayer;\n  }\n\n  zoomTo() {\n    let extent = this.extent;\n    let map = this.getMapEl()._map,\n      xmin = extent.topLeft.pcrs.horizontal,\n      xmax = extent.bottomRight.pcrs.horizontal,\n      ymin = extent.bottomRight.pcrs.vertical,\n      ymax = extent.topLeft.pcrs.vertical,\n      bounds = L.bounds(L.point(xmin, ymin), L.point(xmax, ymax)),\n      center = map.options.crs.unproject(bounds.getCenter(true)),\n      maxZoom = extent.zoom.maxZoom,\n      minZoom = extent.zoom.minZoom;\n    map.setView(center, M.getMaxZoom(bounds, map, minZoom, maxZoom), {\n      animate: false\n    });\n  }\n  getMapEl() {\n    return this.getRootNode() instanceof ShadowRoot\n      ? this.getRootNode().host.closest('mapml-viewer,map[is=web-map]')\n      : this.closest('mapml-viewer,map[is=web-map]');\n  }\n  getLayerEl() {\n    return this.getRootNode() instanceof ShadowRoot\n      ? this.getRootNode().host\n      : this.closest('layer-');\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (this.#hasConnected /* jshint ignore:line */) {\n      switch (name) {\n        case 'units':\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n        case 'label':\n          if (oldValue !== newValue) {\n            this._layerControlHTML.querySelector(\n              '.mapml-extent-item-name'\n            ).innerHTML = newValue || M.options.locale.dfExtent;\n          }\n          break;\n        case 'checked':\n          this.parentLayer\n            .whenReady()\n            .then(() => {\n              this._handleChange();\n              this._calculateBounds();\n              this._layerControlCheckbox.checked = newValue !== null;\n            })\n            .catch((error) => {\n              console.log(\n                'Error while waiting on parentLayer for map-extent checked callback: ' +\n                  error\n              );\n            });\n          break;\n        case 'opacity':\n          if (oldValue !== newValue) {\n            this._opacity = newValue;\n            if (this._extentLayer) this._extentLayer.changeOpacity(newValue);\n          }\n          break;\n        case 'hidden':\n          if (oldValue !== newValue) {\n            this.parentLayer\n              .whenReady()\n              .then(() => {\n                let extentsRootFieldset =\n                  this.parentLayer._propertiesGroupAnatomy;\n                let position = Array.from(\n                  this.parentNode.querySelectorAll('map-extent:not([hidden])')\n                ).indexOf(this);\n                if (newValue !== null) {\n                  // remove from layer control (hide from user)\n                  this._layerControlHTML.remove();\n                } else {\n                  // insert the extent fieldset into the layer control container in\n                  // the calculated position\n                  if (position === 0) {\n                    extentsRootFieldset.insertAdjacentElement(\n                      'afterbegin',\n                      this._layerControlHTML\n                    );\n                  } else if (position > 0) {\n                    this.parentNode\n                      .querySelectorAll('map-extent:not([hidden])')\n                      [position - 1]._layerControlHTML.insertAdjacentElement(\n                        'afterend',\n                        this._layerControlHTML\n                      );\n                  }\n                }\n                this._validateLayerControlContainerHidden();\n              })\n              .catch(() => {\n                console.log(\n                  'Error while waiting on parentLayer for map-extent hidden callback'\n                );\n              });\n          }\n          break;\n      }\n    }\n  }\n  constructor() {\n    // Always call super first in constructor\n    super();\n    this._createLayerControlExtentHTML =\n      M._createLayerControlExtentHTML.bind(this);\n    this._changeHandler = this._handleChange.bind(this);\n  }\n  async connectedCallback() {\n    // this.parentNode.host returns the layer- element when parentNode is\n    // the shadow root\n    this.parentLayer =\n      this.parentNode.nodeName.toUpperCase() === 'LAYER-'\n        ? this.parentNode\n        : this.parentNode.host;\n    if (\n      this.hasAttribute('data-moving') ||\n      this.parentLayer.hasAttribute('data-moving')\n    )\n      return;\n    this.mapEl = this.parentLayer.closest('mapml-viewer,map[is=web-map]');\n    await this.mapEl.whenProjectionDefined(this.units).catch(() => {\n      throw new Error('Undefined projection:' + this.units);\n    });\n    // when projection is changed, the parent layer-._layer is created (so whenReady is fulfilled) but then removed,\n    // then the map-extent disconnectedCallback will be triggered by layer-._onRemove() (clear the shadowRoot)\n    // even before connectedCallback is finished\n    // in this case, the microtasks triggered by the fulfillment of the removed MapMLLayer should be stopped as well\n    // !this.isConnected <=> the disconnectedCallback has run before\n    if (!this.isConnected) return;\n    /* jshint ignore:start */\n    this.#hasConnected = true;\n    /* jshint ignore:end */\n    this._map = this.mapEl._map;\n    this.parentLayer.addEventListener('map-change', this._changeHandler);\n    this.mapEl.addEventListener('map-projectionchange', this._changeHandler);\n    // this._opacity is used to record the current opacity value (with or without updates),\n    // the initial value of this._opacity should be set as opacity attribute value, if exists, or the default value 1.0\n    this._opacity = this.opacity || 1.0;\n    this._extentLayer = M.extentLayer({\n      opacity: this.opacity,\n      crs: M[this.units],\n      extentZIndex: Array.from(\n        this.parentLayer.querySelectorAll('map-extent')\n      ).indexOf(this),\n      extentEl: this\n    });\n    // this._layerControlHTML is the fieldset for the extent in the LayerControl\n    this._layerControlHTML = this._createLayerControlExtentHTML();\n    this._calculateBounds();\n    this._bindMutationObserver();\n  }\n  /*\n   * Set up a function to watch additions of child elements of map-extent\n   * and to invoke desired side  effects of those additions via\n   * _runMutationObserver\n   */\n  _bindMutationObserver() {\n    this._observer = new MutationObserver((mutationList) => {\n      for (let mutation of mutationList) {\n        // the attributes changes should be handled by attributeChangedCallback()\n        if (mutation.type === 'childList') {\n          this._runMutationObserver(mutation.addedNodes);\n        }\n      }\n    });\n    // childList observes immediate children only (not grandchildren etc)\n    this._observer.observe(this, {\n      childList: true\n    });\n  }\n  _runMutationObserver(elementsGroup) {\n    const _addMetaElement = (mapMeta) => {\n      this.whenReady().then(() => {\n        this._calculateBounds();\n        this._validateDisabled();\n      });\n    };\n    for (let i = 0; i < elementsGroup.length; ++i) {\n      let element = elementsGroup[i];\n      switch (element.nodeName) {\n        case 'MAP-META':\n          const name =\n            element.hasAttribute('name') &&\n            (element.getAttribute('name').toLowerCase() === 'zoom' ||\n              element.getAttribute('name').toLowerCase() === 'extent');\n          if (name && element.hasAttribute('content')) {\n            _addMetaElement(element);\n          }\n          break;\n        case 'MAP-LINK':\n        // might need this in future, among others\n        default:\n          break;\n      }\n    }\n  }\n  getLayerControlHTML() {\n    return this._layerControlHTML;\n  }\n  _projectionMatch() {\n    return (\n      this.units.toUpperCase() === this._map.options.projection.toUpperCase()\n    );\n  }\n  _validateDisabled() {\n    if (!this._extentLayer) return;\n    let templates = this.querySelectorAll(\n      'map-link[rel=image],map-link[rel=tile],map-link[rel=features],map-link[rel=query]'\n    );\n    const noTemplateVisible = () => {\n      let totalTemplateCount = templates.length,\n        disabledTemplateCount = 0;\n      for (let j = 0; j < totalTemplateCount; j++) {\n        if (!templates[j]._validateDisabled()) {\n          disabledTemplateCount++;\n        }\n      }\n      return disabledTemplateCount === totalTemplateCount;\n    };\n    if (!this._projectionMatch() || noTemplateVisible()) {\n      this.setAttribute('disabled', '');\n      this.disabled = true;\n    } else {\n      this.removeAttribute('disabled');\n      this.disabled = false;\n    }\n    this.toggleLayerControlDisabled();\n    this._handleChange();\n    return this.disabled;\n  }\n  getMeta(metaName) {\n    let name = metaName.toLowerCase();\n    if (name !== 'extent' && name !== 'zoom') return;\n    return this.parentLayer.src\n      ? this.querySelector(`:scope > map-meta[name=${name}]`) ||\n          this.parentLayer.shadowRoot.querySelector(\n            `:host > map-meta[name=${name}]`\n          )\n      : this.querySelector(`:scope > map-meta[name=${name}]`) ||\n          this.parentLayer.querySelector(`:scope > map-meta[name=${name}]`);\n  }\n  // disable/italicize layer control elements based on the map-extent.disabled property\n  toggleLayerControlDisabled() {\n    let input = this._layerControlCheckbox,\n      label = this._layerControlLabel, // access to the label for the specific map-extent\n      opacityControl = this._opacityControl,\n      opacitySlider = this._opacitySlider,\n      selectDetails = this._selectdetails;\n    if (this.disabled) {\n      // update the status of layerControl\n      input.disabled = true;\n      opacitySlider.disabled = true;\n      label.style.fontStyle = 'italic';\n      opacityControl.style.fontStyle = 'italic';\n      if (selectDetails) {\n        selectDetails.forEach((i) => {\n          i.querySelectorAll('select').forEach((j) => {\n            j.disabled = true;\n            j.style.fontStyle = 'italic';\n          });\n          i.style.fontStyle = 'italic';\n        });\n      }\n    } else {\n      input.disabled = false;\n      opacitySlider.disabled = false;\n      label.style.fontStyle = 'normal';\n      opacityControl.style.fontStyle = 'normal';\n      if (selectDetails) {\n        selectDetails.forEach((i) => {\n          i.querySelectorAll('select').forEach((j) => {\n            j.disabled = false;\n            j.style.fontStyle = 'normal';\n          });\n          i.style.fontStyle = 'normal';\n        });\n      }\n    }\n  }\n\n  _handleChange() {\n    // add _extentLayer to map if map-extent is checked, otherwise remove it\n    if (this.checked && !this.disabled) {\n      // can be added to mapmllayer layerGroup no matter layer- is checked or not\n      this._extentLayer.addTo(this.parentLayer._layer);\n      this._extentLayer.setZIndex(\n        Array.from(this.parentLayer.querySelectorAll('map-extent')).indexOf(\n          this\n        )\n      );\n    } else {\n      this.parentLayer._layer.removeLayer(this._extentLayer);\n    }\n    // change the checkbox in the layer control to match map-extent.checked\n    // doesn't trigger the event handler because it's not user-caused AFAICT\n  }\n  _validateLayerControlContainerHidden() {\n    let extentsFieldset = this.parentLayer._propertiesGroupAnatomy;\n    let nodeToSearch = this.parentLayer.src\n      ? this.parentLayer.shadowRoot\n      : this.parentLayer;\n    if (!extentsFieldset) return;\n    if (\n      nodeToSearch.querySelectorAll('map-extent:not([hidden])').length === 0\n    ) {\n      extentsFieldset.setAttribute('hidden', '');\n    } else {\n      extentsFieldset.removeAttribute('hidden');\n    }\n  }\n  disconnectedCallback() {\n    // in case of projection change, the disconnectedcallback will be triggered by removing layer-._layer even before\n    // map-extent.connectedcallback is finished (because it will wait for the layer- to be ready)\n    // !this._extentLayer <=> this.connectedCallback has not yet been finished before disconnectedCallback is triggered\n    if (\n      this.hasAttribute('data-moving') ||\n      this.parentLayer.hasAttribute('data-moving') ||\n      !this._extentLayer\n    )\n      return;\n    this._validateLayerControlContainerHidden();\n    // remove layer control for map-extent from layer control DOM\n    // TODO: for the case of projection change, the layer control for map-extent has been created while _extentLayer has not yet been ready\n    this._layerControlHTML.remove();\n    if (this.parentLayer._layer) {\n      this.parentLayer._layer.removeLayer(this._extentLayer);\n    }\n    this.parentLayer.removeEventListener('map-change', this._changeHandler);\n    this.mapEl.removeEventListener('map-projectionchange', this._changeHandler);\n    delete this._extentLayer;\n    if (this.parentLayer._layer) delete this.parentLayer._layer.bounds;\n  }\n  _calculateBounds() {\n    delete this._extentLayer.bounds;\n    delete this._extentLayer.zoomBounds;\n    if (this.parentLayer._layer) delete this.parentLayer._layer.bounds;\n    let zoomMax = -Infinity,\n      zoomMin = Infinity,\n      maxNativeZoom = -Infinity,\n      minNativeZoom = Infinity,\n      templates = this.querySelectorAll(\n        'map-link[rel=image],map-link[rel=tile],map-link[rel=features],map-link[rel=query]'\n      );\n\n    // initialize bounds from this.scope > map-meta\n    let bounds = this.querySelector(':scope > map-meta[name=extent][content]')\n      ? M.getBoundsFromMeta(this) // TODO rewrite this pile of doo doo\n      : undefined;\n\n    // initialize zoom bounds from this.scope > map-meta\n    let zoomBounds = this.querySelector(':scope > map-meta[name=zoom][content]')\n      ? M.getZoomBoundsFromMeta(this) // TODO rewrite this pile of doo doo\n      : undefined;\n\n    // bounds should be able to be calculated unconditionally, not depend on map-extent.checked\n    for (let j = 0; j < templates.length; j++) {\n      const templateZoomBounds = templates[j].getZoomBounds(),\n        templateBounds = templates[j].getBounds();\n      let zoomMax =\n          zoomBounds && zoomBounds.hasOwnProperty('maxZoom')\n            ? zoomBounds.maxZoom\n            : -Infinity,\n        zoomMin =\n          zoomBounds && zoomBounds.hasOwnProperty('minZoom')\n            ? zoomBounds.minZoom\n            : Infinity,\n        minNativeZoom =\n          zoomBounds && zoomBounds.hasOwnProperty('minNativeZoom')\n            ? zoomBounds.minNativeZoom\n            : Infinity,\n        maxNativeZoom =\n          zoomBounds && zoomBounds.hasOwnProperty('maxNativeZoom')\n            ? zoomBounds.maxNativeZoom\n            : -Infinity;\n      if (!zoomBounds) {\n        zoomBounds = Object.assign({}, templateZoomBounds);\n      } else {\n        zoomMax = Math.max(zoomMax, templateZoomBounds.maxZoom);\n        zoomMin = Math.min(zoomMin, templateZoomBounds.minZoom);\n        maxNativeZoom = Math.max(\n          maxNativeZoom,\n          templateZoomBounds.maxNativeZoom\n        );\n        minNativeZoom = Math.min(\n          minNativeZoom,\n          templateZoomBounds.minNativeZoom\n        );\n        zoomBounds.minZoom = zoomMin;\n        zoomBounds.maxZoom = zoomMax;\n        zoomBounds.minNativeZoom = minNativeZoom;\n        zoomBounds.maxNativeZoom = maxNativeZoom;\n      }\n      if (!bounds) {\n        bounds = L.bounds(templateBounds.min, templateBounds.max);\n      } else {\n        bounds.extend(templateBounds);\n      }\n    }\n    if (bounds) {\n      this._extentLayer.bounds = bounds;\n    } else {\n      this._extentLayer.bounds = L.bounds(\n        M[this.units].options.bounds.min,\n        M[this.units].options.bounds.max\n      );\n    }\n    if (!zoomBounds) zoomBounds = {};\n    if (!zoomBounds.hasOwnProperty('minZoom')) {\n      zoomBounds.minZoom = 0;\n    }\n    if (!zoomBounds.hasOwnProperty('maxZoom')) {\n      zoomBounds.maxZoom = M[this.units].options.resolutions.length - 1;\n    }\n    if (\n      !zoomBounds.hasOwnProperty('minNativeZoom') ||\n      zoomBounds.minNativeZoom === Infinity\n    ) {\n      zoomBounds.minNativeZoom = zoomBounds.minZoom;\n    }\n    if (\n      !zoomBounds.hasOwnProperty('maxNativeZoom') ||\n      zoomBounds.maxNativeZoom === -Infinity\n    ) {\n      zoomBounds.maxNativeZoom = zoomBounds.maxZoom;\n    }\n    this._extentLayer.zoomBounds = zoomBounds;\n  }\n\n  whenReady() {\n    return new Promise((resolve, reject) => {\n      let interval, failureTimer;\n      if (this._extentLayer) {\n        resolve();\n      } else {\n        let extentElement = this;\n        interval = setInterval(testForExtent, 300, extentElement);\n        failureTimer = setTimeout(extentNotDefined, 10000);\n      }\n      function testForExtent(extentElement) {\n        if (extentElement._extentLayer) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          resolve();\n        } else if (!extentElement.isConnected) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          reject('map-extent was disconnected while waiting to be ready');\n        }\n      }\n      function extentNotDefined() {\n        clearInterval(interval);\n        clearTimeout(failureTimer);\n        reject('Timeout reached waiting for extent to be ready');\n      }\n    });\n  }\n\n  whenLinksReady() {\n    let templates = this.querySelectorAll(\n      'map-link[rel=image],map-link[rel=tile],map-link[rel=features],map-link[rel=query]'\n    );\n    let linksReady = [];\n    for (let link of [...templates]) {\n      linksReady.push(link.whenReady());\n    }\n    return Promise.allSettled(linksReady);\n  }\n}\n"],"names":["MapExtent","HTMLElement","observedAttributes","#hasConnected","units","this","getAttribute","M","FALLBACK_PROJECTION","checked","hasAttribute","val","setAttribute","removeAttribute","label","options","locale","dfExtent","opacity","_opacity","hidden","extent","getExtent","Object","assign","_convertAndFormatPCRS","_extentLayer","bounds","zoom","zoomBounds","_calculateBounds","getOuterHTML","let","tempElement","cloneNode","querySelector","mapLinks","querySelectorAll","forEach","mapLink","decodeURI","URL","attributes","href","value","baseURI","document","tref","outerLayer","outerHTML","remove","zoomTo","map","getMapEl","_map","xmin","topLeft","pcrs","horizontal","xmax","bottomRight","ymin","vertical","ymax","L","point","center","crs","unproject","getCenter","maxZoom","minZoom","setView","getMaxZoom","animate","getRootNode","ShadowRoot","host","closest","getLayerEl","attributeChangedCallback","name","oldValue","newValue","_layerControlHTML","innerHTML","parentLayer","whenReady","then","_handleChange","_layerControlCheckbox","catch","console","log","error","changeOpacity","extentsRootFieldset","_propertiesGroupAnatomy","position","Array","from","parentNode","indexOf","insertAdjacentElement","_validateLayerControlContainerHidden","constructor","super","_createLayerControlExtentHTML","bind","_changeHandler","connectedCallback","nodeName","toUpperCase","mapEl","whenProjectionDefined","Error","isConnected","addEventListener","extentLayer","extentZIndex","extentEl","_bindMutationObserver","_observer","MutationObserver","mutation","mutationList","type","_runMutationObserver","addedNodes","observe","childList","elementsGroup","_addMetaElement","_validateDisabled","i","length","element","toLowerCase","getLayerControlHTML","_projectionMatch","projection","templates","totalTemplateCount","disabledTemplateCount","j","noTemplateVisible","disabled","toggleLayerControlDisabled","getMeta","metaName","src","shadowRoot","input","_layerControlLabel","opacityControl","_opacityControl","opacitySlider","_opacitySlider","selectDetails","_selectdetails","style","fontStyle","addTo","_layer","setZIndex","removeLayer","extentsFieldset","nodeToSearch","disconnectedCallback","removeEventListener","getBoundsFromMeta","undefined","getZoomBoundsFromMeta","templateZoomBounds","getZoomBounds","templateBounds","getBounds","zoomMax","hasOwnProperty","Infinity","zoomMin","minNativeZoom","maxNativeZoom","Math","max","min","extend","resolutions","Promise","resolve","reject","interval","failureTimer","setInterval","extentElement","clearInterval","clearTimeout","setTimeout","whenLinksReady","link","linksReady","push","allSettled"],"mappings":"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"}