{"version":3,"file":"map-extent.js","sources":["../src/map-extent.js"],"sourcesContent":["/* global M */\nexport class MapExtent extends HTMLElement {\n  static get observedAttributes() {\n    return ['units', 'checked', 'label', 'opacity', 'hidden'];\n  }\n  get units() {\n    return this.getAttribute('units');\n  }\n  set units(val) {\n    // built in support for OSMTILE, CBMTILE, WGS84 and APSTILE\n    if (['OSMTILE', 'CBMTILE', 'WGS84', 'APSTILE'].includes(val)) {\n      this.setAttribute('units', val);\n    }\n    // else need to check with the mapml-viewer element if the custom projection is defined\n  }\n  get checked() {\n    return this.hasAttribute('checked');\n  }\n\n  set checked(val) {\n    if (val) {\n      this.setAttribute('checked', '');\n    } else {\n      this.removeAttribute('checked');\n    }\n  }\n  get label() {\n    return this.hasAttribute('label')\n      ? this.getAttribute('label')\n      : M.options.locale.dfExtent;\n  }\n  set label(val) {\n    if (val) {\n      this.setAttribute('label', val);\n    }\n  }\n  get opacity() {\n    // use ?? since 0 is falsy, || would return rhs in that case\n    return +(this._opacity ?? this.getAttribute('opacity'));\n  }\n\n  set opacity(val) {\n    if (+val > 1 || +val < 0) return;\n    this.setAttribute('opacity', val);\n  }\n  get hidden() {\n    return this.hasAttribute('hidden');\n  }\n\n  set hidden(val) {\n    if (val) {\n      this.setAttribute('hidden', '');\n    } else {\n      this.removeAttribute('hidden');\n    }\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    this.whenReady()\n      .then(() => {\n        switch (name) {\n          case 'units':\n            if (oldValue !== newValue) {\n              // handle side effects\n            }\n            break;\n          case 'label':\n            if (oldValue !== newValue) {\n              this._layerControlHTML.querySelector(\n                '.mapml-layer-item-name'\n              ).innerHTML = newValue || M.options.locale.dfExtent;\n            }\n            break;\n          case 'checked':\n            this._handleChange();\n            this._calculateBounds();\n            this._layerControlCheckbox.checked = newValue !== null;\n            break;\n          case 'opacity':\n            if (oldValue !== newValue) {\n              this._opacity = newValue;\n              if (this._templatedLayer)\n                this._templatedLayer.changeOpacity(newValue);\n            }\n            break;\n          case 'hidden':\n            if (oldValue !== newValue) {\n              let extentsRootFieldset =\n                this.parentLayer._propertiesGroupAnatomy;\n              let position = Array.from(\n                this.parentNode.querySelectorAll('map-extent:not([hidden])')\n              ).indexOf(this);\n              if (newValue !== null) {\n                // remove from layer control (hide from user)\n                this._layerControlHTML.remove();\n              } else {\n                // insert the extent fieldset into the layer control container in\n                // the calculated position\n                if (position === 0) {\n                  extentsRootFieldset.insertAdjacentElement(\n                    'afterbegin',\n                    this._layerControlHTML\n                  );\n                } else if (position > 0) {\n                  this.parentNode\n                    .querySelectorAll('map-extent:not([hidden])')\n                    [position - 1]._layerControlHTML.insertAdjacentElement(\n                      'afterend',\n                      this._layerControlHTML\n                    );\n                }\n              }\n              this._validateLayerControlContainerHidden();\n            }\n            break;\n        }\n      })\n      .catch((reason) => {\n        console.log(\n          reason,\n          `\\nin mapExtent.attributeChangeCallback when changing attribute ${name}`\n        );\n      });\n  }\n  constructor() {\n    // Always call super first in constructor\n    super();\n  }\n  async connectedCallback() {\n    // this.parentNode.host returns the layer- element when parentNode is\n    // the shadow root\n    this._createLayerControlExtentHTML =\n      M._createLayerControlExtentHTML.bind(this);\n    this.parentLayer =\n      this.parentNode.nodeName.toUpperCase() === 'LAYER-'\n        ? this.parentNode\n        : this.parentNode.host;\n    if (\n      this.hasAttribute('data-moving') ||\n      this.parentLayer.hasAttribute('data-moving')\n    )\n      return;\n    if (\n      this.querySelector('map-link[rel=query], map-link[rel=features]') &&\n      !this.shadowRoot\n    ) {\n      this.attachShadow({ mode: 'open' });\n    }\n    await this.parentLayer.whenReady();\n    // when projection is changed, the parent layer-._layer is created (so whenReady is fulfilled) but then removed,\n    // then the map-extent disconnectedCallback will be triggered by layer-._onRemove() (clear the shadowRoot)\n    // even before connectedCallback is finished\n    // in this case, the microtasks triggered by the fulfillment of the removed MapMLLayer should be stopped as well\n    // !this.isConnected <=> the disconnectedCallback has run before\n    if (!this.isConnected) return;\n    this._layer = this.parentLayer._layer;\n    this._map = this._layer._map;\n    // reset the layer extent\n    delete this.parentLayer.bounds;\n    this._templateVars = this._initTemplateVars(\n      // read map-meta[name=extent] from shadowroot or layer-\n      // querySelector / querySelectorAll on layer- cannot get elements inside its shadowroot\n      this.parentLayer.shadowRoot\n        ? this.parentLayer.shadowRoot.querySelector(\n            'map-extent > map-meta[name=extent]'\n          ) ||\n            this.parentLayer.shadowRoot.querySelector('map-meta[name=extent]')\n        : this.parentLayer.querySelector(\n            'map-extent > map-meta[name=extent]'\n          ) || this.parentLayer.querySelector('map-meta[name=extent]'),\n      this.units,\n      this._layer._content,\n      this._layer.getBase(),\n      this.units === this._layer.options.mapprojection\n    );\n    this._changeHandler = this._handleChange.bind(this);\n    this.parentLayer.addEventListener('map-change', this._changeHandler);\n    // this._opacity is used to record the current opacity value (with or without updates),\n    // the initial value of this._opacity should be set as opacity attribute value, if exists, or the default value 1.0\n    this._opacity = +(this.getAttribute('opacity') || 1.0);\n    this._templatedLayer = M.templatedLayer(this._templateVars, {\n      pane: this._layer._container,\n      opacity: this.opacity,\n      _leafletLayer: this._layer,\n      crs: this._layer._properties.crs,\n      extentZIndex: Array.from(\n        this.parentLayer.querySelectorAll('map-extent')\n      ).indexOf(this),\n      // when a <map-extent> migrates from a remote mapml file and attaches to the shadow of <layer- >\n      // this._properties._mapExtents[i] refers to the <map-extent> in remote mapml\n      extentEl: this._DOMnode || this\n    });\n    // this._layerControlHTML is the fieldset for the extent in the LayerControl\n    this._layerControlHTML = this._createLayerControlExtentHTML();\n    if (!this.hidden)\n      this._layer.addExtentToLayerControl(this._layerControlHTML);\n    this._validateLayerControlContainerHidden();\n    if (this._templatedLayer._queries) {\n      if (!this._layer._properties._queries)\n        this._layer._properties._queries = [];\n      this._layer._properties._queries =\n        this._layer._properties._queries.concat(this._templatedLayer._queries);\n    }\n    this._calculateBounds();\n  }\n  getLayerControlHTML() {\n    return this._layerControlHTML;\n  }\n  _projectionMatch() {\n    return (\n      this.units.toUpperCase() ===\n      this._layer.options.mapprojection.toUpperCase()\n    );\n  }\n  _validateDisabled() {\n    if (!this._templatedLayer) return;\n    const noTemplateVisible = () => {\n      let totalTemplateCount = this._templatedLayer._templates.length,\n        disabledTemplateCount = 0;\n      for (let j = 0; j < this._templatedLayer._templates.length; j++) {\n        if (this._templatedLayer._templates[j].rel === 'query') {\n          continue;\n        }\n        if (!this._templatedLayer._templates[j].layer.isVisible) {\n          disabledTemplateCount++;\n        }\n      }\n      return disabledTemplateCount === totalTemplateCount;\n    };\n    if (!this._projectionMatch() || noTemplateVisible()) {\n      this.setAttribute('disabled', '');\n      this.disabled = true;\n    } else {\n      this.removeAttribute('disabled');\n      this.disabled = false;\n    }\n    this.toggleLayerControlDisabled();\n    return this.disabled;\n  }\n\n  // disable/italicize layer control elements based on the map-extent.disabled property\n  toggleLayerControlDisabled() {\n    let input = this._layerControlCheckbox,\n      label = this._layerControlLabel, // access to the label for the specific map-extent\n      opacityControl = this._opacityControl,\n      opacitySlider = this._opacitySlider,\n      selectDetails = this._selectdetails;\n    if (this.disabled) {\n      // update the status of layerControl\n      input.disabled = true;\n      opacitySlider.disabled = true;\n      label.style.fontStyle = 'italic';\n      opacityControl.style.fontStyle = 'italic';\n      if (selectDetails) {\n        selectDetails.forEach((i) => {\n          i.querySelectorAll('select').forEach((j) => {\n            j.disabled = true;\n            j.style.fontStyle = 'italic';\n          });\n          i.style.fontStyle = 'italic';\n        });\n      }\n    } else {\n      input.disabled = false;\n      opacitySlider.disabled = false;\n      label.style.fontStyle = 'normal';\n      opacityControl.style.fontStyle = 'normal';\n      if (selectDetails) {\n        selectDetails.forEach((i) => {\n          i.querySelectorAll('select').forEach((j) => {\n            j.disabled = false;\n            j.style.fontStyle = 'normal';\n          });\n          i.style.fontStyle = 'normal';\n        });\n      }\n    }\n  }\n\n  _initTemplateVars(metaExtent, projection, mapml, base, projectionMatch) {\n    function transcribe(element) {\n      var select = document.createElement('select');\n      var elementAttrNames = element.getAttributeNames();\n\n      for (let i = 0; i < elementAttrNames.length; i++) {\n        select.setAttribute(\n          elementAttrNames[i],\n          element.getAttribute(elementAttrNames[i])\n        );\n      }\n\n      var options = element.children;\n\n      for (let i = 0; i < options.length; i++) {\n        var option = document.createElement('option');\n        var optionAttrNames = options[i].getAttributeNames();\n\n        for (let j = 0; j < optionAttrNames.length; j++) {\n          option.setAttribute(\n            optionAttrNames[j],\n            options[i].getAttribute(optionAttrNames[j])\n          );\n        }\n\n        option.innerHTML = options[i].innerHTML;\n        select.appendChild(option);\n      }\n      return select;\n    }\n    var templateVars = [];\n    // set up the URL template and associated inputs (which yield variable values when processed)\n    var tlist = this.querySelectorAll(\n        'map-link[rel=tile],map-link[rel=image],map-link[rel=features],map-link[rel=query]'\n      ),\n      varNamesRe = new RegExp('(?:{)(.*?)(?:})', 'g'),\n      zoomInput = this.querySelector('map-input[type=\"zoom\" i]'),\n      includesZoom = false,\n      boundsFallback = {};\n\n    boundsFallback.zoom = 0;\n    if (metaExtent) {\n      let content = M._metaContentToObject(metaExtent.getAttribute('content')),\n        cs;\n\n      boundsFallback.zoom = content.zoom || boundsFallback.zoom;\n\n      let metaKeys = Object.keys(content);\n      for (let i = 0; i < metaKeys.length; i++) {\n        if (!metaKeys[i].includes('zoom')) {\n          cs = M.axisToCS(metaKeys[i].split('-')[2]);\n          break;\n        }\n      }\n      let axes = M.csToAxes(cs);\n      boundsFallback.bounds = M.boundsToPCRSBounds(\n        L.bounds(\n          L.point(\n            +content[`top-left-${axes[0]}`],\n            +content[`top-left-${axes[1]}`]\n          ),\n          L.point(\n            +content[`bottom-right-${axes[0]}`],\n            +content[`bottom-right-${axes[1]}`]\n          )\n        ),\n        boundsFallback.zoom,\n        projection,\n        cs\n      );\n    } else {\n      // for custom projections, M[projection] may not be loaded, so uses M['OSMTILE'] as backup, this code will need to get rerun once projection is changed and M[projection] is available\n      // TODO: This is a temporary fix, _initTemplateVars (or processinitialextent) should not be called when projection of the layer and map do not match, this should be called/reinitialized once the layer projection matches with the map projection\n      let fallbackProjection = M[projection] || M.OSMTILE;\n      boundsFallback.bounds = fallbackProjection.options.crs.pcrs.bounds;\n    }\n\n    for (var i = 0; i < tlist.length; i++) {\n      var t = tlist[i],\n        template = t.getAttribute('tref');\n      t.zoomInput = zoomInput;\n      if (!template) {\n        template = M.BLANK_TT_TREF;\n        let blankInputs = mapml.querySelectorAll('map-input');\n        for (let i of blankInputs) {\n          template += `{${i.getAttribute('name')}}`;\n        }\n      }\n\n      var v,\n        title = t.hasAttribute('title')\n          ? t.getAttribute('title')\n          : 'Query this layer',\n        vcount = template.match(varNamesRe),\n        trel =\n          !t.hasAttribute('rel') ||\n          t.getAttribute('rel').toLowerCase() === 'tile'\n            ? 'tile'\n            : t.getAttribute('rel').toLowerCase(),\n        ttype = !t.hasAttribute('type')\n          ? 'image/*'\n          : t.getAttribute('type').toLowerCase(),\n        inputs = [],\n        tms = t && t.hasAttribute('tms');\n      var zoomBounds = mapml.querySelector('map-meta[name=zoom]')\n        ? M._metaContentToObject(\n            mapml.querySelector('map-meta[name=zoom]').getAttribute('content')\n          )\n        : undefined;\n      while ((v = varNamesRe.exec(template)) !== null) {\n        var varName = v[1],\n          inp = this.querySelector(\n            'map-input[name=' + varName + '],map-select[name=' + varName + ']'\n          );\n        if (inp) {\n          if (\n            inp.hasAttribute('type') &&\n            inp.getAttribute('type') === 'location' &&\n            (!inp.hasAttribute('min') || !inp.hasAttribute('max')) &&\n            inp.hasAttribute('axis') &&\n            !['i', 'j'].includes(inp.getAttribute('axis').toLowerCase())\n          ) {\n            if (\n              zoomInput &&\n              template.includes(`{${zoomInput.getAttribute('name')}}`)\n            ) {\n              zoomInput.setAttribute('value', boundsFallback.zoom);\n            }\n            let axis = inp.getAttribute('axis'),\n              axisBounds = M.convertPCRSBounds(\n                boundsFallback.bounds,\n                boundsFallback.zoom,\n                projection,\n                M.axisToCS(axis)\n              );\n            inp.setAttribute('min', axisBounds.min[M.axisToXY(axis)]);\n            inp.setAttribute('max', axisBounds.max[M.axisToXY(axis)]);\n          }\n\n          inputs.push(inp);\n          includesZoom =\n            includesZoom ||\n            (inp.hasAttribute('type') &&\n              inp.getAttribute('type').toLowerCase() === 'zoom');\n          if (inp.tagName.toLowerCase() === 'map-select') {\n            // use a throwaway div to parse the input from MapML into HTML\n            var div = document.createElement('div');\n            div.insertAdjacentHTML('afterbegin', inp.outerHTML);\n            // parse\n            inp.htmlselect = div.querySelector('map-select');\n            inp.htmlselect = transcribe(inp.htmlselect);\n\n            // this goes into the layer control, so add a listener\n            L.DomEvent.on(inp.htmlselect, 'change', this.redraw, this);\n\n            if (!this._userInputs) {\n              this._userInputs = [];\n            }\n            this._userInputs.push(inp.htmlselect);\n          }\n          // TODO: if this is an input@type=location\n          // get the TCRS min,max attribute values at the identified zoom level\n          // save this information as properties of the mapExtent,\n          // perhaps as a bounds object so that it can be easily used\n          // later by the layer control to determine when to enable\n          // disable the layer for drawing.\n        } else {\n          console.log(\n            'input with name=' +\n              varName +\n              ' not found for template variable of same name'\n          );\n          // no match found, template won't be used\n          break;\n        }\n      }\n      if (\n        (template && vcount.length === inputs.length) ||\n        template === M.BLANK_TT_TREF\n      ) {\n        if (trel === 'query') {\n          this._layer.queryable = true;\n        }\n        if (!includesZoom && zoomInput) {\n          inputs.push(zoomInput);\n        }\n        let step = zoomInput ? zoomInput.getAttribute('step') : 1;\n        if (!step || step === '0' || isNaN(step)) step = 1;\n        // template has a matching input for every variable reference {varref}\n        templateVars.push({\n          template: decodeURI(new URL(template, base)),\n          linkEl: t,\n          title: title,\n          rel: trel,\n          type: ttype,\n          values: inputs,\n          zoomBounds: zoomBounds,\n          boundsFallbackPCRS: { bounds: boundsFallback.bounds },\n          projectionMatch: projectionMatch,\n          projection: this.units || M.FALLBACK_PROJECTION,\n          tms: tms,\n          step: step\n        });\n      }\n    }\n    return templateVars;\n  }\n  redraw() {\n    this._templatedLayer.redraw();\n  }\n\n  _handleChange() {\n    // if the parent layer- is checked, add _templatedLayer to map if map-extent is checked, otherwise remove it\n    if (this.checked && this.parentLayer.checked && !this.disabled) {\n      this._templatedLayer.addTo(this._layer._map);\n      this._templatedLayer.setZIndex(\n        Array.from(this.parentLayer.querySelectorAll('map-extent')).indexOf(\n          this\n        )\n      );\n    } else {\n      this._map.removeLayer(this._templatedLayer);\n    }\n    // change the checkbox in the layer control to match map-extent.checked\n    // doesn't trigger the event handler because it's not user-caused AFAICT\n  }\n  _validateLayerControlContainerHidden() {\n    let extentsFieldset = this.parentLayer._propertiesGroupAnatomy;\n    let nodeToSearch = this.parentLayer.shadowRoot || this.parentLayer;\n    if (\n      nodeToSearch.querySelectorAll('map-extent:not([hidden])').length === 0\n    ) {\n      extentsFieldset.setAttribute('hidden', '');\n    } else {\n      extentsFieldset.removeAttribute('hidden');\n    }\n  }\n  disconnectedCallback() {\n    // in case of projection change, the disconnectedcallback will be triggered by removing layer-._layer even before\n    // map-extent.connectedcallback is finished (because it will wait for the layer- to be ready)\n    // !this._templatedLayer <=> this.connectedCallback has not yet been finished before disconnectedCallback is triggered\n    if (\n      this.hasAttribute('data-moving') ||\n      this.parentLayer.hasAttribute('data-moving') ||\n      !this._templatedLayer\n    )\n      return;\n    this._validateLayerControlContainerHidden();\n    // remove layer control for map-extent from layer control DOM\n    this._layerControlHTML.remove();\n    this._map.removeLayer(this._templatedLayer);\n    this.parentLayer.removeEventListener('map-change', this._changeHandler);\n    delete this._templatedLayer;\n    delete this.parentLayer.bounds;\n  }\n  _calculateBounds() {\n    let bounds = null,\n      zoomMax = 0,\n      zoomMin = 0,\n      maxNativeZoom = 0,\n      minNativeZoom = 0;\n    // bounds should be able to be calculated unconditionally, not depend on map-extent.checked\n    for (let j = 0; j < this._templateVars.length; j++) {\n      let inputData = M._extractInputBounds(this._templateVars[j]);\n      this._templateVars[j].tempExtentBounds = inputData.bounds;\n      this._templateVars[j].extentZoomBounds = inputData.zoomBounds;\n      if (!bounds) {\n        bounds = this._templateVars[j].tempExtentBounds;\n        zoomMax = this._templateVars[j].extentZoomBounds.maxZoom;\n        zoomMin = this._templateVars[j].extentZoomBounds.minZoom;\n        maxNativeZoom = this._templateVars[j].extentZoomBounds.maxNativeZoom;\n        minNativeZoom = this._templateVars[j].extentZoomBounds.minNativeZoom;\n      } else {\n        bounds.extend(this._templateVars[j].tempExtentBounds.min);\n        bounds.extend(this._templateVars[j].tempExtentBounds.max);\n        zoomMax = Math.max(\n          zoomMax,\n          this._templateVars[j].extentZoomBounds.maxZoom\n        );\n        zoomMin = Math.min(\n          zoomMin,\n          this._templateVars[j].extentZoomBounds.minZoom\n        );\n        maxNativeZoom = Math.max(\n          maxNativeZoom,\n          this._templateVars[j].extentZoomBounds.maxNativeZoom\n        );\n        minNativeZoom = Math.min(\n          minNativeZoom,\n          this._templateVars[j].extentZoomBounds.minNativeZoom\n        );\n      }\n    }\n    // cannot be named as layerBounds if we decide to keep the debugoverlay logic\n    this._templatedLayer.bounds = bounds;\n    this._templatedLayer.zoomBounds = {\n      minZoom: zoomMin,\n      maxZoom: zoomMax,\n      maxNativeZoom,\n      minNativeZoom\n    };\n  }\n\n  whenReady() {\n    return new Promise((resolve, reject) => {\n      let interval, failureTimer;\n      if (this._templatedLayer) {\n        resolve();\n      } else {\n        let extentElement = this;\n        interval = setInterval(testForExtent, 300, extentElement);\n        failureTimer = setTimeout(extentNotDefined, 10000);\n      }\n      function testForExtent(extentElement) {\n        if (extentElement._templatedLayer) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          resolve();\n        } else if (!extentElement.isConnected) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          reject('map-extent was disconnected while waiting to be ready');\n        }\n      }\n      function extentNotDefined() {\n        clearInterval(interval);\n        clearTimeout(failureTimer);\n        reject('Timeout reached waiting for extent to be ready');\n      }\n    });\n  }\n}\n"],"names":["MapExtent","HTMLElement","observedAttributes","units","this","getAttribute","val","includes","setAttribute","checked","hasAttribute","removeAttribute","label","M","options","locale","dfExtent","opacity","_opacity","hidden","attributeChangedCallback","name","oldValue","newValue","whenReady","then","_layerControlHTML","querySelector","innerHTML","_handleChange","_calculateBounds","_layerControlCheckbox","_templatedLayer","changeOpacity","let","extentsRootFieldset","parentLayer","_propertiesGroupAnatomy","position","Array","from","parentNode","querySelectorAll","indexOf","remove","insertAdjacentElement","_validateLayerControlContainerHidden","catch","console","log","reason","constructor","super","connectedCallback","_createLayerControlExtentHTML","bind","nodeName","toUpperCase","host","shadowRoot","attachShadow","mode","isConnected","_layer","_map","bounds","_templateVars","_initTemplateVars","_content","getBase","mapprojection","_changeHandler","addEventListener","templatedLayer","pane","_container","_leafletLayer","crs","_properties","extentZIndex","extentEl","_DOMnode","addExtentToLayerControl","_queries","concat","getLayerControlHTML","_projectionMatch","_validateDisabled","noTemplateVisible","totalTemplateCount","_templates","length","disabledTemplateCount","j","rel","layer","isVisible","disabled","toggleLayerControlDisabled","input","_layerControlLabel","opacityControl","_opacityControl","opacitySlider","_opacitySlider","selectDetails","_selectdetails","style","fontStyle","forEach","i","metaExtent","projection","mapml","base","projectionMatch","templateVars","tlist","varNamesRe","RegExp","zoomInput","includesZoom","boundsFallback","zoom","content","_metaContentToObject","cs","metaKeys","Object","keys","axisToCS","split","axes","csToAxes","boundsToPCRSBounds","L","point","fallbackProjection","OSMTILE","pcrs","t","template","BLANK_TT_TREF","title","vcount","match","trel","toLowerCase","ttype","inputs","tms","zoomBounds","undefined","v","exec","div","varName","inp","axis","axisBounds","convertPCRSBounds","min","axisToXY","max","push","tagName","document","createElement","insertAdjacentHTML","outerHTML","htmlselect","element","select","elementAttrNames","getAttributeNames","children","option","optionAttrNames","appendChild","transcribe","DomEvent","on","redraw","_userInputs","queryable","step","isNaN","decodeURI","URL","linkEl","type","values","boundsFallbackPCRS","FALLBACK_PROJECTION","addTo","setZIndex","removeLayer","extentsFieldset","nodeToSearch","disconnectedCallback","removeEventListener","zoomMax","zoomMin","maxNativeZoom","minNativeZoom","inputData","_extractInputBounds","tempExtentBounds","extentZoomBounds","extend","Math","maxZoom","minZoom","Promise","resolve","reject","interval","failureTimer","setInterval","extentElement","clearInterval","clearTimeout","setTimeout"],"mappings":";;MACaA,kBAAkBC,YAC7BC,gCACE,MAAO,CAAC,QAAS,UAAW,QAAS,UAAW,UAElDC,YACE,OAAOC,KAAKC,aAAa,SAE3BF,UAAUG,GAEJ,CAAC,UAAW,UAAW,QAAS,WAAWC,SAASD,IACtDF,KAAKI,aAAa,QAASF,GAI/BG,cACE,OAAOL,KAAKM,aAAa,WAG3BD,YAAYH,GACNA,EACFF,KAAKI,aAAa,UAAW,IAE7BJ,KAAKO,gBAAgB,WAGzBC,YACE,OAAOR,KAAKM,aAAa,SACrBN,KAAKC,aAAa,SAClBQ,EAAEC,QAAQC,OAAOC,SAEvBJ,UAAUN,GACJA,GACFF,KAAKI,aAAa,QAASF,GAG/BW,cAEE,QAASb,KAAKc,UAAYd,KAAKC,aAAa,YAG9CY,YAAYX,GACC,GAANA,IAAYA,EAAM,GACvBF,KAAKI,aAAa,UAAWF,GAE/Ba,aACE,OAAOf,KAAKM,aAAa,UAG3BS,WAAWb,GACLA,EACFF,KAAKI,aAAa,SAAU,IAE5BJ,KAAKO,gBAAgB,UAGzBS,yBAAyBC,EAAMC,EAAUC,GACvCnB,KAAKoB,YACFC,KAAK,KACJ,OAAQJ,GACN,IAAK,QAIH,MACF,IAAK,QACCC,IAAaC,IACfnB,KAAKsB,kBAAkBC,cACrB,0BACAC,UAAYL,GAAYV,EAAEC,QAAQC,OAAOC,UAE7C,MACF,IAAK,UACHZ,KAAKyB,gBACLzB,KAAK0B,mBACL1B,KAAK2B,sBAAsBtB,QAAuB,OAAbc,EACrC,MACF,IAAK,UACCD,IAAaC,IACfnB,KAAKc,SAAWK,EACZnB,KAAK4B,iBACP5B,KAAK4B,gBAAgBC,cAAcV,IAEvC,MACF,IAAK,SACH,GAAID,IAAaC,EAAU,CACzBW,IAAIC,EACF/B,KAAKgC,YAAYC,wBACnBH,IAAII,EAAWC,MAAMC,KACnBpC,KAAKqC,WAAWC,iBAAiB,6BACjCC,QAAQvC,MACO,OAAbmB,EAEFnB,KAAKsB,kBAAkBkB,SAIN,IAAbN,EACFH,EAAoBU,sBAClB,aACAzC,KAAKsB,mBAEa,EAAXY,GACTlC,KAAKqC,WACFC,iBAAiB,4BACjBJ,EAAW,GAAGZ,kBAAkBmB,sBAC/B,WACAzC,KAAKsB,mBAIbtB,KAAK0C,2CAKZC,MAAM,IACLC,QAAQC,IACNC;+DACkE7B,KAI1E8B,cAEEC,QAEFC,0BAGEjD,KAAKkD,8BACHzC,EAAEyC,8BAA8BC,KAAKnD,MACvCA,KAAKgC,YACwC,WAA3ChC,KAAKqC,WAAWe,SAASC,cACrBrD,KAAKqC,WACLrC,KAAKqC,WAAWiB,KAEpBtD,KAAKM,aAAa,gBAClBN,KAAKgC,YAAY1B,aAAa,iBAI9BN,KAAKuB,cAAc,iDAClBvB,KAAKuD,YAENvD,KAAKwD,aAAa,CAAEC,KAAM,eAEtBzD,KAAKgC,YAAYZ,YAMlBpB,KAAK0D,cACV1D,KAAK2D,OAAS3D,KAAKgC,YAAY2B,OAC/B3D,KAAK4D,KAAO5D,KAAK2D,OAAOC,YAEjB5D,KAAKgC,YAAY6B,OACxB7D,KAAK8D,cAAgB9D,KAAK+D,kBAGxB/D,KAAKgC,YAAYuB,WACbvD,KAAKgC,YAAYuB,WAAWhC,cAC1B,uCAEAvB,KAAKgC,YAAYuB,WAAWhC,cAAc,yBAC5CvB,KAAKgC,YAAYT,cACf,uCACGvB,KAAKgC,YAAYT,cAAc,yBACxCvB,KAAKD,MACLC,KAAK2D,OAAOK,SACZhE,KAAK2D,OAAOM,UACZjE,KAAKD,QAAUC,KAAK2D,OAAOjD,QAAQwD,eAErClE,KAAKmE,eAAiBnE,KAAKyB,cAAc0B,KAAKnD,MAC9CA,KAAKgC,YAAYoC,iBAAiB,aAAcpE,KAAKmE,gBAGrDnE,KAAKc,WAAad,KAAKC,aAAa,YAAc,GAClDD,KAAK4B,gBAAkBnB,EAAE4D,eAAerE,KAAK8D,cAAe,CAC1DQ,KAAMtE,KAAK2D,OAAOY,WAClB1D,QAASb,KAAKa,QACd2D,cAAexE,KAAK2D,OACpBc,IAAKzE,KAAK2D,OAAOe,YAAYD,IAC7BE,aAAcxC,MAAMC,KAClBpC,KAAKgC,YAAYM,iBAAiB,eAClCC,QAAQvC,MAGV4E,SAAU5E,KAAK6E,UAAY7E,OAG7BA,KAAKsB,kBAAoBtB,KAAKkD,gCACzBlD,KAAKe,QACRf,KAAK2D,OAAOmB,wBAAwB9E,KAAKsB,mBAC3CtB,KAAK0C,uCACD1C,KAAK4B,gBAAgBmD,WAClB/E,KAAK2D,OAAOe,YAAYK,WAC3B/E,KAAK2D,OAAOe,YAAYK,SAAW,IACrC/E,KAAK2D,OAAOe,YAAYK,SACtB/E,KAAK2D,OAAOe,YAAYK,SAASC,OAAOhF,KAAK4B,gBAAgBmD,WAEjE/E,KAAK0B,qBAEPuD,sBACE,OAAOjF,KAAKsB,kBAEd4D,mBACE,OACElF,KAAKD,MAAMsD,gBACXrD,KAAK2D,OAAOjD,QAAQwD,cAAcb,cAGtC8B,oBACE,GAAKnF,KAAK4B,gBAAV,CACA,IAAMwD,EAAoB,KACxBtD,IAAIuD,EAAqBrF,KAAK4B,gBAAgB0D,WAAWC,OACvDC,EAAwB,EAC1B,IAAK1D,IAAI2D,EAAI,EAAGA,EAAIzF,KAAK4B,gBAAgB0D,WAAWC,OAAQE,IACX,UAA3CzF,KAAK4B,gBAAgB0D,WAAWG,GAAGC,MAGlC1F,KAAK4B,gBAAgB0D,WAAWG,GAAGE,MAAMC,WAC5CJ,KAGJ,OAAOA,IAA0BH,GAUnC,OARKrF,KAAKkF,oBAAsBE,KAC9BpF,KAAKI,aAAa,WAAY,IAC9BJ,KAAK6F,UAAW,IAEhB7F,KAAKO,gBAAgB,YACrBP,KAAK6F,UAAW,GAElB7F,KAAK8F,6BACE9F,KAAK6F,UAIdC,6BACEhE,IAAIiE,EAAQ/F,KAAK2B,sBACfnB,EAAQR,KAAKgG,mBACbC,EAAiBjG,KAAKkG,gBACtBC,EAAgBnG,KAAKoG,eACrBC,EAAgBrG,KAAKsG,eACnBtG,KAAK6F,UAEPE,EAAMF,UAAW,EACjBM,EAAcN,UAAW,EACzBrF,EAAM+F,MAAMC,UAAY,SACxBP,EAAeM,MAAMC,UAAY,SAC7BH,GACFA,EAAcI,QAAQ,IACpBC,EAAEpE,iBAAiB,UAAUmE,QAAQ,IACnChB,EAAEI,UAAW,EACbJ,EAAEc,MAAMC,UAAY,WAEtBE,EAAEH,MAAMC,UAAY,aAIxBT,EAAMF,UAAW,EACjBM,EAAcN,UAAW,EACzBrF,EAAM+F,MAAMC,UAAY,SACxBP,EAAeM,MAAMC,UAAY,SAC7BH,GACFA,EAAcI,QAAQ,IACpBC,EAAEpE,iBAAiB,UAAUmE,QAAQ,IACnChB,EAAEI,UAAW,EACbJ,EAAEc,MAAMC,UAAY,WAEtBE,EAAEH,MAAMC,UAAY,YAM5BzC,kBAAkB4C,EAAYC,EAAYC,EAAOC,EAAMC,GA8BrD,IAAIC,EAAe,GAEfC,EAAQjH,KAAKsC,iBACb,qFAEF4E,EAAa,IAAIC,OAAO,kBAAmB,KAC3CC,EAAYpH,KAAKuB,cAAc,4BAC/B8F,GAAe,EACfC,EAAiB,CAEnBC,KAAsB,GACtB,GAAIZ,EAAY,CACd7E,IAAI0F,EAAU/G,EAAEgH,qBAAqBd,EAAW1G,aAAa,YAC3DyH,EAEFJ,EAAeC,KAAOC,EAAQD,MAAQD,EAAeC,KAErDzF,IAAI6F,EAAWC,OAAOC,KAAKL,GAC3B,IAAK1F,IAAI4E,EAAI,EAAGA,EAAIiB,EAASpC,OAAQmB,IACnC,IAAKiB,EAASjB,GAAGvG,SAAS,QAAS,CACjCuH,EAAKjH,EAAEqH,SAASH,EAASjB,GAAGqB,MAAM,KAAK,IACvC,MAGJjG,IAAIkG,EAAOvH,EAAEwH,SAASP,GACtBJ,EAAezD,OAASpD,EAAEyH,mBACxBC,EAAEtE,OACAsE,EAAEC,OACCZ,EAAQ,YAAYQ,EAAK,KACzBR,EAAQ,YAAYQ,EAAK,KAE5BG,EAAEC,OACCZ,EAAQ,gBAAgBQ,EAAK,KAC7BR,EAAQ,gBAAgBQ,EAAK,MAGlCV,EAAeC,KACfX,EACAc,OAEG,CAGDW,EAAqB5H,EAAEmG,IAAenG,EAAE6H,QAC5ChB,EAAezD,OAASwE,EAAmB3H,QAAQ+D,IAAI8D,KAAK1E,OAG9D,IAAK,IAAI6C,EAAI,EAAGA,EAAIO,EAAM1B,OAAQmB,IAAK,CACrC,IAAI8B,EAAIvB,EAAMP,GACZ+B,EAAWD,EAAEvI,aAAa,QAE5B,GADAuI,EAAEpB,UAAYA,GACTqB,EAAU,CAEb3G,IACS4E,EAFT+B,EAAWhI,EAAEiI,cAEb,IAAShC,KADSG,EAAMvE,iBAAiB,aAEvCmG,OAAgB/B,EAAEzG,aAAa,WAwBnC,IApBA,IACE0I,EAAQH,EAAElI,aAAa,SACnBkI,EAAEvI,aAAa,SACf,mBACJ2I,EAASH,EAASI,MAAM3B,GACxB4B,EACGN,EAAElI,aAAa,QACwB,SAAxCkI,EAAEvI,aAAa,OAAO8I,cAElBP,EAAEvI,aAAa,OAAO8I,cADtB,OAENC,EAASR,EAAElI,aAAa,QAEpBkI,EAAEvI,aAAa,QAAQ8I,cADvB,UAEJE,EAAS,GACTC,EAAMV,GAAKA,EAAElI,aAAa,OACxB6I,EAAatC,EAAMtF,cAAc,uBACjCd,EAAEgH,qBACAZ,EAAMtF,cAAc,uBAAuBtB,aAAa,iBAE1DmJ,EACuC,QAAnCC,EAAInC,EAAWoC,KAAKb,KAAqB,CAC/C,IAoCQc,EApCJC,EAAUH,EAAE,GACdI,EAAMzJ,KAAKuB,cACT,kBAAoBiI,EAAU,qBAAuBA,EAAU,KAEnE,IAAIC,EAoDG,CACL7G,QAAQC,IACN,mBACE2G,EACA,iDAGJ,OAzDEC,EAAInJ,aAAa,SACY,aAA7BmJ,EAAIxJ,aAAa,SACfwJ,EAAInJ,aAAa,QAAWmJ,EAAInJ,aAAa,SAC/CmJ,EAAInJ,aAAa,SAChB,CAAC,IAAK,KAAKH,SAASsJ,EAAIxJ,aAAa,QAAQ8I,iBAG5C3B,GACAqB,EAAStI,aAAaiH,EAAUnH,aAAa,aAE7CmH,EAAUhH,aAAa,QAASkH,EAAeC,MAE7CmC,EAAOD,EAAIxJ,aAAa,QAC1B0J,EAAalJ,EAAEmJ,kBACbtC,EAAezD,OACfyD,EAAeC,KACfX,EACAnG,EAAEqH,SAAS4B,IAEfD,EAAIrJ,aAAa,MAAOuJ,EAAWE,IAAIpJ,EAAEqJ,SAASJ,KAClDD,EAAIrJ,aAAa,MAAOuJ,EAAWI,IAAItJ,EAAEqJ,SAASJ,MAGpDT,EAAOe,KAAKP,GACZpC,EACEA,GACCoC,EAAInJ,aAAa,SAC2B,SAA3CmJ,EAAIxJ,aAAa,QAAQ8I,cACK,eAA9BU,EAAIQ,QAAQlB,iBAEVQ,EAAMW,SAASC,cAAc,QAC7BC,mBAAmB,aAAcX,EAAIY,WAEzCZ,EAAIa,WAAaf,EAAIhI,cAAc,cACnCkI,EAAIa,WArJZ,SAAoBC,GAClB,IAAIC,EAASN,SAASC,cAAc,UAChCM,EAAmBF,EAAQG,oBAE/B,IAAK5I,IAAI4E,EAAI,EAAGA,EAAI+D,EAAiBlF,OAAQmB,IAC3C8D,EAAOpK,aACLqK,EAAiB/D,GACjB6D,EAAQtK,aAAawK,EAAiB/D,KAI1C,IAAIhG,EAAU6J,EAAQI,SAEtB,IAAK7I,IAAI4E,EAAI,EAAGA,EAAIhG,EAAQ6E,OAAQmB,IAAK,CACvC,IAAIkE,EAASV,SAASC,cAAc,UAChCU,EAAkBnK,EAAQgG,GAAGgE,oBAEjC,IAAK5I,IAAI2D,EAAI,EAAGA,EAAIoF,EAAgBtF,OAAQE,IAC1CmF,EAAOxK,aACLyK,EAAgBpF,GAChB/E,EAAQgG,GAAGzG,aAAa4K,EAAgBpF,KAI5CmF,EAAOpJ,UAAYd,EAAQgG,GAAGlF,UAC9BgJ,EAAOM,YAAYF,GAErB,OAAOJ,EA0HgBO,CAAWtB,EAAIa,YAGhCnC,EAAE6C,SAASC,GAAGxB,EAAIa,WAAY,SAAUtK,KAAKkL,OAAQlL,MAEhDA,KAAKmL,cACRnL,KAAKmL,YAAc,IAErBnL,KAAKmL,YAAYnB,KAAKP,EAAIa,aAkBhC,GACG7B,GAAYG,EAAOrD,SAAW0D,EAAO1D,QACtCkD,IAAahI,EAAEiI,cACf,CACa,UAATI,IACF9I,KAAK2D,OAAOyH,WAAY,IAErB/D,GAAgBD,GACnB6B,EAAOe,KAAK5C,GAEdtF,IAAIuJ,EAAOjE,EAAYA,EAAUnH,aAAa,QAAU,EACnDoL,GAAiB,MAATA,IAAgBC,MAAMD,KAAOA,EAAO,GAEjDrE,EAAagD,KAAK,CAChBvB,SAAU8C,UAAU,IAAIC,IAAI/C,EAAU3B,IACtC2E,OAAQjD,EACRG,MAAOA,EACPjD,IAAKoD,EACL4C,KAAM1C,EACN2C,OAAQ1C,EACRE,WAAYA,EACZyC,mBAAoB,CAAE/H,OAAQyD,EAAezD,QAC7CkD,gBAAiBA,EACjBH,WAAY5G,KAAKD,OAASU,EAAEoL,oBAC5B3C,IAAKA,EACLmC,KAAMA,KAIZ,OAAOrE,EAETkE,SACElL,KAAK4B,gBAAgBsJ,SAGvBzJ,gBAEMzB,KAAKK,SAAWL,KAAKgC,YAAY3B,UAAYL,KAAK6F,UACpD7F,KAAK4B,gBAAgBkK,MAAM9L,KAAK2D,OAAOC,MACvC5D,KAAK4B,gBAAgBmK,UACnB5J,MAAMC,KAAKpC,KAAKgC,YAAYM,iBAAiB,eAAeC,QAC1DvC,QAIJA,KAAK4D,KAAKoI,YAAYhM,KAAK4B,iBAK/Bc,uCACEZ,IAAImK,EAAkBjM,KAAKgC,YAAYC,wBACnCiK,EAAelM,KAAKgC,YAAYuB,YAAcvD,KAAKgC,YAEgB,IAArEkK,EAAa5J,iBAAiB,4BAA4BiD,OAE1D0G,EAAgB7L,aAAa,SAAU,IAEvC6L,EAAgB1L,gBAAgB,UAGpC4L,uBAKInM,KAAKM,aAAa,gBAClBN,KAAKgC,YAAY1B,aAAa,iBAC7BN,KAAK4B,kBAGR5B,KAAK0C,uCAEL1C,KAAKsB,kBAAkBkB,SACvBxC,KAAK4D,KAAKoI,YAAYhM,KAAK4B,iBAC3B5B,KAAKgC,YAAYoK,oBAAoB,aAAcpM,KAAKmE,uBACjDnE,KAAK4B,uBACL5B,KAAKgC,YAAY6B,QAE1BnC,mBACEI,IAAI+B,EAAS,KACXwI,EAAU,EACVC,EAAU,EACVC,EAAgB,EAChBC,EAAgB,EAElB,IAAK1K,IAAI2D,EAAI,EAAGA,EAAIzF,KAAK8D,cAAcyB,OAAQE,IAAK,CAClD3D,IAAI2K,EAAYhM,EAAEiM,oBAAoB1M,KAAK8D,cAAc2B,IACzDzF,KAAK8D,cAAc2B,GAAGkH,iBAAmBF,EAAU5I,OACnD7D,KAAK8D,cAAc2B,GAAGmH,iBAAmBH,EAAUtD,WAsBjDqD,EArBG3I,GAOHA,EAAOgJ,OAAO7M,KAAK8D,cAAc2B,GAAGkH,iBAAiB9C,KACrDhG,EAAOgJ,OAAO7M,KAAK8D,cAAc2B,GAAGkH,iBAAiB5C,KACrDsC,EAAUS,KAAK/C,IACbsC,EACArM,KAAK8D,cAAc2B,GAAGmH,iBAAiBG,SAEzCT,EAAUQ,KAAKjD,IACbyC,EACAtM,KAAK8D,cAAc2B,GAAGmH,iBAAiBI,SAEzCT,EAAgBO,KAAK/C,IACnBwC,EACAvM,KAAK8D,cAAc2B,GAAGmH,iBAAiBL,eAEzBO,KAAKjD,IACnB2C,EACAxM,KAAK8D,cAAc2B,GAAGmH,iBAAiBJ,iBAtBzC3I,EAAS7D,KAAK8D,cAAc2B,GAAGkH,iBAC/BN,EAAUrM,KAAK8D,cAAc2B,GAAGmH,iBAAiBG,QACjDT,EAAUtM,KAAK8D,cAAc2B,GAAGmH,iBAAiBI,QACjDT,EAAgBvM,KAAK8D,cAAc2B,GAAGmH,iBAAiBL,cACvCvM,KAAK8D,cAAc2B,GAAGmH,iBAAiBJ,eAuB3DxM,KAAK4B,gBAAgBiC,OAASA,EAC9B7D,KAAK4B,gBAAgBuH,WAAa,CAChC6D,QAASV,EACTS,QAASV,EACTE,cAAAA,EACAC,cAAAA,GAIJpL,YACE,OAAO,IAAI6L,QAAQ,CAACC,EAASC,KAC3BrL,IAAIsL,EAAUC,EACVrN,KAAK4B,gBACPsL,KAGAE,EAAWE,YAGb,SAAuBC,GACjBA,EAAc3L,iBAChB4L,cAAcJ,GACdK,aAAaJ,GACbH,KACUK,EAAc7J,cACxB8J,cAAcJ,GACdK,aAAaJ,GACbF,EAAO,2DAX6B,IADlBnN,MAEpBqN,EAAeK,WAajB,WACEF,cAAcJ,GACdK,aAAaJ,GACbF,EAAO,mDAhBqC,gBA5kBvCvN"}