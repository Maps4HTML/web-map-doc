{"version":3,"file":"map-extent.js","sources":["../src/map-extent.js"],"sourcesContent":["/* global M */\nexport class MapExtent extends HTMLElement {\n  static get observedAttributes() {\n    return ['checked', 'label', 'opacity', 'hidden'];\n  }\n  /* jshint ignore:start */\n  #hasConnected;\n  /* jshint ignore:end */\n  get units() {\n    return this.getAttribute('units') || M.FALLBACK_PROJECTION;\n  }\n\n  get checked() {\n    return this.hasAttribute('checked');\n  }\n\n  set checked(val) {\n    if (val) {\n      this.setAttribute('checked', '');\n    } else {\n      this.removeAttribute('checked');\n    }\n  }\n  get label() {\n    return this.hasAttribute('label')\n      ? this.getAttribute('label')\n      : M.options.locale.dfExtent;\n  }\n  set label(val) {\n    if (val) {\n      this.setAttribute('label', val);\n    }\n  }\n  get opacity() {\n    // use ?? since 0 is falsy, || would return rhs in that case\n    return +(this._opacity ?? this.getAttribute('opacity'));\n  }\n\n  set opacity(val) {\n    if (+val > 1 || +val < 0) return;\n    this.setAttribute('opacity', val);\n  }\n  get hidden() {\n    return this.hasAttribute('hidden');\n  }\n\n  set hidden(val) {\n    if (val) {\n      this.setAttribute('hidden', '');\n    } else {\n      this.removeAttribute('hidden');\n    }\n  }\n  get extent() {\n    const getExtent = (extent) => {\n      return Object.assign(\n        M._convertAndFormatPCRS(\n          extent._extentLayer.bounds,\n          M[extent.units],\n          extent.units\n        ),\n        { zoom: extent._extentLayer.zoomBounds }\n      );\n    };\n    const getCalculatedExtent = (extent) => {\n      extent._calculateBounds();\n      return getExtent(extent);\n    };\n\n    return this._extentLayer.bounds\n      ? getExtent(this)\n      : getCalculatedExtent(this);\n  }\n\n  getOuterHTML() {\n    let tempElement = this.cloneNode(true);\n\n    if (this.querySelector('map-link')) {\n      let mapLinks = tempElement.querySelectorAll('map-link');\n\n      mapLinks.forEach((mapLink) => {\n        if (mapLink.hasAttribute('href')) {\n          mapLink.setAttribute(\n            'href',\n            decodeURI(\n              new URL(\n                mapLink.attributes.href.value,\n                this.baseURI ? this.baseURI : document.baseURI\n              ).href\n            )\n          );\n        } else if (mapLink.hasAttribute('tref')) {\n          mapLink.setAttribute(\n            'tref',\n            decodeURI(\n              new URL(\n                mapLink.attributes.tref.value,\n                this.baseURI ? this.baseURI : document.baseURI\n              ).href\n            )\n          );\n        }\n      });\n    }\n\n    let outerLayer = tempElement.outerHTML;\n\n    tempElement.remove();\n\n    return outerLayer;\n  }\n\n  zoomTo() {\n    let extent = this.extent;\n    let map = this.getMapEl()._map,\n      xmin = extent.topLeft.pcrs.horizontal,\n      xmax = extent.bottomRight.pcrs.horizontal,\n      ymin = extent.bottomRight.pcrs.vertical,\n      ymax = extent.topLeft.pcrs.vertical,\n      bounds = L.bounds(L.point(xmin, ymin), L.point(xmax, ymax)),\n      center = map.options.crs.unproject(bounds.getCenter(true)),\n      maxZoom = extent.zoom.maxZoom,\n      minZoom = extent.zoom.minZoom;\n    map.setView(center, M.getMaxZoom(bounds, map, minZoom, maxZoom), {\n      animate: false\n    });\n  }\n\n  getMapEl() {\n    return M.getClosest(this, 'mapml-viewer,map[is=web-map]');\n  }\n  getLayerEl() {\n    return M.getClosest(this, 'layer-');\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (this.#hasConnected /* jshint ignore:line */) {\n      switch (name) {\n        case 'units':\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n        case 'label':\n          if (oldValue !== newValue) {\n            this._layerControlHTML.querySelector(\n              '.mapml-extent-item-name'\n            ).innerHTML = newValue || M.options.locale.dfExtent;\n          }\n          break;\n        case 'checked':\n          this.parentLayer\n            .whenReady()\n            .then(() => {\n              this._handleChange();\n              this._calculateBounds();\n              this._layerControlCheckbox.checked = newValue !== null;\n            })\n            .catch((error) => {\n              console.log(\n                'Error while waiting on parentLayer for map-extent checked callback: ' +\n                  error\n              );\n            });\n          break;\n        case 'opacity':\n          if (oldValue !== newValue) {\n            this._opacity = newValue;\n            if (this._extentLayer) this._extentLayer.changeOpacity(newValue);\n          }\n          break;\n        case 'hidden':\n          if (oldValue !== newValue) {\n            this.parentLayer\n              .whenReady()\n              .then(() => {\n                let extentsRootFieldset =\n                  this.parentLayer._propertiesGroupAnatomy;\n                let position = Array.from(\n                  this.parentLayer.src\n                    ? this.parentLayer.shadowRoot.querySelectorAll(\n                        ':host > map-extent:not([hidden])'\n                      )\n                    : this.parentLayer.querySelectorAll(\n                        ':scope > map-extent:not([hidden])'\n                      )\n                ).indexOf(this);\n                if (newValue !== null) {\n                  // remove from layer control (hide from user)\n                  this._layerControlHTML.remove();\n                } else {\n                  // insert the extent fieldset into the layer control container in\n                  // the calculated position\n                  if (position === 0) {\n                    extentsRootFieldset.insertAdjacentElement(\n                      'afterbegin',\n                      this._layerControlHTML\n                    );\n                  } else if (position > 0) {\n                    Array.from(\n                      this.parentLayer.src\n                        ? this.parentLayer.shadowRoot.querySelectorAll(\n                            ':host > map-extent:not([hidden])'\n                          )\n                        : this.parentLayer.querySelectorAll(\n                            ':scope > map-extent:not([hidden])'\n                          )\n                    )[position - 1]._layerControlHTML.insertAdjacentElement(\n                      'afterend',\n                      this._layerControlHTML\n                    );\n                  }\n                }\n                this._validateLayerControlContainerHidden();\n              })\n              .catch(() => {\n                console.log(\n                  'Error while waiting on parentLayer for map-extent hidden callback'\n                );\n              });\n          }\n          break;\n      }\n    }\n  }\n  constructor() {\n    // Always call super first in constructor\n    super();\n    this._createLayerControlExtentHTML =\n      M._createLayerControlExtentHTML.bind(this);\n    this._changeHandler = this._handleChange.bind(this);\n  }\n  async connectedCallback() {\n    // this.parentNode.host returns the layer- element when parentNode is\n    // the shadow root\n    this.parentLayer = this.getLayerEl();\n    if (\n      this.hasAttribute('data-moving') ||\n      this.parentLayer.hasAttribute('data-moving')\n    )\n      return;\n    this.mapEl = this.getMapEl();\n    await this.mapEl.whenProjectionDefined(this.units).catch(() => {\n      throw new Error('Undefined projection:' + this.units);\n    });\n    // when projection is changed, the parent layer-._layer is created (so whenReady is fulfilled) but then removed,\n    // then the map-extent disconnectedCallback will be triggered by layer-._onRemove() (clear the shadowRoot)\n    // even before connectedCallback is finished\n    // in this case, the microtasks triggered by the fulfillment of the removed MapMLLayer should be stopped as well\n    // !this.isConnected <=> the disconnectedCallback has run before\n    if (!this.isConnected) return;\n    /* jshint ignore:start */\n    this.#hasConnected = true;\n    /* jshint ignore:end */\n    this._map = this.mapEl._map;\n    this.parentLayer.addEventListener('map-change', this._changeHandler);\n    this.mapEl.addEventListener('map-projectionchange', this._changeHandler);\n    // this._opacity is used to record the current opacity value (with or without updates),\n    // the initial value of this._opacity should be set as opacity attribute value, if exists, or the default value 1.0\n    this._opacity = this.opacity || 1.0;\n    this._extentLayer = M.extentLayer({\n      opacity: this.opacity,\n      crs: M[this.units],\n      extentZIndex: Array.from(\n        this.parentLayer.src\n          ? this.parentLayer.shadowRoot.querySelectorAll(':host > map-extent')\n          : this.parentLayer.querySelectorAll(':scope > map-extent')\n      ).indexOf(this),\n      extentEl: this\n    });\n    // this._layerControlHTML is the fieldset for the extent in the LayerControl\n    this._layerControlHTML = this._createLayerControlExtentHTML();\n    this._calculateBounds();\n    // instead of children using parents' whenReady which can be cyclic,\n    // when this element is ready, run stuff that is only available after\n    // initialization\n    this._runMutationObserver(this.children);\n    // make sure same thing happens when children are added\n    this._bindMutationObserver();\n  }\n  /*\n   * Set up a function to watch additions of child elements of map-extent\n   * and to invoke desired side  effects of those additions via\n   * _runMutationObserver\n   */\n  _bindMutationObserver() {\n    this._observer = new MutationObserver((mutationList) => {\n      for (let mutation of mutationList) {\n        // the attributes changes should be handled by attributeChangedCallback()\n        if (mutation.type === 'childList') {\n          this._runMutationObserver(mutation.addedNodes);\n        }\n      }\n    });\n    // childList observes immediate children only (not grandchildren etc)\n    this._observer.observe(this, {\n      childList: true\n    });\n  }\n  _runMutationObserver(elementsGroup) {\n    const _addMetaElement = (mapMeta) => {\n      this.whenReady().then(() => {\n        this._calculateBounds();\n        this._validateDisabled();\n      });\n    };\n    const _addStylesheetLink = (mapLink) => {\n      this.whenReady().then(() => {\n        this._extentLayer.appendStyleLink(mapLink);\n      });\n    };\n    const _addStyleElement = (mapStyle) => {\n      this.whenReady().then(() => {\n        this._extentLayer.appendStyleElement(mapStyle);\n      });\n    };\n    for (let i = 0; i < elementsGroup.length; ++i) {\n      let element = elementsGroup[i];\n      switch (element.nodeName) {\n        case 'MAP-META':\n          const name =\n            element.hasAttribute('name') &&\n            (element.getAttribute('name').toLowerCase() === 'zoom' ||\n              element.getAttribute('name').toLowerCase() === 'extent');\n          if (name && element.hasAttribute('content')) {\n            _addMetaElement(element);\n          }\n          break;\n        case 'MAP-LINK':\n          if (element.link && !element.link.isConnected)\n            _addStylesheetLink(element);\n          break;\n        case 'MAP-STYLE':\n          if (element.styleElement && !element.styleElement.isConnected) {\n            _addStyleElement(element);\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  getLayerControlHTML() {\n    return this._layerControlHTML;\n  }\n  _projectionMatch() {\n    return (\n      this.units.toUpperCase() === this._map.options.projection.toUpperCase()\n    );\n  }\n  _validateDisabled() {\n    if (!this._extentLayer) return;\n    let templates = this.querySelectorAll(\n      'map-link[rel=image],map-link[rel=tile],map-link[rel=features],map-link[rel=query]'\n    );\n    const noTemplateVisible = () => {\n      let totalTemplateCount = templates.length,\n        disabledTemplateCount = 0;\n      for (let j = 0; j < totalTemplateCount; j++) {\n        if (!templates[j]._validateDisabled()) {\n          disabledTemplateCount++;\n        }\n      }\n      return disabledTemplateCount === totalTemplateCount;\n    };\n    if (!this._projectionMatch() || noTemplateVisible()) {\n      this.setAttribute('disabled', '');\n      this.disabled = true;\n    } else {\n      this.removeAttribute('disabled');\n      this.disabled = false;\n    }\n    this.toggleLayerControlDisabled();\n    this._handleChange();\n    return this.disabled;\n  }\n  getMeta(metaName) {\n    let name = metaName.toLowerCase();\n    if (name !== 'extent' && name !== 'zoom') return;\n    return this.parentLayer.src\n      ? this.querySelector(`:scope > map-meta[name=${name}]`) ||\n          this.parentLayer.shadowRoot.querySelector(\n            `:host > map-meta[name=${name}]`\n          )\n      : this.querySelector(`:scope > map-meta[name=${name}]`) ||\n          this.parentLayer.querySelector(`:scope > map-meta[name=${name}]`);\n  }\n  // disable/italicize layer control elements based on the map-extent.disabled property\n  toggleLayerControlDisabled() {\n    let input = this._layerControlCheckbox,\n      label = this._layerControlLabel, // access to the label for the specific map-extent\n      opacityControl = this._opacityControl,\n      opacitySlider = this._opacitySlider,\n      selectDetails = this._selectdetails;\n    if (this.disabled) {\n      // update the status of layerControl\n      input.disabled = true;\n      opacitySlider.disabled = true;\n      label.style.fontStyle = 'italic';\n      opacityControl.style.fontStyle = 'italic';\n      if (selectDetails) {\n        selectDetails.forEach((i) => {\n          i.querySelectorAll('select').forEach((j) => {\n            j.disabled = true;\n            j.style.fontStyle = 'italic';\n          });\n          i.style.fontStyle = 'italic';\n        });\n      }\n    } else {\n      input.disabled = false;\n      opacitySlider.disabled = false;\n      label.style.fontStyle = 'normal';\n      opacityControl.style.fontStyle = 'normal';\n      if (selectDetails) {\n        selectDetails.forEach((i) => {\n          i.querySelectorAll('select').forEach((j) => {\n            j.disabled = false;\n            j.style.fontStyle = 'normal';\n          });\n          i.style.fontStyle = 'normal';\n        });\n      }\n    }\n  }\n\n  _handleChange() {\n    // add _extentLayer to map if map-extent is checked, otherwise remove it\n    if (this.checked && !this.disabled) {\n      // can be added to mapmllayer layerGroup no matter layer- is checked or not\n      this._extentLayer.addTo(this.parentLayer._layer);\n      this._extentLayer.setZIndex(\n        Array.from(\n          this.parentLayer.src\n            ? this.parentLayer.shadowRoot.querySelectorAll(':host > map-extent')\n            : this.parentLayer.querySelectorAll(':scope > map-extent')\n        ).indexOf(this)\n      );\n    } else {\n      this.parentLayer._layer?.removeLayer(this._extentLayer);\n    }\n    // change the checkbox in the layer control to match map-extent.checked\n    // doesn't trigger the event handler because it's not user-caused AFAICT\n  }\n  _validateLayerControlContainerHidden() {\n    let extentsFieldset = this.parentLayer._propertiesGroupAnatomy;\n    if (!extentsFieldset) return;\n    const numberOfVisibleSublayers = (\n      this.parentLayer.src\n        ? this.parentLayer.shadowRoot.querySelectorAll(\n            ':host > map-extent:not([hidden])'\n          )\n        : this.parentLayer.querySelectorAll(':scope > map-extent:not([hidden])')\n    ).length;\n    if (numberOfVisibleSublayers === 0) {\n      extentsFieldset.setAttribute('hidden', '');\n    } else {\n      extentsFieldset.removeAttribute('hidden');\n    }\n  }\n  disconnectedCallback() {\n    // in case of projection change, the disconnectedcallback will be triggered by removing layer-._layer even before\n    // map-extent.connectedcallback is finished (because it will wait for the layer- to be ready)\n    // !this._extentLayer <=> this.connectedCallback has not yet been finished before disconnectedCallback is triggered\n    if (\n      this.hasAttribute('data-moving') ||\n      this.parentLayer.hasAttribute('data-moving') ||\n      !this._extentLayer\n    )\n      return;\n    this._validateLayerControlContainerHidden();\n    // remove layer control for map-extent from layer control DOM\n    // TODO: for the case of projection change, the layer control for map-extent has been created while _extentLayer has not yet been ready\n    this._layerControlHTML.remove();\n    if (this.parentLayer._layer) {\n      this.parentLayer._layer.removeLayer(this._extentLayer);\n    }\n    this.parentLayer.removeEventListener('map-change', this._changeHandler);\n    this.mapEl.removeEventListener('map-projectionchange', this._changeHandler);\n    delete this._extentLayer;\n    if (this.parentLayer._layer) delete this.parentLayer._layer.bounds;\n  }\n  _calculateBounds() {\n    delete this._extentLayer.bounds;\n    delete this._extentLayer.zoomBounds;\n    if (this.parentLayer._layer) delete this.parentLayer._layer.bounds;\n    let zoomMax = -Infinity,\n      zoomMin = Infinity,\n      maxNativeZoom = -Infinity,\n      minNativeZoom = Infinity,\n      templates = this.querySelectorAll(\n        'map-link[rel=image],map-link[rel=tile],map-link[rel=features],map-link[rel=query]'\n      );\n\n    // initialize bounds from this.scope > map-meta\n    let bounds = this.querySelector(':scope > map-meta[name=extent][content]')\n      ? M.getBoundsFromMeta(this) // TODO rewrite this pile of doo doo\n      : undefined;\n\n    // initialize zoom bounds from this.scope > map-meta\n    let zoomBounds = this.querySelector(':scope > map-meta[name=zoom][content]')\n      ? M.getZoomBoundsFromMeta(this) // TODO rewrite this pile of doo doo\n      : undefined;\n\n    // bounds should be able to be calculated unconditionally, not depend on map-extent.checked\n    for (let j = 0; j < templates.length; j++) {\n      const templateZoomBounds = templates[j].getZoomBounds(),\n        templateBounds = templates[j].getBounds();\n      let zoomMax =\n          zoomBounds && zoomBounds.hasOwnProperty('maxZoom')\n            ? zoomBounds.maxZoom\n            : -Infinity,\n        zoomMin =\n          zoomBounds && zoomBounds.hasOwnProperty('minZoom')\n            ? zoomBounds.minZoom\n            : Infinity,\n        minNativeZoom =\n          zoomBounds && zoomBounds.hasOwnProperty('minNativeZoom')\n            ? zoomBounds.minNativeZoom\n            : Infinity,\n        maxNativeZoom =\n          zoomBounds && zoomBounds.hasOwnProperty('maxNativeZoom')\n            ? zoomBounds.maxNativeZoom\n            : -Infinity;\n      if (!zoomBounds) {\n        zoomBounds = Object.assign({}, templateZoomBounds);\n      } else {\n        zoomMax = Math.max(zoomMax, templateZoomBounds.maxZoom);\n        zoomMin = Math.min(zoomMin, templateZoomBounds.minZoom);\n        maxNativeZoom = Math.max(\n          maxNativeZoom,\n          templateZoomBounds.maxNativeZoom\n        );\n        minNativeZoom = Math.min(\n          minNativeZoom,\n          templateZoomBounds.minNativeZoom\n        );\n        zoomBounds.minZoom = zoomMin;\n        zoomBounds.maxZoom = zoomMax;\n        zoomBounds.minNativeZoom = minNativeZoom;\n        zoomBounds.maxNativeZoom = maxNativeZoom;\n      }\n      if (!bounds) {\n        bounds = L.bounds(templateBounds.min, templateBounds.max);\n      } else {\n        bounds.extend(templateBounds);\n      }\n    }\n    if (bounds) {\n      this._extentLayer.bounds = bounds;\n    } else {\n      this._extentLayer.bounds = L.bounds(\n        M[this.units].options.bounds.min,\n        M[this.units].options.bounds.max\n      );\n    }\n    if (!zoomBounds) zoomBounds = {};\n    if (!zoomBounds.hasOwnProperty('minZoom')) {\n      zoomBounds.minZoom = 0;\n    }\n    if (!zoomBounds.hasOwnProperty('maxZoom')) {\n      zoomBounds.maxZoom = M[this.units].options.resolutions.length - 1;\n    }\n    if (\n      !zoomBounds.hasOwnProperty('minNativeZoom') ||\n      zoomBounds.minNativeZoom === Infinity\n    ) {\n      zoomBounds.minNativeZoom = zoomBounds.minZoom;\n    }\n    if (\n      !zoomBounds.hasOwnProperty('maxNativeZoom') ||\n      zoomBounds.maxNativeZoom === -Infinity\n    ) {\n      zoomBounds.maxNativeZoom = zoomBounds.maxZoom;\n    }\n    this._extentLayer.zoomBounds = zoomBounds;\n  }\n\n  whenReady() {\n    return new Promise((resolve, reject) => {\n      let interval, failureTimer;\n      if (this._extentLayer) {\n        resolve();\n      } else {\n        let extentElement = this;\n        interval = setInterval(testForExtent, 300, extentElement);\n        failureTimer = setTimeout(extentNotDefined, 10000);\n      }\n      function testForExtent(extentElement) {\n        if (extentElement._extentLayer) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          resolve();\n        } else if (!extentElement.isConnected) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          reject('map-extent was disconnected while waiting to be ready');\n        }\n      }\n      function extentNotDefined() {\n        clearInterval(interval);\n        clearTimeout(failureTimer);\n        reject('Timeout reached waiting for extent to be ready');\n      }\n    });\n  }\n\n  whenLinksReady() {\n    let templates = this.querySelectorAll(\n      'map-link[rel=image],map-link[rel=tile],map-link[rel=features],map-link[rel=query]'\n    );\n    let linksReady = [];\n    for (let link of [...templates]) {\n      linksReady.push(link.whenReady());\n    }\n    return Promise.allSettled(linksReady);\n  }\n}\n"],"names":["MapExtent","HTMLElement","observedAttributes","#hasConnected","units","this","getAttribute","M","FALLBACK_PROJECTION","checked","hasAttribute","val","setAttribute","removeAttribute","label","options","locale","dfExtent","opacity","_opacity","hidden","extent","getExtent","Object","assign","_convertAndFormatPCRS","_extentLayer","bounds","zoom","zoomBounds","_calculateBounds","getOuterHTML","let","tempElement","cloneNode","querySelector","mapLinks","querySelectorAll","forEach","mapLink","decodeURI","URL","attributes","href","value","baseURI","document","tref","outerLayer","outerHTML","remove","zoomTo","map","getMapEl","_map","xmin","topLeft","pcrs","horizontal","xmax","bottomRight","ymin","vertical","ymax","L","point","center","crs","unproject","getCenter","maxZoom","minZoom","setView","getMaxZoom","animate","getClosest","getLayerEl","attributeChangedCallback","name","oldValue","newValue","_layerControlHTML","innerHTML","parentLayer","whenReady","then","_handleChange","_layerControlCheckbox","catch","console","log","error","changeOpacity","extentsRootFieldset","_propertiesGroupAnatomy","position","Array","from","src","shadowRoot","indexOf","insertAdjacentElement","_validateLayerControlContainerHidden","constructor","super","_createLayerControlExtentHTML","bind","_changeHandler","connectedCallback","mapEl","whenProjectionDefined","Error","isConnected","addEventListener","extentLayer","extentZIndex","extentEl","_runMutationObserver","children","_bindMutationObserver","_observer","MutationObserver","mutation","mutationList","type","addedNodes","observe","childList","elementsGroup","_addMetaElement","_validateDisabled","_addStylesheetLink","appendStyleLink","_addStyleElement","appendStyleElement","mapStyle","i","length","element","nodeName","toLowerCase","link","styleElement","getLayerControlHTML","_projectionMatch","toUpperCase","projection","templates","totalTemplateCount","disabledTemplateCount","j","noTemplateVisible","disabled","toggleLayerControlDisabled","getMeta","metaName","input","_layerControlLabel","opacityControl","_opacityControl","opacitySlider","_opacitySlider","selectDetails","_selectdetails","style","fontStyle","addTo","_layer","setZIndex","removeLayer","extentsFieldset","disconnectedCallback","removeEventListener","getBoundsFromMeta","undefined","getZoomBoundsFromMeta","templateZoomBounds","getZoomBounds","templateBounds","getBounds","zoomMax","hasOwnProperty","Infinity","zoomMin","minNativeZoom","maxNativeZoom","Math","max","min","extend","resolutions","Promise","resolve","reject","interval","failureTimer","setInterval","extentElement","clearInterval","clearTimeout","setTimeout","whenLinksReady","linksReady","push","allSettled"],"mappings":"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"}