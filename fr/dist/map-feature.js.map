{"version":3,"file":"map-feature.js","sources":["../src/map-feature.js"],"sourcesContent":["export class MapFeature extends HTMLElement {\n  static get observedAttributes() {\n    return ['zoom', 'min', 'max'];\n  }\n\n  /* jshint ignore:start */\n  #hasConnected;\n  /* jshint ignore:end */\n  get zoom() {\n    // for templated or queried features ** native zoom is only used for zoomTo() **\n    let meta = {},\n      metaEl = this.getMeta('zoom');\n    if (metaEl) meta = M._metaContentToObject(metaEl.getAttribute('content'));\n    if (this._parentEl.nodeName === 'MAP-LINK') {\n      // nativeZoom = zoom attribute || (sd.map-meta zoom 'value'  || 'max') || this._initialZoom\n      return +(this.hasAttribute('zoom')\n        ? this.getAttribute('zoom')\n        : meta.value\n        ? meta.value\n        : meta.max\n        ? meta.max\n        : this._initialZoom);\n    } else {\n      // for \"static\" features\n      // nativeZoom zoom attribute || this._initialZoom\n      // NOTE we don't use map-meta here, because the map-meta is the minimum\n      // zoom bounds for the layer, and is extended by additional features\n      // if added / removed during layer lifetime\n      return +(this.hasAttribute('zoom')\n        ? this.getAttribute('zoom')\n        : this._initialZoom);\n    }\n  }\n\n  set zoom(val) {\n    var parsedVal = parseInt(val, 10);\n    if (!isNaN(parsedVal) && parsedVal >= this.min && parsedVal <= this.max) {\n      this.setAttribute('zoom', parsedVal);\n    }\n  }\n\n  get min() {\n    // for templated or queried features ** native zoom is only used for zoomTo() **\n    let meta = {},\n      metaEl = this.getMeta('zoom');\n    if (metaEl) meta = M._metaContentToObject(metaEl.getAttribute('content'));\n    let projectionMinZoom = 0;\n    if (this._parentEl.nodeName === 'MAP-LINK') {\n      // minZoom = min attribute || sd.map-meta min zoom || map-link minZoom\n      return +(this.hasAttribute('min')\n        ? this.getAttribute('min')\n        : meta.min\n        ? meta.min\n        : this._parentEl.getZoomBounds().minZoom);\n    } else {\n      // for \"static\" features\n      // minZoom = min attribute || map-meta zoom || projection minZoom\n      return +(this.hasAttribute('min')\n        ? this.getAttribute('min')\n        : meta.min\n        ? meta.min\n        : projectionMinZoom);\n    }\n  }\n\n  set min(val) {\n    var parsedVal = parseInt(val, 10);\n    var layerZoomBounds = this.getLayerEl().extent.zoom;\n    if (!isNaN(parsedVal)) {\n      if (\n        parsedVal >= layerZoomBounds.minZoom &&\n        parsedVal <= layerZoomBounds.maxZoom\n      ) {\n        this.setAttribute('min', parsedVal);\n      } else {\n        this.setAttribute('min', layerZoomBounds.minZoom);\n      }\n    }\n  }\n\n  get max() {\n    // for templated or queried features ** native zoom is only used for zoomTo() **\n    let meta = {},\n      metaEl = this.getMeta('zoom');\n    if (metaEl) meta = M._metaContentToObject(metaEl.getAttribute('content'));\n    let projectionMaxZoom =\n      this.getMapEl()._map.options.crs.options.resolutions.length - 1;\n    if (this._parentEl.nodeName === 'MAP-LINK') {\n      // maxZoom = max attribute || sd.map-meta max zoom || map-link maxZoom\n      return +(this.hasAttribute('max')\n        ? this.getAttribute('max')\n        : meta.max\n        ? meta.max\n        : this._parentEl.getZoomBounds().maxZoom);\n    } else {\n      // for \"static\" features\n      // maxZoom = max attribute || map-meta zoom max || projection maxZoom\n      return +(this.hasAttribute('max')\n        ? this.getAttribute('max')\n        : meta.max\n        ? meta.max\n        : projectionMaxZoom);\n    }\n  }\n\n  set max(val) {\n    var parsedVal = parseInt(val, 10);\n    var layerZoomBounds = this.getLayerEl().extent.zoom;\n    if (!isNaN(parsedVal)) {\n      if (\n        parsedVal >= layerZoomBounds.minZoom &&\n        parsedVal <= layerZoomBounds.maxZoom\n      ) {\n        this.setAttribute('max', parsedVal);\n      } else {\n        this.setAttribute('max', layerZoomBounds.maxZoom);\n      }\n    }\n  }\n\n  get extent() {\n    if (this.isConnected) {\n      // if the feature extent is the first time to be calculated or the feature extent is changed (by changing\n      // the innertext of map-coordinates), then calculate feature extent by invoking the getFeatureExtent function\n      if (!this._getFeatureExtent) {\n        this._getFeatureExtent = this._memoizeExtent();\n      }\n      return this._getFeatureExtent();\n    }\n  }\n  getLayerEl() {\n    let layerEl;\n    if (this.getRootNode() instanceof ShadowRoot) {\n      if (this.getRootNode().host.getRootNode() instanceof ShadowRoot) {\n        //   layer- src\n        //     > sd\n        //      map-extent\n        //       map-link\n        //        > sd\n        //          map-feature (1)\n        layerEl = this.getRootNode().host.getRootNode().host;\n      } else if (this.getRootNode().host.nodeName === 'MAP-LINK') {\n        //   layer-\n        //     map-extent\n        //       map-link\n        //         > sd\n        //           map-feature (4)\n        layerEl = this.getRootNode().host.closest('layer-');\n      } else {\n        //   layer- src\n        //     > sd\n        //        map-feature (2)\n        layerEl = this.getRootNode().host;\n      }\n    } else {\n      //     layer-\n      //       map-feature (3)\n      layerEl = this.closest('layer-');\n    }\n    return layerEl;\n  }\n  getMapEl() {\n    return this.getLayerEl().closest('mapml-viewer,map[is=web-map]');\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (this.#hasConnected /* jshint ignore:line */) {\n      switch (name) {\n        case 'min':\n        case 'max':\n        case 'zoom':\n          if (oldValue !== newValue) {\n            this.reRender(this._featureLayer);\n          }\n          break;\n      }\n    }\n  }\n\n  constructor() {\n    // Always call super first in constructor\n    super();\n  }\n\n  connectedCallback() {\n    /* jshint ignore:start */\n    this.#hasConnected = true;\n    /* jshint ignore:end */\n    // set the initial zoom of the map when features connected\n    // used for fallback zoom getter for static features\n    this._initialZoom = this.getMapEl().zoom;\n    this._parentEl =\n      this.parentNode.nodeName.toUpperCase() === 'LAYER-' ||\n      this.parentNode.nodeName.toUpperCase() === 'MAP-LINK'\n        ? this.parentNode\n        : this.parentNode.host;\n    if (\n      this.getLayerEl().hasAttribute('data-moving') ||\n      this._parentEl.parentElement?.hasAttribute('data-moving')\n    )\n      return;\n    // use observer to monitor the changes in mapFeature's subtree\n    // (i.e. map-properties, map-featurecaption, map-coordinates)\n    this._observer = new MutationObserver((mutationList) => {\n      for (let mutation of mutationList) {\n        // the attributes changes of <map-feature> element should be handled by attributeChangedCallback()\n        if (mutation.type === 'attributes' && mutation.target === this) {\n          return;\n        }\n        // re-render feature if there is any observed change\n        this.reRender(this._featureLayer);\n      }\n    });\n    this._observer.observe(this, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeOldValue: true,\n      characterData: true\n    });\n  }\n\n  disconnectedCallback() {\n    if (\n      this.getLayerEl()?.hasAttribute('data-moving') ||\n      this._parentEl.parentElement?.hasAttribute('data-moving')\n    )\n      return;\n    this._observer.disconnect();\n    if (this._featureLayer) {\n      this.removeFeature(this._featureLayer);\n    }\n  }\n\n  reRender(layerToRenderOn) {\n    // this is for re-generating the rendering in case of <geometry> changes\n    // based on mutation observers. Kinda brute force.\n    if (this._groupEl.isConnected) {\n      let fallbackCS = this._getFallbackCS();\n      let placeholder = document.createElement('span');\n      this._groupEl.insertAdjacentElement('beforebegin', placeholder);\n      if (layerToRenderOn._staticFeature) {\n        layerToRenderOn._removeFromFeaturesList(this._geometry);\n      }\n      layerToRenderOn.removeLayer(this._geometry);\n      // Garbage collection needed\n      this._geometry = layerToRenderOn\n        .createGeometry(this, fallbackCS) // side effect: this._groupEl set\n        .addTo(layerToRenderOn);\n      placeholder.replaceWith(this._geometry.options.group);\n      layerToRenderOn._validateRendering();\n      // TODO: getBounds() should dynamically update the layerBounds and zoomBounds\n      delete this._getFeatureExtent;\n      this._setUpEvents();\n    }\n  }\n\n  removeFeature(layerToRemoveFrom) {\n    // layerToRemoveFrom is the L.LayerGroup or L.FeatureGroup to remove this\n    // feature from...\n    layerToRemoveFrom.removeLayer(this._geometry);\n    // TODO: MOVE THIS LOGIC TO layerToRemoveFrom.removeLayer(M.Geometry)\n    //    if (layerToRemoveFrom._staticFeature) {\n    //      if (layerToRemoveFrom._features[this.zoom]) {\n    //        this._removeInFeatureList(this.zoom);\n    //      }\n    if (layerToRemoveFrom._staticFeature) {\n      layerToRemoveFrom._removeFromFeaturesList(this._geometry);\n    }\n    layerToRemoveFrom.options.properties = null;\n    delete this._geometry;\n    // ensure that feature extent can be re-calculated everytime that map-feature element is updated / re-added\n    if (this._getFeatureExtent) delete this._getFeatureExtent;\n  }\n\n  addFeature(layerToAddTo) {\n    this._featureLayer = layerToAddTo;\n    let parentLayer = this.getLayerEl();\n    // \"synchronize\" the event handlers between map-feature and <g>\n    if (!this.querySelector('map-geometry')) return;\n    let fallbackCS = this._getFallbackCS();\n    let content = parentLayer.src ? parentLayer.shadowRoot : parentLayer;\n    this._geometry = layerToAddTo.createGeometry(this, fallbackCS); // side effect: extends `this` with this._groupEl, points to svg g element that renders to map SD\n    layerToAddTo.addLayer(this._geometry);\n    this._setUpEvents();\n  }\n\n  _setUpEvents() {\n    ['click', 'focus', 'blur', 'keyup', 'keydown'].forEach((name) => {\n      // when <g> is clicked / focused / blurred\n      // should dispatch the click / focus / blur event listener on **linked HTMLFeatureElements**\n      this._groupEl.addEventListener(name, (e) => {\n        if (name === 'click') {\n          // dispatch a cloned mouseevent to trigger the click event handlers set on HTMLFeatureElement\n          let clickEv = new PointerEvent(name, { cancelable: true });\n          clickEv.originalEvent = e;\n          this.dispatchEvent(clickEv);\n        } else if (name === 'keyup' || name === 'keydown') {\n          let keyEv = new KeyboardEvent(name, { cancelable: true });\n          keyEv.originalEvent = e;\n          this.dispatchEvent(keyEv);\n        } else {\n          // dispatch a cloned focusevent to trigger the focus/blue event handlers set on HTMLFeatureElement\n          let focusEv = new FocusEvent(name, { cancelable: true });\n          focusEv.originalEvent = e;\n          this.dispatchEvent(focusEv);\n        }\n      });\n    });\n  }\n\n  // native cs: used by FeatureLayer._geometryToLayer(...),\n  //            the fallback cs for map-geometry if its cs attribute is not specified\n  _getFallbackCS() {\n    let csMeta;\n    if (this._parentEl.nodeName === 'MAP-LINK') {\n      // feature attaches to link's shadow\n      csMeta =\n        this._parentEl.shadowRoot.querySelector('map-meta[name=cs]') ||\n        this._parentEl.parentElement.getMeta('cs');\n    } else {\n      let layerEl = this.getLayerEl();\n      csMeta = layerEl.src\n        ? layerEl.shadowRoot.querySelector('map-meta[name=cs]')\n        : layerEl.querySelector('map-meta[name=cs]');\n    }\n    if (csMeta) {\n      // M._metaContentObject(\"gcrs\") -> {content: \"gcrs\"}\n      return (\n        M._metaContentToObject(csMeta.getAttribute('content')).content || 'gcrs'\n      );\n    } else {\n      return 'gcrs';\n    }\n  }\n\n  // Util functions:\n  // internal method to calculate the extent of the feature and store it in cache for the first time\n  // and return cache when feature's extent is repeatedly requested\n  // for .extent\n  _memoizeExtent() {\n    // memoize calculated extent\n    let extentCache;\n    return function () {\n      if (extentCache && this._getFeatureExtent) {\n        // if the extent has already been calculated and is not updated, return stored extent\n        return extentCache;\n      } else {\n        // calculate feature extent\n        let map = this.getMapEl()._map,\n          geometry = this.querySelector('map-geometry'),\n          cs = geometry.getAttribute('cs') || this._getFallbackCS(),\n          // zoom level that the feature rendered at\n          zoom = this.zoom,\n          shapes = geometry.querySelectorAll(\n            'map-point, map-linestring, map-polygon, map-multipoint, map-multilinestring'\n          ),\n          bboxExtent = [\n            Infinity,\n            Infinity,\n            Number.NEGATIVE_INFINITY,\n            Number.NEGATIVE_INFINITY\n          ];\n        for (let shape of shapes) {\n          let coord = shape.querySelectorAll('map-coordinates');\n          for (let i = 0; i < coord.length; ++i) {\n            bboxExtent = _updateExtent(shape, coord[i], bboxExtent);\n          }\n        }\n        let topLeft = L.point(bboxExtent[0], bboxExtent[1]);\n        let bottomRight = L.point(bboxExtent[2], bboxExtent[3]);\n        let pcrsBound = M.boundsToPCRSBounds(\n          L.bounds(topLeft, bottomRight),\n          zoom,\n          map.options.projection,\n          cs\n        );\n        if (\n          shapes.length === 1 &&\n          shapes[0].tagName.toUpperCase() === 'MAP-POINT'\n        ) {\n          let projection = map.options.projection,\n            maxZoom = this.hasAttribute('max')\n              ? +this.getAttribute('max')\n              : M[projection].options.resolutions.length - 1,\n            tileCenter = M[projection].options.crs.tile.bounds.getCenter(),\n            pixel = M[projection].transformation.transform(\n              pcrsBound.min,\n              M[projection].scale(+this.zoom || maxZoom)\n            );\n          pcrsBound = M.pixelToPCRSBounds(\n            L.bounds(pixel.subtract(tileCenter), pixel.add(tileCenter)),\n            this.zoom || maxZoom,\n            projection\n          );\n        }\n        let result = Object.assign(\n          M._convertAndFormatPCRS(\n            pcrsBound,\n            map.options.crs,\n            map.options.projection\n          ),\n          { zoom: this._getZoomBounds() }\n        );\n        // memoize calculated result\n        extentCache = result;\n        return result;\n      }\n    };\n\n    // update the bboxExtent\n    function _updateExtent(shape, coord, bboxExtent) {\n      let data = coord.innerHTML\n        .trim()\n        .replace(/<[^>]+>/g, '')\n        .replace(/\\s+/g, ' ')\n        .split(/[<>\\ ]/g);\n      switch (shape.tagName.toUpperCase()) {\n        case 'MAP-POINT':\n          bboxExtent = M._updateExtent(bboxExtent, +data[0], +data[1]);\n          break;\n        case 'MAP-LINESTRING':\n        case 'MAP-POLYGON':\n        case 'MAP-MULTIPOINT':\n        case 'MAP-MULTILINESTRING':\n          for (let i = 0; i < data.length; i += 2) {\n            bboxExtent = M._updateExtent(bboxExtent, +data[i], +data[i + 1]);\n          }\n          break;\n        default:\n          break;\n      }\n      return bboxExtent;\n    }\n  }\n  _getZoomBounds() {\n    // ** native zoom is only used for zoomTo() **\n    return {\n      minZoom: this.min,\n      maxZoom: this.max,\n      minNativeZoom: this.zoom,\n      maxNativeZoom: this.zoom\n    };\n  }\n  getZoomToZoom() {\n    let tL = this.extent.topLeft.pcrs,\n      bR = this.extent.bottomRight.pcrs,\n      bound = L.bounds(\n        L.point(tL.horizontal, tL.vertical),\n        L.point(bR.horizontal, bR.vertical)\n      );\n    let projection = this.getMapEl()._map.options.projection,\n      layerZoomBounds = this.getLayerEl().extent.zoom,\n      minZoom = layerZoomBounds.minZoom ? layerZoomBounds.minZoom : 0,\n      maxZoom = layerZoomBounds.maxZoom\n        ? layerZoomBounds.maxZoom\n        : M[projection].options.resolutions.length - 1;\n    let newZoom;\n    if (this.hasAttribute('zoom')) {\n      // if there is a zoom attribute set to the map-feature, zoom to the zoom attribute value\n      newZoom = this.zoom;\n    } else {\n      // if not, calculate the maximum zoom level that can show the feature completely\n      newZoom = M.getMaxZoom(bound, this.getMapEl()._map, minZoom, maxZoom);\n      if (this.max < newZoom) {\n        // if the calculated zoom is greater than the value of max zoom attribute, go with max zoom attribute\n        newZoom = this.max;\n      } else if (this.min > newZoom) {\n        // if the calculated zoom is less than the value of min zoom attribute, go with min zoom attribute\n        newZoom = this.min;\n      }\n    }\n    // prevent overzooming / underzooming\n    if (newZoom < minZoom) {\n      newZoom = minZoom;\n    } else if (newZoom > maxZoom) {\n      newZoom = maxZoom;\n    }\n\n    // should check whether the extent after zooming falls into the templated extent bound\n    return newZoom;\n  }\n  getMeta(metaName) {\n    let name = metaName.toLowerCase();\n    if (name !== 'cs' && name !== 'zoom' && name !== 'projection') return;\n    let sdMeta = this._parentEl.shadowRoot.querySelector(\n      `map-meta[name=${name}][content]`\n    );\n    if (this._parentEl.nodeName === 'MAP-LINK') {\n      // sd.map-meta || map-extent meta || layer meta\n      return sdMeta || this._parentEl.parentElement.getMeta(metaName);\n    } else {\n      return this._parentEl.src\n        ? this._parentEl.shadowRoot.querySelector(\n            `map-meta[name=${name}][content]`\n          )\n        : this._parentEl.querySelector(`map-meta[name=${name}][content]`);\n    }\n  }\n  // internal support for returning a GeoJSON representation of <map-feature> geometry\n  // The options object can contain the following:\n  //      propertyFunction   - function(<map-properties>), A function that maps the features' <map-properties> element to a GeoJSON \"properties\" member.\n  //      transform          - Bool, Transform coordinates to gcrs values, defaults to True\n  // mapml2geojson: <map-feature> Object -> GeoJSON\n  mapml2geojson(options) {\n    let defaults = {\n      propertyFunction: null,\n      transform: true\n    };\n    // assign default values for undefined options\n    options = Object.assign({}, defaults, options);\n\n    let json = {\n      type: 'Feature',\n      properties: {},\n      geometry: {}\n    };\n    let el = this.querySelector('map-properties');\n    if (!el) {\n      json.properties = null;\n    } else if (typeof options.propertyFunction === 'function') {\n      json.properties = options.propertyFunction(el);\n    } else if (el.querySelector('table')) {\n      // setting properties when table presented\n      let table = el.querySelector('table').cloneNode(true);\n      json.properties = M._table2properties(table);\n    } else {\n      // when no table present, strip any possible html tags to only get text\n      json.properties = {\n        prop0: el.innerHTML.replace(/(<([^>]+)>)/gi, '').replace(/\\s/g, '')\n      };\n    }\n\n    // transform to gcrs if options.transform = true (default)\n    let source = null,\n      dest = null,\n      map = this.getMapEl()._map;\n    if (options.transform) {\n      source = new proj4.Proj(map.options.crs.code);\n      dest = new proj4.Proj('EPSG:4326');\n      if (\n        map.options.crs.code === 'EPSG:3857' ||\n        map.options.crs.code === 'EPSG:4326'\n      ) {\n        options.transform = false;\n      }\n    }\n\n    let collection = this.querySelector('map-geometry').querySelector(\n        'map-geometrycollection'\n      ),\n      shapes = this.querySelector('map-geometry').querySelectorAll(\n        'map-point, map-polygon, map-linestring, map-multipoint, map-multipolygon, map-multilinestring'\n      );\n\n    if (collection) {\n      json.geometry.type = 'GeometryCollection';\n      json.geometry.geometries = [];\n      for (let shape of shapes) {\n        json.geometry.geometries.push(\n          M._geometry2geojson(shape, source, dest, options.transform)\n        );\n      }\n    } else {\n      json.geometry = M._geometry2geojson(\n        shapes[0],\n        source,\n        dest,\n        options.transform\n      );\n    }\n    return json;\n  }\n\n  // a method that simulates a click, or invoking the user-defined click event\n  click() {\n    let g = this._groupEl,\n      rect = g.getBoundingClientRect();\n    let event = new MouseEvent('click', {\n      clientX: rect.x + rect.width / 2,\n      clientY: rect.y + rect.height / 2,\n      button: 0\n    });\n    let properties = this.querySelector('map-properties');\n    if (g.getAttribute('role') === 'link') {\n      for (let path of g.children) {\n        path.mousedown.call(this._geometry, event);\n        path.mouseup.call(this._geometry, event);\n      }\n    }\n    // dispatch click event for map-feature to allow events entered by 'addEventListener'\n    let clickEv = new PointerEvent('click', { cancelable: true });\n    clickEv.originalEvent = event;\n    this.dispatchEvent(clickEv);\n    // for custom projection, layer- element may disconnect and re-attach to the map after the click\n    // so check whether map-feature element is still connected before any further operations\n    if (properties && this.isConnected) {\n      let geometry = this._geometry,\n        shapes = geometry._layers;\n      // close popup if the popup is currently open\n      for (let id in shapes) {\n        if (shapes[id].isPopupOpen()) {\n          shapes[id].closePopup();\n        }\n      }\n      if (geometry.isPopupOpen()) {\n        geometry.closePopup();\n      } else if (!clickEv.originalEvent.cancelBubble) {\n        // If stopPropagation is not set on originalEvent by user\n        geometry.openPopup();\n      }\n    }\n  }\n\n  // a method that sets the current focus to the <g> element, or invoking the user-defined focus event\n  //      options (optional): as options parameter for native HTMLElement\n  //                          https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus\n  focus(options) {\n    this._groupEl.focus(options);\n  }\n\n  // a method that makes the <g> element lose focus, or invoking the user-defined blur event\n  blur() {\n    if (\n      document.activeElement.shadowRoot?.activeElement === this._groupEl ||\n      document.activeElement.shadowRoot?.activeElement.parentNode ===\n        this._groupEl\n    ) {\n      this._groupEl.blur();\n      // set focus to the map container\n      this.getMapEl()._map.getContainer().focus();\n    }\n  }\n\n  // a method that can the viewport to be centred on the feature's extent\n  zoomTo() {\n    let extent = this.extent,\n      map = this.getMapEl()._map;\n    let tL = extent.topLeft.pcrs,\n      bR = extent.bottomRight.pcrs,\n      bound = L.bounds(\n        L.point(tL.horizontal, tL.vertical),\n        L.point(bR.horizontal, bR.vertical)\n      ),\n      center = map.options.crs.unproject(bound.getCenter(true));\n    map.setView(center, this.getZoomToZoom(), { animate: false });\n  }\n  whenReady() {\n    return new Promise((resolve, reject) => {\n      let interval, failureTimer;\n      if (this.isConnected /* jshint ignore:line */) {\n        resolve();\n      } else {\n        let featureElement = this;\n        interval = setInterval(testForFeature, 200, featureElement);\n        failureTimer = setTimeout(featureNotDefined, 5000);\n      }\n      function testForFeature(featureElement) {\n        if (featureElement.isConnected /* jshint ignore:line */) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          resolve();\n        }\n      }\n      function featureNotDefined() {\n        clearInterval(interval);\n        clearTimeout(failureTimer);\n        reject('Timeout reached waiting for feature to be ready');\n      }\n    });\n  }\n}\n"],"names":["MapFeature","HTMLElement","observedAttributes","#hasConnected","zoom","let","meta","metaEl","this","getMeta","M","_metaContentToObject","getAttribute","_parentEl","nodeName","hasAttribute","value","max","_initialZoom","val","parsedVal","parseInt","isNaN","min","setAttribute","getZoomBounds","minZoom","layerZoomBounds","getLayerEl","extent","maxZoom","projectionMaxZoom","getMapEl","_map","options","crs","resolutions","length","isConnected","_getFeatureExtent","_memoizeExtent","layerEl","getRootNode","ShadowRoot","host","closest","attributeChangedCallback","name","oldValue","newValue","reRender","_featureLayer","constructor","super","connectedCallback","parentNode","toUpperCase","parentElement","_observer","MutationObserver","mutation","mutationList","type","target","observe","childList","subtree","attributes","attributeOldValue","characterData","disconnectedCallback","disconnect","removeFeature","layerToRenderOn","_groupEl","fallbackCS","_getFallbackCS","placeholder","document","createElement","insertAdjacentElement","_staticFeature","_removeFromFeaturesList","_geometry","removeLayer","createGeometry","addTo","replaceWith","group","_validateRendering","_setUpEvents","layerToRemoveFrom","properties","addFeature","layerToAddTo","parentLayer","querySelector","src","shadowRoot","addLayer","forEach","addEventListener","clickEv","PointerEvent","cancelable","originalEvent","e","dispatchEvent","keyEv","KeyboardEvent","focusEv","FocusEvent","csMeta","content","extentCache","map","geometry","cs","shapes","querySelectorAll","bboxExtent","Infinity","Number","NEGATIVE_INFINITY","shape","coord","i","data","innerHTML","trim","replace","split","tagName","_updateExtent","topLeft","L","point","bottomRight","pcrsBound","boundsToPCRSBounds","bounds","projection","tileCenter","tile","getCenter","pixel","transformation","transform","scale","pixelToPCRSBounds","subtract","add","result","Object","assign","_convertAndFormatPCRS","_getZoomBounds","minNativeZoom","maxNativeZoom","getZoomToZoom","tL","pcrs","bR","bound","horizontal","vertical","newZoom","getMaxZoom","metaName","toLowerCase","sdMeta","mapml2geojson","propertyFunction","json","el","table","cloneNode","_table2properties","prop0","source","dest","proj4","Proj","code","collection","geometries","push","_geometry2geojson","click","g","rect","getBoundingClientRect","event","MouseEvent","clientX","x","width","clientY","y","height","button","path","children","mousedown","call","mouseup","_layers","id","isPopupOpen","closePopup","cancelBubble","openPopup","focus","blur","activeElement","getContainer","zoomTo","center","unproject","setView","animate","whenReady","Promise","resolve","reject","interval","failureTimer","setInterval","featureElement","clearInterval","clearTimeout","setTimeout"],"mappings":"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"}