{"version":3,"file":"map-feature.js","sources":["../src/map-feature.js"],"sourcesContent":["export class MapFeature extends HTMLElement {\n  static get observedAttributes() {\n    return ['zoom', 'onfocus', 'onclick', 'onblur'];\n  }\n\n  get zoom() {\n    return +(this.hasAttribute('zoom') ? this.getAttribute('zoom') : 0);\n  }\n\n  set zoom(val) {\n    var parsedVal = parseInt(val, 10);\n    if (!isNaN(parsedVal) && parsedVal >= this.min && parsedVal <= this.max) {\n      this.setAttribute('zoom', parsedVal);\n    }\n  }\n\n  get min() {\n    // fallback: the minimum zoom bound of layer- element\n    return +(this.hasAttribute('min')\n      ? this.getAttribute('min')\n      : this._layer._layerEl.extent.zoom.minZoom);\n  }\n\n  set min(val) {\n    var parsedVal = parseInt(val, 10);\n    if (!isNaN(parsedVal)) {\n      if (\n        parsedVal >= this._layer._layerEl.extent.zoom.minZoom &&\n        parsedVal <= this._layer._layerEl.extent.zoom.maxZoom\n      ) {\n        this.setAttribute('min', parsedVal);\n      } else {\n        this.setAttribute('min', this._layer._layerEl.extent.zoom.minZoom);\n      }\n    }\n  }\n\n  get max() {\n    // fallback: the maximum zoom bound of layer- element\n    return +(this.hasAttribute('max')\n      ? this.getAttribute('max')\n      : this._layer._layerEl.extent.zoom.maxZoom);\n  }\n\n  set max(val) {\n    var parsedVal = parseInt(val, 10);\n    if (!isNaN(parsedVal)) {\n      if (\n        parsedVal >= this._layer._layerEl.extent.zoom.minZoom &&\n        parsedVal <= this._layer._layerEl.extent.zoom.maxZoom\n      ) {\n        this.setAttribute('max', parsedVal);\n      } else {\n        this.setAttribute('max', this._layer._layerEl.extent.zoom.maxZoom);\n      }\n    }\n  }\n\n  get extent() {\n    if (this.isConnected) {\n      // if the feature extent is the first time to be calculated or the feature extent is changed (by changing\n      // the innertext of map-coordinates), then calculate feature extent by invoking the getFeatureExtent function\n      if (!this._getFeatureExtent) {\n        this._getFeatureExtent = this._memoizeExtent();\n      }\n      return this._getFeatureExtent();\n    }\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    switch (name) {\n      case 'zoom': {\n        if (oldValue !== newValue && this._layer) {\n          let layer = this._layer,\n            layerEl = layer._layerEl,\n            mapmlvectors = layer._mapmlvectors;\n          // if the vector layer only has static features, should update zoom bounds when zoom attribute is changed\n          if (mapmlvectors?._staticFeature) {\n            this._removeInFeatureList(oldValue);\n            let native = this._getNativeZoomAndCS(layer._content);\n            mapmlvectors.zoomBounds = mapmlvectors._getZoomBounds(\n              layerEl.shadowRoot || layerEl,\n              native.zoom\n            );\n          }\n          this._removeFeature();\n          this._updateFeature();\n        }\n        break;\n      }\n      case 'onfocus':\n      case 'onclick':\n      case 'onblur':\n        if (this._groupEl) {\n          // \"synchronize\" the onevent properties (i.e. onfocus, onclick, onblur)\n          // between the mapFeature and its associated <g> element\n          this._groupEl[name] = this[name].bind(this._groupEl);\n          break;\n        }\n    }\n  }\n\n  constructor() {\n    // Always call super first in constructor\n    super();\n  }\n\n  connectedCallback() {\n    // if mapFeature element is not connected to layer- or layer-'s shadowroot,\n    // or the parent layer- element has a \"data-moving\" attribute\n    if (\n      (this.parentNode.nodeType !== document.DOCUMENT_FRAGMENT_NODE &&\n        this.parentNode.nodeName.toLowerCase() !== 'layer-') ||\n      (this.parentNode.nodeType === document.DOCUMENT_FRAGMENT_NODE &&\n        this.parentNode.host.hasAttribute('data-moving')) ||\n      (this.parentNode.nodeName.toLowerCase() === 'layer-' &&\n        this.parentNode.hasAttribute('data-moving'))\n    ) {\n      return;\n    }\n    // set up the map-feature object properties\n    this._addFeature();\n    // use observer to monitor the changes in mapFeature's subtree\n    // (i.e. map-properties, map-featurecaption, map-coordinates)\n    this._observer = new MutationObserver((mutationList) => {\n      for (let mutation of mutationList) {\n        // the attributes changes of <map-feature> element should be handled by attributeChangedCallback()\n        if (mutation.type === 'attributes' && mutation.target === this) {\n          return;\n        }\n        // re-render feature if there is any observed change\n        this._removeFeature();\n        this._updateFeature();\n      }\n    });\n    this._observer.observe(this, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeOldValue: true,\n      characterData: true\n    });\n  }\n\n  disconnectedCallback() {\n    if (this._layer._layerEl.hasAttribute('data-moving')) return;\n    this._removeFeature();\n    this._observer.disconnect();\n  }\n\n  _removeFeature() {\n    // if the <layer- > el is disconnected\n    // the <g> el has already got removed at this point\n    if (this._groupEl?.isConnected) {\n      this._groupEl.remove();\n    }\n    // if the <layer- > el has already been disconnected,\n    // then _map.removeLayer(layerEl._layer) has already been invoked (inside layerEl.disconnectedCallback())\n    // this._featureGroup has already got removed at this point\n    if (this._featureGroup?._map) {\n      this._featureGroup._map.removeLayer(this._featureGroup);\n      let mapmlvectors = this._layer._mapmlvectors;\n      if (mapmlvectors) {\n        if (mapmlvectors._staticFeature) {\n          if (mapmlvectors._features[this.zoom]) {\n            this._removeInFeatureList(this.zoom);\n          }\n          let container = this._layer.shadowRoot || this._layer._layerEl;\n          // update zoom bounds of vector layer\n          mapmlvectors.zoomBounds = mapmlvectors._getZoomBounds(\n            container,\n            this._getNativeZoomAndCS(this._layer._content).zoom\n          );\n        }\n        mapmlvectors.options.properties = null;\n        delete mapmlvectors._layers[this._featureGroup._leaflet_id];\n      }\n    }\n    delete this._featureGroup;\n    delete this._groupEl;\n    // ensure that feature extent can be re-calculated everytime that map-feature element is updated / re-added\n    if (this._getFeatureExtent) delete this._getFeatureExtent;\n  }\n\n  _addFeature() {\n    let parentEl =\n      this.parentNode.nodeName.toUpperCase() === 'LAYER-' ||\n      this.parentNode.nodeName.toUpperCase() === 'MAP-EXTENT'\n        ? this.parentNode\n        : this.parentNode.host;\n\n    // arrow function is not hoisted, define before use\n    var _attachedToMap = (e) => {\n      if (!parentEl._layer._map) {\n        // if the parent layer- el has not yet added to the map (i.e. not yet rendered), wait until it is added\n        this._layer.once(\n          'attached',\n          function () {\n            this._map = this._layer._map;\n          },\n          this\n        );\n      } else {\n        this._map = this._layer._map;\n      }\n      // \"synchronize\" the event handlers between map-feature and <g>\n      if (!this.querySelector('map-geometry')) return;\n      if (!this._layer._mapmlvectors) {\n        // if vector layer has not yet created (i.e. the layer- is not yet rendered on the map / layer is empty)\n        let layerEl = this._layer._layerEl;\n        this._layer.once('add', this._setUpEvents, this);\n        if (\n          !layerEl.querySelector('map-extent, map-tile') &&\n          !layerEl.hasAttribute('src') &&\n          layerEl.querySelectorAll('map-feature').length === 1\n        ) {\n          // if the map-feature is added to an empty layer, fire extentload to create vector layer\n          // must re-run _initialize of MapMLLayer.js to re-set layer._extent (layer._extent is null for an empty layer)\n          this._layer._initialize(layerEl);\n          this._layer.fire('extentload');\n        }\n        return;\n      } else if (!this._featureGroup) {\n        // if the map-feature el or its subtree is updated\n        // this._featureGroup has been free in this._removeFeature()\n        this._updateFeature();\n      } else {\n        this._setUpEvents();\n      }\n    };\n\n    if (!parentEl._layer) {\n      // for custom projection cases, the MapMLLayer has not yet created and binded with the layer- at this point,\n      // because the \"createMap\" event of mapml-viewer has not yet been dispatched, the map has not yet been created\n      // the event will be dispatched after defineCustomProjection > projection setter\n      // should wait until MapMLLayer is built\n      let parentLayer =\n        parentEl.nodeName.toUpperCase() === 'LAYER-'\n          ? parentEl\n          : parentEl.parentElement || parentEl.parentNode.host;\n      parentLayer.parentNode.addEventListener('createmap', (e) => {\n        this._layer = parentLayer._layer;\n        _attachedToMap();\n      });\n    } else {\n      this._layer = parentEl._layer;\n      _attachedToMap();\n    }\n  }\n\n  _updateFeature() {\n    let mapmlvectors = this._layer._mapmlvectors;\n    // if the parent layer has not yet rendered on the map\n    if (!mapmlvectors) return;\n    // if the <layer- > is not removed, then regenerate featureGroup and update the mapmlvectors accordingly\n    let native = this._getNativeZoomAndCS(this._layer._content);\n    this._featureGroup = mapmlvectors.addData(this, native.cs, native.zoom);\n    mapmlvectors._layers[this._featureGroup._leaflet_id] = this._featureGroup;\n    this._groupEl = this._featureGroup.options.group;\n    if (mapmlvectors._staticFeature) {\n      let container = this._layer.shadowRoot || this._layer._layerEl;\n      // update zoom bounds of vector layer\n      mapmlvectors.zoomBounds = mapmlvectors._getZoomBounds(\n        container,\n        this._getNativeZoomAndCS(this._layer._content).zoom\n      );\n      // add feature layers to map\n      mapmlvectors._resetFeatures();\n      // update map's zoom limit\n      this._map._addZoomLimit(mapmlvectors);\n      L.extend(mapmlvectors.options, mapmlvectors.zoomBounds);\n    }\n    this._setUpEvents();\n  }\n\n  _setUpEvents() {\n    ['click', 'focus', 'blur'].forEach((name) => {\n      // onevent properties & onevent attributes\n      if (this[`on${name}`] && typeof this[`on${name}`] === 'function') {\n        this._groupEl[`on${name}`] = this[`on${name}`];\n      }\n      // handle event handlers set via addEventlistener\n      // for HTMLElement\n      // when <g> is clicked / focused / blurred\n      // should dispatch the click / focus / blur event listener on **linked HTMLFeatureElements**\n      this._groupEl.addEventListener(name, (e) => {\n        // this === mapFeature as arrow function does not have their own \"this\" pointer\n        // store onEvent handler of mapFeature if there is any to ensure that it will not be re-triggered when the cloned mouseevent is dispatched\n        // so that only the event handlers set on HTMLFeatureElement via addEventListener method will be triggered\n        const handler = this[`on${name}`]; // a deep copy, var handler will not change when this.onevent is set to null (i.e. store the onevent property)\n        this[`on${name}`] = null;\n        if (name === 'click') {\n          // dispatch a cloned mouseevent to trigger the click event handlers set on HTMLFeatureElement\n          this.dispatchEvent(new PointerEvent(name, { ...e }));\n        } else {\n          this.dispatchEvent(new FocusEvent(name, { ...e }));\n        }\n        this[`on${name}`] = handler;\n      });\n    });\n  }\n\n  _getNativeZoomAndCS(content) {\n    // content: referred to <layer- > if the <layer- > has inline <map-extent>, <map-feature> or <map-tile>\n    //          referred to remote mapml if the <layer- > has a src attribute, and the fetched mapml contains <map-feature>\n    //          referred to null otherwise (i.e. <layer- > has fetched <map-extent> in shadow, the <map-feature> attaches to <map-extent>'s shadow)\n    let nativeZoom, nativeCS;\n    if (this._extentEl) {\n      // feature attaches to extent's shadow\n      if (this._extentEl.querySelector('map-link[rel=query]')) {\n        // for query, fallback zoom is the current map zoom level that the query is returned\n        nativeZoom = this._map.getZoom();\n        nativeCS = 'pcrs';\n      } else if (this._extentEl.querySelector('map-link[rel=features]')) {\n        // for templated feature, read fallback from the fetched mapml's map-meta[name=zoom / cs]\n        nativeZoom = this._extentEl._nativeZoom;\n        nativeCS = this._extentEl._nativeCS;\n      }\n      return { zoom: nativeZoom, cs: nativeCS };\n    } else {\n      // feature attaches to layer- or layer-'s shadow\n      if (content.nodeType === Node.DOCUMENT_NODE) {\n        // for features migrated from mapml, read native zoom and cs from the remote mapml\n        return this._layer._mapmlvectors._getNativeVariables(content);\n      } else if (content.nodeName.toUpperCase() === 'LAYER-') {\n        // for inline features, read native zoom and cs from inline map-meta\n        let zoomMeta = this.parentElement.querySelectorAll(\n            'map-meta[name=zoom]'\n          ),\n          zoomLength = zoomMeta?.length;\n        nativeZoom = zoomLength\n          ? +zoomMeta[zoomLength - 1]\n              .getAttribute('content')\n              ?.split(',')\n              .find((str) => str.includes('value'))\n              ?.split('=')[1]\n          : 0;\n\n        let csMeta = this.parentElement.querySelectorAll('map-meta[name=cs]'),\n          csLength = csMeta?.length;\n        nativeCS = csLength\n          ? csMeta[csLength - 1].getAttribute('content')\n          : 'pcrs';\n        return { zoom: nativeZoom, cs: nativeCS };\n      }\n    }\n  }\n\n  // Util functions:\n  // internal method to calculate the extent of the feature and store it in cache for the first time\n  // and return cache when feature's extent is repeatedly requested\n  // for .extent\n  _memoizeExtent() {\n    // memoize calculated extent\n    let extentCache;\n    return function () {\n      if (extentCache && this._getFeatureExtent) {\n        // if the extent has already been calculated and is not updated, return stored extent\n        return extentCache;\n      } else {\n        // calculate feature extent\n        let map = this._map,\n          geometry = this.querySelector('map-geometry'),\n          native = this._getNativeZoomAndCS(this._layer._content),\n          cs = geometry.getAttribute('cs') || native.cs,\n          // zoom level that the feature rendered at\n          zoom = this.zoom || native.zoom,\n          shapes = geometry.querySelectorAll(\n            'map-point, map-linestring, map-polygon, map-multipoint, map-multilinestring'\n          ),\n          bboxExtent = [\n            Infinity,\n            Infinity,\n            Number.NEGATIVE_INFINITY,\n            Number.NEGATIVE_INFINITY\n          ];\n        for (let shape of shapes) {\n          let coord = shape.querySelectorAll('map-coordinates');\n          for (let i = 0; i < coord.length; ++i) {\n            bboxExtent = _updateExtent(shape, coord[i], bboxExtent);\n          }\n        }\n        let topLeft = L.point(bboxExtent[0], bboxExtent[1]);\n        let bottomRight = L.point(bboxExtent[2], bboxExtent[3]);\n        let pcrsBound = M.boundsToPCRSBounds(\n          L.bounds(topLeft, bottomRight),\n          zoom,\n          map.options.projection,\n          cs\n        );\n        if (\n          shapes.length === 1 &&\n          shapes[0].tagName.toUpperCase() === 'MAP-POINT'\n        ) {\n          let projection = map.options.projection,\n            maxZoom = this.hasAttribute('max')\n              ? +this.getAttribute('max')\n              : M[projection].options.resolutions.length - 1,\n            tileCenter = M[projection].options.crs.tile.bounds.getCenter(),\n            pixel = M[projection].transformation.transform(\n              pcrsBound.min,\n              M[projection].scale(+this.zoom || maxZoom)\n            );\n          pcrsBound = M.pixelToPCRSBounds(\n            L.bounds(pixel.subtract(tileCenter), pixel.add(tileCenter)),\n            this.zoom || maxZoom,\n            projection\n          );\n        }\n        let result = M._convertAndFormatPCRS(pcrsBound, map);\n        // memoize calculated result\n        extentCache = result;\n        return result;\n      }\n    };\n\n    // update the bboxExtent\n    function _updateExtent(shape, coord, bboxExtent) {\n      let data = coord.innerHTML\n        .trim()\n        .replace(/<[^>]+>/g, '')\n        .replace(/\\s+/g, ' ')\n        .split(/[<>\\ ]/g);\n      switch (shape.tagName) {\n        case 'MAP-POINT':\n          bboxExtent = M._updateExtent(bboxExtent, +data[0], +data[1]);\n          break;\n        case 'MAP-LINESTRING':\n        case 'MAP-POLYGON':\n        case 'MAP-MULTIPOINT':\n        case 'MAP-MULTILINESTRING':\n          for (let i = 0; i < data.length; i += 2) {\n            bboxExtent = M._updateExtent(bboxExtent, +data[i], +data[i + 1]);\n          }\n          break;\n        default:\n          break;\n      }\n      return bboxExtent;\n    }\n  }\n\n  // find and remove the feature from mapmlvectors._features if vector layer only contains static features, helper function\n  //      prevent it from being rendered again when zooming in / out (mapmlvectors.resetFeature() is invoked)\n  _removeInFeatureList(zoom) {\n    let mapmlvectors = this._layer._mapmlvectors;\n    for (let i = 0; i < mapmlvectors._features[zoom].length; ++i) {\n      let feature = mapmlvectors._features[zoom][i];\n      if (feature._leaflet_id === this._featureGroup._leaflet_id) {\n        mapmlvectors._features[zoom].splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  getMaxZoom() {\n    let tL = this.extent.topLeft.pcrs,\n      bR = this.extent.bottomRight.pcrs,\n      bound = L.bounds(\n        L.point(tL.horizontal, tL.vertical),\n        L.point(bR.horizontal, bR.vertical)\n      );\n    let projection = this._map.options.projection,\n      layerZoomBounds = this._layer._layerEl.extent.zoom,\n      minZoom = layerZoomBounds.minZoom ? layerZoomBounds.minZoom : 0,\n      maxZoom = layerZoomBounds.maxZoom\n        ? layerZoomBounds.maxZoom\n        : M[projection].options.resolutions.length - 1;\n    let newZoom;\n    if (this.hasAttribute('zoom')) {\n      // if there is a zoom attribute set to the map-feature, zoom to the zoom attribute value\n      newZoom = this.zoom;\n    } else {\n      // if not, calculate the maximum zoom level that can show the feature completely\n      newZoom = M.getMaxZoom(bound, this._map, minZoom, maxZoom);\n      if (this.max < newZoom) {\n        // if the calculated zoom is greater than the value of max zoom attribute, go with max zoom attribute\n        newZoom = this.max;\n      } else if (this.min > newZoom) {\n        // if the calculated zoom is less than the value of min zoom attribute, go with min zoom attribute\n        newZoom = this.min;\n      }\n    }\n    // prevent overzooming / underzooming\n    if (newZoom < minZoom) {\n      newZoom = minZoom;\n    } else if (newZoom > maxZoom) {\n      newZoom = maxZoom;\n    }\n\n    // should check whether the extent after zooming falls into the templated extent bound\n    return newZoom;\n  }\n\n  // internal support for returning a GeoJSON representation of <map-feature> geometry\n  // The options object can contain the following:\n  //      propertyFunction   - function(<map-properties>), A function that maps the features' <map-properties> element to a GeoJSON \"properties\" member.\n  //      transform          - Bool, Transform coordinates to gcrs values, defaults to True\n  // mapml2geojson: <map-feature> Object -> GeoJSON\n  mapml2geojson(options) {\n    let defaults = {\n      propertyFunction: null,\n      transform: true\n    };\n    // assign default values for undefined options\n    options = Object.assign({}, defaults, options);\n\n    let json = {\n      type: 'Feature',\n      properties: {},\n      geometry: {}\n    };\n    let el = this.querySelector('map-properties');\n    if (!el) {\n      json.properties = null;\n    } else if (typeof options.propertyFunction === 'function') {\n      json.properties = options.propertyFunction(el);\n    } else if (el.querySelector('table')) {\n      // setting properties when table presented\n      let table = el.querySelector('table').cloneNode(true);\n      json.properties = M._table2properties(table);\n    } else {\n      // when no table present, strip any possible html tags to only get text\n      json.properties = {\n        prop0: el.innerHTML.replace(/(<([^>]+)>)/gi, '').replace(/\\s/g, '')\n      };\n    }\n\n    // transform to gcrs if options.transform = true (default)\n    let source = null,\n      dest = null;\n    if (options.transform) {\n      source = new proj4.Proj(this._map.options.crs.code);\n      dest = new proj4.Proj('EPSG:4326');\n      if (\n        this._map.options.crs.code === 'EPSG:3857' ||\n        this._map.options.crs.code === 'EPSG:4326'\n      ) {\n        options.transform = false;\n      }\n    }\n\n    let collection = this.querySelector('map-geometry').querySelector(\n        'map-geometrycollection'\n      ),\n      shapes = this.querySelector('map-geometry').querySelectorAll(\n        'map-point, map-polygon, map-linestring, map-multipoint, map-multipolygon, map-multilinestring'\n      );\n\n    if (collection) {\n      json.geometry.type = 'GeometryCollection';\n      json.geometry.geometries = [];\n      for (let shape of shapes) {\n        json.geometry.geometries.push(\n          M._geometry2geojson(shape, source, dest, options.transform)\n        );\n      }\n    } else {\n      json.geometry = M._geometry2geojson(\n        shapes[0],\n        source,\n        dest,\n        options.transform\n      );\n    }\n    return json;\n  }\n\n  // a method that simulates a click, or invoking the user-defined click event\n  //      event (optional): a MouseEvent object, can be passed as an argument of the user-defined click event handlers\n  click(event) {\n    let g = this._groupEl,\n      rect = g.getBoundingClientRect();\n    if (!event) {\n      event = new MouseEvent('click', {\n        clientX: rect.x + rect.width / 2,\n        clientY: rect.y + rect.height / 2,\n        button: 0\n      });\n    }\n    if (typeof this.onclick === 'function') {\n      this.onclick.call(this._groupEl, event);\n      return;\n    } else {\n      let properties = this.querySelector('map-properties');\n      if (g.getAttribute('role') === 'link') {\n        for (let path of g.children) {\n          path.mousedown.call(this._featureGroup, event);\n          path.mouseup.call(this._featureGroup, event);\n        }\n      }\n      // for custom projection, layer- element may disconnect and re-attach to the map after the click\n      // so check whether map-feature element is still connected before any further operations\n      if (properties && this.isConnected) {\n        let featureGroup = this._featureGroup,\n          shapes = featureGroup._layers;\n        // close popup if the popup is currently open\n        for (let id in shapes) {\n          if (shapes[id].isPopupOpen()) {\n            shapes[id].closePopup();\n          }\n        }\n        if (featureGroup.isPopupOpen()) {\n          featureGroup.closePopup();\n        } else {\n          featureGroup.openPopup();\n        }\n      }\n    }\n  }\n\n  // a method that sets the current focus to the <g> element, or invoking the user-defined focus event\n  //      event (optional): a FocusEvent object, can be passed as an argument of the user-defined focus event handlers\n  //      options (optional): as options parameter for native HTMLelemnt\n  //                          https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus\n  focus(event, options) {\n    let g = this._groupEl;\n    if (typeof this.onfocus === 'function') {\n      this.onfocus.call(this._groupEl, event);\n      return;\n    } else {\n      g.focus(options);\n    }\n  }\n\n  // a method that makes the <g> element lose focus, or invoking the user-defined blur event\n  //      event (optional): a FocusEvent object, can be passed as an argument of the user-defined blur event handlers\n  blur(event) {\n    if (typeof this.onblur === 'function') {\n      this.onblur.call(this._groupEl, event);\n    } else if (\n      document.activeElement.shadowRoot?.activeElement === this._groupEl ||\n      document.activeElement.shadowRoot?.activeElement.parentNode ===\n        this._groupEl\n    ) {\n      this._groupEl.blur();\n      // set focus to the map container\n      this._map._container.focus();\n    }\n  }\n\n  // a method that can the viewport to be centred on the feature's extent\n  zoomTo() {\n    let extent = this.extent,\n      map = this._map;\n    let tL = extent.topLeft.pcrs,\n      bR = extent.bottomRight.pcrs,\n      bound = L.bounds(\n        L.point(tL.horizontal, tL.vertical),\n        L.point(bR.horizontal, bR.vertical)\n      ),\n      center = map.options.crs.unproject(bound.getCenter(true));\n    map.setView(center, this.getMaxZoom(), { animate: false });\n  }\n}\n"],"names":["MapFeature","HTMLElement","observedAttributes","zoom","this","hasAttribute","getAttribute","val","parsedVal","parseInt","isNaN","min","max","setAttribute","_layer","_layerEl","extent","minZoom","maxZoom","isConnected","_getFeatureExtent","_memoizeExtent","attributeChangedCallback","name","oldValue","newValue","let","layer","layerEl","mapmlvectors","_mapmlvectors","native","_staticFeature","_removeInFeatureList","_getNativeZoomAndCS","_content","zoomBounds","_getZoomBounds","shadowRoot","_removeFeature","_updateFeature","_groupEl","bind","constructor","super","connectedCallback","parentNode","nodeType","document","DOCUMENT_FRAGMENT_NODE","nodeName","toLowerCase","host","_addFeature","_observer","MutationObserver","mutation","mutationList","type","target","observe","childList","subtree","attributes","attributeOldValue","characterData","disconnectedCallback","disconnect","remove","_featureGroup","_map","removeLayer","container","_features","options","properties","_layers","_leaflet_id","parentEl","toUpperCase","_attachedToMap","once","querySelector","_setUpEvents","querySelectorAll","length","_initialize","fire","parentLayer","parentElement","addEventListener","addData","cs","group","_resetFeatures","_addZoomLimit","L","extend","forEach","handler","dispatchEvent","PointerEvent","e","FocusEvent","content","nativeZoom","nativeCS","_extentEl","getZoom","_nativeZoom","_nativeCS","Node","DOCUMENT_NODE","_getNativeVariables","zoomMeta","zoomLength","split","find","str","includes","csMeta","csLength","extentCache","map","geometry","shapes","bboxExtent","Infinity","Number","NEGATIVE_INFINITY","shape","coord","i","data","innerHTML","trim","replace","tagName","M","_updateExtent","topLeft","point","bottomRight","pcrsBound","boundsToPCRSBounds","bounds","projection","resolutions","tileCenter","crs","tile","getCenter","pixel","transformation","transform","scale","pixelToPCRSBounds","subtract","add","result","_convertAndFormatPCRS","splice","getMaxZoom","tL","pcrs","bR","bound","horizontal","vertical","layerZoomBounds","newZoom","mapml2geojson","Object","assign","propertyFunction","json","el","table","cloneNode","_table2properties","prop0","source","dest","proj4","Proj","code","collection","geometries","push","_geometry2geojson","click","event","g","rect","getBoundingClientRect","MouseEvent","clientX","x","width","clientY","y","height","button","onclick","call","path","children","mousedown","mouseup","featureGroup","id","isPopupOpen","closePopup","openPopup","focus","onfocus","blur","onblur","activeElement","_container","zoomTo","center","unproject","setView","animate"],"mappings":"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"}