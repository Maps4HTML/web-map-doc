{"version":3,"file":"map-link.js","sources":["../src/map-link.js"],"sourcesContent":["/* global M */\n\nexport class MapLink extends HTMLElement {\n  static get observedAttributes() {\n    return [\n      'type',\n      'rel',\n      //      'title',\n      'media',\n      'href',\n      'hreflang',\n      'tref',\n      'tms',\n      'projection'\n    ];\n  }\n  /* jshint ignore:start */\n  #hasConnected;\n  /* jshint ignore:end */\n  get type() {\n    return this.getAttribute('type') || 'image/*';\n  }\n  set type(val) {\n    // improve this\n    if (\n      val === 'text/mapml' ||\n      val.startsWith('image/' || val === 'application/pmtiles')\n    ) {\n      this.setAttribute('type', val);\n    }\n  }\n  get rel() {\n    // rel value has no default value\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel#:~:text=The%20rel%20attribute%20has%20no%20default%20value.\n    return this.getAttribute('rel');\n  }\n  set rel(val) {\n    // improve this\n    if (\n      [\n        'license',\n        'alternate',\n        'self',\n        'style',\n        'tile',\n        'image',\n        'features',\n        'zoomin',\n        'zoomout',\n        'legend',\n        'query',\n        'stylesheet'\n      ].includes(val)\n    ) {\n      this.setAttribute('type', val);\n    }\n  }\n  //  get title() {\n  //    return this.getAttribute('title');\n  //  }\n  //  set title(val) {\n  //    if (val) {\n  //      this.setAttribute('title', val);\n  //    }\n  //  }\n  get href() {\n    if (this.hasAttribute('href')) {\n      return new URL(this.getAttribute('href'), this.getBase()).href;\n    } else if (this.hasAttribute('tref')) {\n      return this.resolve();\n    }\n  }\n  set href(val) {\n    // improve this\n    if (val) {\n      this.setAttribute('href', val);\n    }\n  }\n  get hreflang() {\n    return this.getAttribute('hreflang');\n  }\n  set hreflang(val) {\n    // improve this\n    if (val) {\n      this.setAttribute('hreflang', val);\n    }\n  }\n  get tref() {\n    if (!this.hasAttribute('tref')) {\n      return M.BLANK_TT_TREF;\n    }\n    return this.getAttribute('tref');\n  }\n  set tref(val) {\n    // improve this\n    if (val) {\n      this.setAttribute('tref', val);\n    }\n  }\n  get media() {\n    // return the content of media attribute as an object\n    // maybe memoizing the object to avoid repeated formatting\n    // the Util function may need to be renamed?\n    return M._metaContentToObject(this.getAttribute('media'));\n  }\n  set media(val) {\n    this.setAttribute('media', val);\n  }\n  get tms() {\n    return this.hasAttribute('tms');\n  }\n  set tms(val) {\n    // improve this\n    if (val) {\n      this.setAttribute('tms', '');\n    }\n  }\n  get projection() {\n    return this.getAttribute('projection');\n  }\n  set projection(val) {\n    // improve this\n    if (['OSMTILE', 'CBMTILE', 'WGS84', 'APSTILE'].includes(val)) {\n      this.setAttribute('projection', val);\n    }\n  }\n  get extent() {\n    // calculate the bounds of content, return it.\n    // _templateVars existence happens for both templated layers and query links\n    return this._templateVars\n      ? Object.assign(\n          M._convertAndFormatPCRS(\n            this.getBounds(),\n            M[this.parentExtent.units],\n            this.parentExtent.units\n          ),\n          { zoom: this.getZoomBounds() }\n        )\n      : null;\n  }\n  zoomTo() {\n    let extent = this.extent;\n    if (!extent) return;\n    let map = this.getMapEl()._map,\n      xmin = extent.topLeft.pcrs.horizontal,\n      xmax = extent.bottomRight.pcrs.horizontal,\n      ymin = extent.bottomRight.pcrs.vertical,\n      ymax = extent.topLeft.pcrs.vertical,\n      bounds = L.bounds(L.point(xmin, ymin), L.point(xmax, ymax)),\n      center = map.options.crs.unproject(bounds.getCenter(true)),\n      maxZoom = extent.zoom.maxZoom,\n      minZoom = extent.zoom.minZoom;\n    map.setView(center, M.getMaxZoom(bounds, map, minZoom, maxZoom), {\n      animate: false\n    });\n  }\n  getMapEl() {\n    return M.getClosest(this, 'mapml-viewer,map[is=web-map]');\n  }\n  getLayerEl() {\n    return M.getClosest(this, 'layer-');\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    //['type','rel','href','hreflang','tref','tms','projection'];\n    // fold to lowercase\n    if (this.#hasConnected /* jshint ignore:line */) {\n      switch (name) {\n        case 'type':\n          // rel = tile, features, etc. TBD when it is used\n          //        ttype = !t.hasAttribute('type')\n          //          ? 'image/*'\n          //          : t.getAttribute('type').toLowerCase(),\n\n          if (oldValue !== newValue) {\n            // default value image/*\n            // handle side effects\n          }\n          break;\n        case 'rel':\n          // mandatory attribute, no default value\n          if (oldValue !== newValue) {\n            // handle side effects\n            if (newValue === 'query') {\n            }\n          }\n          break;\n        //      case 'title':\n        //        if (oldValue !== newValue) {\n        //          // handle side effects\n        //        }\n        //        break;\n        case 'href':\n          // rel = license, legend, stylesheet, self, style, self style, style self, zoomin, zoomout\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n        case 'hreflang':\n          // rel = *all*\n          // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#hreflang\n          // idea is that we can have multiple map-links with different hreflang, and map-extent chooses a map-link that matches with user's lang. Not a priority. - create an use-case issue?\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n        case 'tref':\n          // rel = tile, image, features, query\n          if (oldValue !== newValue) {\n            // create or reset the _templateVars property\n            this._initTemplateVars();\n          }\n          break;\n        case 'media':\n          break;\n        case 'tms':\n          // rel = tile\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n        case 'projection':\n          // rel = alternate\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n      }\n    }\n  }\n  constructor() {\n    // Always call super first in constructor\n    super();\n  }\n  connectedCallback() {\n    this.#hasConnected = true; /* jshint ignore:line */\n    if (\n      this.getLayerEl().hasAttribute('data-moving') ||\n      (this.parentExtent && this.parentExtent.hasAttribute('data-moving'))\n    )\n      return;\n    switch (this.rel.toLowerCase()) {\n      // for some cases, require a dependency check\n      case 'tile':\n      case 'image':\n      case 'features':\n      case 'query':\n        this._initTemplateVars();\n        this._createTemplatedLink();\n        break;\n      case 'style':\n      case 'self':\n      case 'style self':\n      case 'self style':\n        this._createSelfOrStyleLink();\n        break;\n      case 'zoomin':\n      case 'zoomout':\n        //        this._createZoominOrZoomoutLink();\n        break;\n      case 'legend':\n        //this._createLegendLink();\n        break;\n      case 'stylesheet':\n        // MIME type application/pmtiles+stylesheet is an invention of the requirement to get\n        // closer to loading style rules as CSS does, via link / (map-link)\n        // we could probably do something similar with map-style i.e. treat the\n        // content of map-style as though it was a stylesheet tbd caveat CSP\n        if (this.type === 'application/pmtiles+stylesheet') {\n          const pmtilesStyles = new URL(this.href, this.getBase()).href;\n          import(pmtilesStyles)\n            .then((module) => {\n              this._pmtilesRules = module.pmtilesRules;\n            })\n            .catch((reason) => {\n              console.error(\n                'Error importing pmtiles symbolizer rules or theme: \\n' + reason\n              );\n            });\n        } else {\n          this._createStylesheetLink();\n        }\n        break;\n      case 'alternate':\n        this._createAlternateLink(); // add media attribute\n        break;\n      case 'license':\n        // this._createLicenseLink();\n        break;\n    }\n    // create the type of templated leaflet layer appropriate to the rel value\n    // image/map/features = templated(Image/Feature), tile=templatedTile,\n    // this._tempatedTileLayer = M.templatedTile(pane: this.extentElement._leafletLayer._container)\n    // add to viewer._map dependant on map-extent.checked, layer-.checked\n    // what else?\n  }\n  disconnectedCallback() {\n    switch (this.rel.toLowerCase()) {\n      case 'stylesheet':\n        if (this._stylesheetHost) {\n          this.link.remove();\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  _createAlternateLink(mapml) {\n    if (this.href && this.projection) this._alternate = true;\n  }\n  _createStylesheetLink() {\n    // if the parent element is a map-link, the stylesheet is a link that should\n    //  be loaded as part of a templated layer processing i.e. on moveend\n    //  and the generated <link> that implements this <map-link> should be located\n    //  in the parent <map-link>._templatedLayer.container root node if\n    //  the _templatedLayer is an instance of M.TemplatedTileLayer or M.TemplatedFeaturesLayer\n    //\n    // if the parent node (or the host of the shadow root parent node) is layer-, the link should be created in the _layer\n    // container\n    this._stylesheetHost =\n      this.getRootNode() instanceof ShadowRoot\n        ? this.getRootNode().host\n        : this.parentElement;\n    if (this._stylesheetHost === undefined) return;\n\n    this.link = document.createElement('link');\n    this.link.mapLink = this;\n    this.link.setAttribute('href', new URL(this.href, this.getBase()).href);\n    copyAttributes(this, this.link);\n\n    if (this._stylesheetHost._layer) {\n      this._stylesheetHost._layer.appendStyleLink(this);\n    } else if (this._stylesheetHost._templatedLayer) {\n      this._stylesheetHost._templatedLayer.appendStyleLink(this);\n    } else if (this._stylesheetHost._extentLayer) {\n      this._stylesheetHost._extentLayer.appendStyleLink(this);\n    }\n\n    function copyAttributes(source, target) {\n      return Array.from(source.attributes).forEach((attribute) => {\n        if (attribute.nodeName !== 'href')\n          target.setAttribute(attribute.nodeName, attribute.nodeValue);\n      });\n    }\n  }\n\n  async _createTemplatedLink() {\n    // conditions check\n    // the tms and type attributes are optional, may need to be checked in future\n    this.parentExtent =\n      this.parentNode.nodeName.toUpperCase() === 'MAP-EXTENT'\n        ? this.parentNode\n        : this.parentNode.host;\n    if (!this.tref || !this.parentExtent) return;\n    try {\n      await this.parentExtent.whenReady();\n      await this._templateVars.inputsReady;\n    } catch (error) {\n      console.log('Error while creating templated link: ' + error);\n      return;\n    }\n    this.mapEl = this.getMapEl();\n    // create the layer type appropriate to the rel value\n    this.zIndex = Array.from(\n      this.parentExtent.querySelectorAll(\n        'map-link[rel=image],map-link[rel=tile],map-link[rel=features]'\n      )\n    ).indexOf(this);\n    if (\n      (this.rel === 'tile' && this.type === 'application/pmtiles') ||\n      this.type === 'application/vnd.mapbox-vector-tile'\n    ) {\n      let relativeSelector =\n        'map-link[rel=\"stylesheet\"][type=\"application/pmtiles+stylesheet\"]';\n      let rules = M.getClosest(\n        this,\n        'map-extent:has(' +\n          relativeSelector +\n          '),layer-:has(' +\n          relativeSelector +\n          '),mapml-viewer:has(' +\n          relativeSelector +\n          ')'\n      )?.querySelector(relativeSelector)._pmtilesRules;\n      let options = {\n        zoomBounds: this.getZoomBounds(),\n        extentBounds: this.getBounds(),\n        crs: M[this.parentExtent.units],\n        zIndex: this.zIndex,\n        pane: this.parentExtent._extentLayer.getContainer(),\n        linkEl: this,\n        pmtilesRules: rules\n      };\n      this._templatedLayer = M.templatedPMTilesLayer(\n        this._templateVars,\n        options\n      ).addTo(this.parentExtent._extentLayer);\n    } else if (this.rel === 'tile') {\n      this._templatedLayer = M.templatedTileLayer(this._templateVars, {\n        zoomBounds: this.getZoomBounds(),\n        extentBounds: this.getBounds(),\n        crs: M[this.parentExtent.units],\n        errorTileUrl:\n          'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==',\n        zIndex: this.zIndex,\n        pane: this.parentExtent._extentLayer.getContainer(),\n        linkEl: this\n      }).addTo(this.parentExtent._extentLayer);\n    } else if (this.rel === 'image') {\n      this._templatedLayer = M.templatedImageLayer(this._templateVars, {\n        zoomBounds: this.getZoomBounds(),\n        extentBounds: this.getBounds(),\n        zIndex: this.zIndex,\n        pane: this.parentExtent._extentLayer.getContainer(),\n        linkEl: this\n      }).addTo(this.parentExtent._extentLayer);\n    } else if (this.rel === 'features') {\n      // map-feature retrieved by link will be stored in shadowRoot owned by link\n      this.attachShadow({ mode: 'open' });\n      this._templatedLayer = M.templatedFeaturesLayer(this._templateVars, {\n        zoomBounds: this.getZoomBounds(),\n        extentBounds: this.getBounds(),\n        zIndex: this.zIndex,\n        pane: this.parentExtent._extentLayer.getContainer(),\n        linkEl: this\n      }).addTo(this.parentExtent._extentLayer);\n    } else if (this.rel === 'query') {\n      this.attachShadow({ mode: 'open' });\n      L.extend(this._templateVars, this._setupQueryVars(this._templateVars));\n      L.extend(this._templateVars, { extentBounds: this.getBounds() });\n    }\n  }\n  _setupQueryVars(template) {\n    // process the inputs associated to template and create an object named\n    // query with member properties as follows:\n    // {width: 'widthvarname',\n    //  height: 'heightvarname',\n    //  left: 'leftvarname',\n    //  right: 'rightvarname',\n    //  top: 'topvarname',\n    //  bottom: 'bottomvarname'\n    //  i: 'ivarname'\n    //  j: 'jvarname'}\n    //  x: 'xvarname' x being the tcrs x axis\n    //  y: 'yvarname' y being the tcrs y axis\n    //  z: 'zvarname' zoom\n    //  title: link title\n\n    var queryVarNames = { query: {} },\n      inputs = template.values;\n\n    for (var i = 0; i < template.values.length; i++) {\n      var type = inputs[i].getAttribute('type'),\n        units = inputs[i].getAttribute('units'),\n        axis = inputs[i].getAttribute('axis'),\n        name = inputs[i].getAttribute('name'),\n        position = inputs[i].getAttribute('position'),\n        rel = inputs[i].getAttribute('rel'),\n        select = inputs[i].tagName.toLowerCase() === 'map-select';\n      if (type === 'width') {\n        queryVarNames.query.width = name;\n      } else if (type === 'height') {\n        queryVarNames.query.height = name;\n      } else if (type === 'location') {\n        switch (axis) {\n          case 'x':\n          case 'y':\n          case 'column':\n          case 'row':\n            queryVarNames.query[axis] = name;\n            break;\n          case 'longitude':\n          case 'easting':\n            if (position) {\n              if (position.match(/.*?-left/i)) {\n                if (rel === 'pixel') {\n                  queryVarNames.query.pixelleft = name;\n                } else if (rel === 'tile') {\n                  queryVarNames.query.tileleft = name;\n                } else {\n                  queryVarNames.query.mapleft = name;\n                }\n              } else if (position.match(/.*?-right/i)) {\n                if (rel === 'pixel') {\n                  queryVarNames.query.pixelright = name;\n                } else if (rel === 'tile') {\n                  queryVarNames.query.tileright = name;\n                } else {\n                  queryVarNames.query.mapright = name;\n                }\n              }\n            } else {\n              queryVarNames.query[axis] = name;\n            }\n            break;\n          case 'latitude':\n          case 'northing':\n            if (position) {\n              if (position.match(/top-.*?/i)) {\n                if (rel === 'pixel') {\n                  queryVarNames.query.pixeltop = name;\n                } else if (rel === 'tile') {\n                  queryVarNames.query.tiletop = name;\n                } else {\n                  queryVarNames.query.maptop = name;\n                }\n              } else if (position.match(/bottom-.*?/i)) {\n                if (rel === 'pixel') {\n                  queryVarNames.query.pixelbottom = name;\n                } else if (rel === 'tile') {\n                  queryVarNames.query.tilebottom = name;\n                } else {\n                  queryVarNames.query.mapbottom = name;\n                }\n              }\n            } else {\n              queryVarNames.query[axis] = name;\n            }\n            break;\n          case 'i':\n            if (units === 'tile') {\n              queryVarNames.query.tilei = name;\n            } else {\n              queryVarNames.query.mapi = name;\n            }\n            break;\n          case 'j':\n            if (units === 'tile') {\n              queryVarNames.query.tilej = name;\n            } else {\n              queryVarNames.query.mapj = name;\n            }\n            break;\n          default:\n          // unsuportted axis value\n        }\n      } else if (type === 'zoom') {\n        //<input name=\"...\" type=\"zoom\" value=\"0\" min=\"0\" max=\"17\">\n        queryVarNames.query.zoom = name;\n      } else if (select) {\n        /*jshint -W104 */\n        const parsedselect = inputs[i].htmlselect;\n        queryVarNames.query[name] = function () {\n          return parsedselect.value;\n        };\n      } else {\n        /*jshint -W104 */\n        const input = inputs[i];\n        queryVarNames.query[name] = function () {\n          return input.getAttribute('value');\n        };\n      }\n    }\n    return queryVarNames;\n  }\n  _initTemplateVars() {\n    // set up the URL template and associated inputs (which yield variable values when processed)\n    var varNamesRe = new RegExp('(?:{)(.*?)(?:})', 'g'),\n      zoomInput = this.parentElement.querySelector('map-input[type=\"zoom\" i]'),\n      includesZoom = false,\n      linkedZoomInput;\n\n    var template = this.tref;\n    if (template === M.BLANK_TT_TREF) {\n      for (let i of this.parentElement.querySelectorAll('map-input')) {\n        template += `{${i.getAttribute('name')}}`;\n      }\n    }\n    this.zoomInput = zoomInput;\n\n    var v,\n      vcount = template.match(varNamesRe) || [],\n      inputs = [],\n      inputsReady = [];\n    while ((v = varNamesRe.exec(template)) !== null) {\n      let varName = v[1],\n        inp = this.parentElement.querySelector(\n          'map-input[name=' + varName + '],map-select[name=' + varName + ']'\n        );\n      if (inp) {\n        // this \"associates\" the input to this  map-link\n        inputs.push(inp);\n        inputsReady.push(inp.whenReady());\n\n        // I think this means that regardless of whether the tref includes\n        // a reference to the zoom input, it gets associated to the link\n        // and used (to specify the native zoom bounds??) for the templated(Tile|Image|Features)Layer\n        if (\n          inp.hasAttribute('type') &&\n          inp.getAttribute('type').toLowerCase() === 'zoom'\n        ) {\n          linkedZoomInput = inp;\n          includesZoom = true;\n        }\n        // moved a block to map-select to transcribe the map-select into an\n        // actual html select for inclusion in the layer control.\n\n        // TODO: if this is an input@type=location\n        // get the TCRS min,max attribute values at the identified zoom level\n        // save this information as properties of the mapExtent,\n        // perhaps as a bounds object so that it can be easily used\n        // later by the layer control to determine when to enable\n        // disable the layer for drawing.\n      } else {\n        console.log(\n          'input with name=' +\n            varName +\n            ' not found for template variable of same name'\n        );\n      }\n    }\n    if (template && vcount.length === inputs.length) {\n      if (!includesZoom && zoomInput) {\n        inputs.push(zoomInput);\n        linkedZoomInput = zoomInput;\n      }\n      let step = zoomInput ? zoomInput.getAttribute('step') : 1;\n      if (!step || step === '0' || isNaN(step)) step = 1;\n      // template has a matching input for every variable reference {varref}\n      this._templateVars = {\n        template: decodeURI(new URL(template, this.getBase())),\n        linkEl: this,\n        rel: this.rel,\n        type: this.type,\n        values: inputs,\n        inputsReady: Promise.allSettled(inputsReady),\n        zoom: linkedZoomInput,\n        projection: this.parentElement.units,\n        tms: this.tms,\n        step: step\n      };\n    }\n  }\n  getZoomBounds() {\n    return this._getZoomBounds(this._templateVars.zoom);\n  }\n  /**\n   * TODO: review getBounds for sanity, also getFallbackBounds, perhaps integrate\n   * there is no other kind of bounds but native....\n   *  each rectangle must be established and valid and converted to PCRS coordinates...\n    // \"native\" bounds = input type=location min max || map-extent/map-meta name=extent min,max || layer-/map-meta name=extent min,max || layer projection min/max\n */\n  getBounds() {\n    let template = this._templateVars;\n    let inputs = template.values,\n      projection = this.parentElement.units,\n      boundsUnit = {};\n    boundsUnit.name = M.FALLBACK_CS;\n    let bounds = M[projection].options.crs.tilematrix.bounds(0),\n      locInputs = false,\n      numberOfAxes = 0,\n      horizontalAxis = false,\n      verticalAxis = false;\n    for (let i = 0; i < inputs.length; i++) {\n      if (inputs[i].getAttribute('type') === 'location') {\n        if (!inputs[i].getAttribute('max') || !inputs[i].getAttribute('min'))\n          continue;\n        let max = +inputs[i].getAttribute('max'),\n          min = +inputs[i].getAttribute('min');\n        switch (inputs[i].getAttribute('axis').toLowerCase()) {\n          case 'x':\n          case 'longitude':\n          case 'column':\n          case 'easting':\n            boundsUnit.name = M.axisToCS(\n              inputs[i].getAttribute('axis').toLowerCase()\n            );\n            bounds.min.x = min;\n            bounds.max.x = max;\n            boundsUnit.horizontalAxis = inputs[i]\n              .getAttribute('axis')\n              .toLowerCase();\n            break;\n          case 'y':\n          case 'latitude':\n          case 'row':\n          case 'northing':\n            boundsUnit.name = M.axisToCS(\n              inputs[i].getAttribute('axis').toLowerCase()\n            );\n            bounds.min.y = min;\n            bounds.max.y = max;\n            boundsUnit.verticalAxis = inputs[i]\n              .getAttribute('axis')\n              .toLowerCase();\n            break;\n          default:\n            break;\n        }\n      }\n    }\n    if (\n      boundsUnit.horizontalAxis &&\n      boundsUnit.verticalAxis &&\n      ((boundsUnit.horizontalAxis === 'x' && boundsUnit.verticalAxis === 'y') ||\n        (boundsUnit.horizontalAxis === 'longitude' &&\n          boundsUnit.verticalAxis === 'latitude') ||\n        (boundsUnit.horizontalAxis === 'column' &&\n          boundsUnit.verticalAxis === 'row') ||\n        (boundsUnit.horizontalAxis === 'easting' &&\n          boundsUnit.verticalAxis === 'northing'))\n    ) {\n      locInputs = true;\n    }\n    if (locInputs) {\n      let zoomValue = this._templateVars.zoom?.hasAttribute('value')\n        ? +this._templateVars.zoom.getAttribute('value')\n        : 0;\n      bounds = M.boundsToPCRSBounds(\n        bounds,\n        zoomValue,\n        projection,\n        boundsUnit.name\n      );\n    } else if (!locInputs) {\n      bounds = this.getFallbackBounds(projection);\n    }\n    return bounds;\n  }\n  getFallbackBounds(projection) {\n    let bounds;\n\n    let zoom = 0;\n    let metaExtent = this.parentElement.getMeta('extent');\n    if (metaExtent) {\n      let content = M._metaContentToObject(metaExtent.getAttribute('content')),\n        cs;\n\n      zoom = content.zoom || zoom;\n\n      let metaKeys = Object.keys(content);\n      for (let i = 0; i < metaKeys.length; i++) {\n        if (!metaKeys[i].includes('zoom')) {\n          cs = M.axisToCS(metaKeys[i].split('-')[2]);\n          break;\n        }\n      }\n      let axes = M.csToAxes(cs);\n      bounds = M.boundsToPCRSBounds(\n        L.bounds(\n          L.point(\n            +content[`top-left-${axes[0]}`],\n            +content[`top-left-${axes[1]}`]\n          ),\n          L.point(\n            +content[`bottom-right-${axes[0]}`],\n            +content[`bottom-right-${axes[1]}`]\n          )\n        ),\n        zoom,\n        projection,\n        cs\n      );\n    } else {\n      let crs = M[projection];\n      bounds = crs.options.crs.pcrs.bounds;\n    }\n    return bounds;\n  }\n  getBase() {\n    let layer = this.getRootNode().host;\n    //\n    let relativeURL =\n      this.getRootNode().querySelector('map-base') &&\n      this.getRootNode() instanceof ShadowRoot\n        ? this.getRootNode().querySelector('map-base').getAttribute('href')\n        : /* local content? */ !(this.getRootNode() instanceof ShadowRoot)\n        ? /* use the baseURI algorithm which takes into account any <base> */\n          this.getRootNode().querySelector('map-base')?.getAttribute('href') ||\n          this.baseURI\n        : /* else use the resolved <layer- src=\"...\"> value */ new URL(\n            layer.src,\n            layer.baseURI\n          ).href;\n\n    // when remote content, use layer.src as base else use baseURI of map-link\n    let baseURL =\n      this.getRootNode() instanceof ShadowRoot\n        ? new URL(layer.src, layer.baseURI).href\n        : this.baseURI;\n    return new URL(relativeURL, baseURL).href;\n  }\n  /**\n   * Return BOTH min/max(Display)Zoom AND min/maxNativeZoom which\n   * are options that can be passed to L.GridLayer...\n   * https://leafletjs.com/reference.html#gridlayer-minzoom\n   *\n   * @param {Object} zoomInput - is an element reference to a map-input[type=zoom]\n   * @returns {Object} - returns {minZoom: n,maxZoom: n,minNativeZoom: n,maxNativeZoom: n}\n   */\n  _getZoomBounds(zoomInput) {\n    // native variables should ONLY come from map-input min/max attributes\n    // BUT they should fall back to map-meta or projection values for min/max (display) zoom\n    // display zoom variables should be EQUAL to native unless specified differently\n    // via map-meta name=zoom\n    // in particular minNativeZoom being > minZoom can be problematic because\n    // you fetch tiles at larger scales (i.e. many many small tiles) and render\n    // them at smaller scale (i.e. little postage stamps), which can freez your\n    // browser and bury a tile cache in requests, getting you banned/blocked\n    //\n    // minZoom = map-meta name=zoom min || input type=zoom min || projection minZoom\n    // minNativeZoom = input type=zoom min || minZoom\n    // maxZoom = map-meta name=zoom max || input type=zoom max || projection maxZoom\n    // maxNativeZoom = input type=zoom max || maxZoom\n\n    let zoomBounds = {};\n    // search document from here up, using closest source of zoom bounds info\n    let meta = this.parentElement.getMeta('zoom');\n    let metaMin = meta\n      ? +M._metaContentToObject(meta.getAttribute('content'))?.min\n      : null;\n    zoomBounds.minZoom =\n      metaMin || (zoomInput ? +zoomInput.getAttribute('min') : 0);\n    zoomBounds.minNativeZoom = zoomInput\n      ? +zoomInput.getAttribute('min')\n      : zoomBounds.minZoom;\n    let metaMax = meta\n      ? +M._metaContentToObject(meta.getAttribute('content'))?.max\n      : null;\n    zoomBounds.maxZoom =\n      metaMax ||\n      (zoomInput\n        ? +zoomInput.getAttribute('max')\n        : M[this.parentElement.units].options.resolutions.length - 1);\n    zoomBounds.maxNativeZoom = zoomInput\n      ? +zoomInput.getAttribute('max')\n      : zoomBounds.maxZoom;\n\n    return zoomBounds;\n  }\n  _validateDisabled() {\n    let isVisible = false,\n      map = this.getMapEl(),\n      mapZoom = map.zoom,\n      extent = map.extent,\n      xmin = extent.topLeft.pcrs.horizontal,\n      xmax = extent.bottomRight.pcrs.horizontal,\n      ymin = extent.bottomRight.pcrs.vertical,\n      ymax = extent.topLeft.pcrs.vertical,\n      mapBounds = L.bounds(L.point(xmin, ymin), L.point(xmax, ymax));\n\n    if (this._templatedLayer) {\n      isVisible = this._templatedLayer.isVisible();\n    } else if (this.rel === 'query') {\n      const minZoom = this.extent.zoom.minZoom,\n        maxZoom = this.extent.zoom.maxZoom,\n        withinZoomBounds = (z) => {\n          return minZoom <= z && z <= maxZoom;\n        };\n\n      if (this.getBounds().overlaps(mapBounds) && withinZoomBounds(mapZoom)) {\n        isVisible = true;\n      }\n    }\n    return isVisible;\n  }\n  _createSelfOrStyleLink() {\n    let layerEl = this.getLayerEl();\n    const changeStyle = function (e) {\n      L.DomEvent.stop(e);\n      layerEl.dispatchEvent(\n        new CustomEvent('changestyle', {\n          detail: {\n            src: e.target.getAttribute('data-href'),\n            preference: this.media['prefers-map-content']\n          }\n        })\n      );\n    };\n\n    let styleOption = document.createElement('div'),\n      styleOptionInput = styleOption.appendChild(\n        document.createElement('input')\n      );\n    styleOptionInput.setAttribute('type', 'radio');\n    styleOptionInput.setAttribute('id', 'rad-' + L.stamp(styleOptionInput));\n    styleOptionInput.setAttribute(\n      'name',\n      // grouping radio buttons based on parent layer's style <detail>\n      'styles-' + L.stamp(styleOption)\n    );\n    styleOptionInput.setAttribute('value', this.getAttribute('title'));\n    styleOptionInput.setAttribute(\n      'data-href',\n      new URL(this.href, this.getBase()).href\n    );\n    var styleOptionLabel = styleOption.appendChild(\n      document.createElement('label')\n    );\n    styleOptionLabel.setAttribute('for', 'rad-' + L.stamp(styleOptionInput));\n    styleOptionLabel.innerText = this.title;\n    if (this.rel === 'style self' || this.rel === 'self style') {\n      styleOptionInput.checked = true;\n    }\n    this._styleOption = styleOption;\n    styleOptionInput.addEventListener('click', changeStyle.bind(this));\n  }\n  getLayerControlOption() {\n    return this._styleOption;\n  }\n\n  // Resolve the templated URL with info from the sibling map-input's\n  resolve() {\n    if (this.tref) {\n      let obj = {};\n      const inputs = this.parentElement.querySelectorAll('map-input');\n      if (this.rel === 'image') {\n        // image/map\n        for (let i = 0; i < inputs.length; i++) {\n          const inp = inputs[i];\n          obj[inp.name] = inp.value;\n        }\n        console.log(obj); // DEBUGGING\n        return L.Util.template(this.tref, obj);\n      } else if (this.rel === 'tile') {\n        // TODO. Need to get tile coords from moveend\n        // should be done/called from the TemplatedTilelayer.js file\n        return obj;\n      } else if (this.rel === 'query') {\n        // TODO. Need to get the click coords from click event\n        // should be done/called from the templatedlayer.js file\n      } else if (this.rel === 'features') {\n        // TODO.\n      }\n    }\n  }\n  whenReady() {\n    return new Promise((resolve, reject) => {\n      let interval, failureTimer, ready;\n      switch (this.rel.toLowerCase()) {\n        // for some cases, require a dependency check\n        case 'tile':\n        case 'image':\n        case 'features':\n          ready = '_templatedLayer';\n          break;\n        case 'style':\n        case 'self':\n        case 'style self':\n        case 'self style':\n          ready = '_styleOption';\n          break;\n        case 'query':\n          ready = 'shadowRoot';\n          break;\n        case 'alternate':\n          ready = '_alternate';\n          break;\n        case 'stylesheet':\n          if (this.type === 'application/pmtiles+stylesheet') {\n            ready = _pmtilesRules;\n          } else {\n            resolve();\n          }\n          break;\n        case 'zoomin':\n        case 'zoomout':\n        case 'legend':\n        case 'license':\n          resolve();\n          break;\n        default:\n          resolve();\n          break;\n      }\n      if (this[ready]) {\n        resolve();\n      }\n      interval = setInterval(testForLinkReady, 300, this);\n      failureTimer = setTimeout(linkNotDefined, 10000);\n      function testForLinkReady(linkElement) {\n        if (linkElement[ready]) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          resolve();\n        } else if (!linkElement.isConnected) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          reject('map-link was disconnected while waiting to be ready');\n        }\n      }\n      function linkNotDefined() {\n        clearInterval(interval);\n        clearTimeout(failureTimer);\n        reject('Timeout reached waiting for link to be ready');\n      }\n    });\n  }\n}\n"],"names":["MapLink","HTMLElement","observedAttributes","#hasConnected","type","this","getAttribute","val","startsWith","setAttribute","rel","includes","href","hasAttribute","URL","getBase","resolve","hreflang","tref","M","BLANK_TT_TREF","media","_metaContentToObject","tms","projection","extent","_templateVars","Object","assign","_convertAndFormatPCRS","getBounds","parentExtent","units","zoom","getZoomBounds","zoomTo","let","map","getMapEl","_map","xmin","topLeft","pcrs","horizontal","xmax","bottomRight","ymin","vertical","ymax","bounds","L","point","center","options","crs","unproject","getCenter","maxZoom","minZoom","setView","getMaxZoom","animate","getClosest","getLayerEl","attributeChangedCallback","name","oldValue","newValue","_initTemplateVars","constructor","super","connectedCallback","toLowerCase","_createTemplatedLink","_createSelfOrStyleLink","pmtilesStyles","import","then","_pmtilesRules","module","pmtilesRules","catch","console","error","reason","_createStylesheetLink","_createAlternateLink","disconnectedCallback","_stylesheetHost","link","remove","mapml","_alternate","source","target","getRootNode","ShadowRoot","host","parentElement","undefined","document","createElement","mapLink","Array","from","attributes","forEach","attribute","nodeName","nodeValue","_layer","appendStyleLink","_templatedLayer","_extentLayer","parentNode","toUpperCase","whenReady","inputsReady","log","mapEl","zIndex","querySelectorAll","indexOf","relativeSelector","rules","querySelector","zoomBounds","extentBounds","pane","getContainer","linkEl","templatedPMTilesLayer","addTo","templatedTileLayer","errorTileUrl","templatedImageLayer","attachShadow","mode","templatedFeaturesLayer","extend","_setupQueryVars","template","queryVarNames","query","inputs","values","i","length","axis","position","select","tagName","width","height","match","pixelleft","tileleft","mapleft","pixelright","tileright","mapright","pixeltop","tiletop","maptop","pixelbottom","tilebottom","mapbottom","tilei","mapi","tilej","mapj","parsedselect","htmlselect","value","input","linkedZoomInput","varNamesRe","RegExp","zoomInput","includesZoom","v","vcount","exec","varName","inp","push","step","isNaN","decodeURI","Promise","allSettled","_getZoomBounds","zoomValue","boundsUnit","FALLBACK_CS","tilematrix","locInputs","max","min","axisToCS","x","horizontalAxis","y","verticalAxis","boundsToPCRSBounds","getFallbackBounds","metaExtent","getMeta","content","cs","metaKeys","keys","split","axes","csToAxes","layer","relativeURL","src","baseURI","baseURL","meta","metaMin","minNativeZoom","metaMax","resolutions","maxNativeZoom","_validateDisabled","isVisible","mapZoom","mapBounds","overlaps","z","layerEl","styleOption","styleOptionInput","appendChild","stamp","styleOptionLabel","innerText","title","checked","_styleOption","addEventListener","e","DomEvent","stop","dispatchEvent","CustomEvent","detail","preference","bind","getLayerControlOption","obj","Util","reject","interval","failureTimer","ready","setInterval","linkElement","clearInterval","clearTimeout","isConnected","setTimeout"],"mappings":"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"}