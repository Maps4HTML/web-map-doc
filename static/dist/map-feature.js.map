{"version":3,"file":"map-feature.js","sources":["../src/map-feature.js"],"sourcesContent":["export class MapFeature extends HTMLElement {\n    static get observedAttributes() {\n      return ['zoom', 'onfocus', 'onclick', 'onblur'];\n    }\n\n    get zoom() {\n      return +(this.hasAttribute(\"zoom\") ? this.getAttribute(\"zoom\") : 0);\n    }\n\n    set zoom(val) {\n      var parsedVal = parseInt(val,10);\n      if (!isNaN(parsedVal) && (parsedVal >= this.min && parsedVal <= this.max)) {\n        this.setAttribute('zoom', parsedVal);\n      }\n    }\n\n    get min() {\n      // fallback: the minimum zoom bound of layer- element\n      return +(this.hasAttribute(\"min\") ? this.getAttribute(\"min\") : this._layer._layerEl.extent.zoom.minZoom);\n    }\n\n    set min(val) {\n      var parsedVal = parseInt(val,10);\n      if (!isNaN(parsedVal)) {\n        if (parsedVal >= this._layer._layerEl.extent.zoom.minZoom && parsedVal <= this._layer._layerEl.extent.zoom.maxZoom) {          \n          this.setAttribute('min', parsedVal);\n        } else {\n          this.setAttribute('min', this._layer._layerEl.extent.zoom.minZoom);\n        }\n      }\n    }\n\n    get max() {\n      // fallback: the maximum zoom bound of layer- element\n      return +(this.hasAttribute(\"max\") ? this.getAttribute(\"max\") : this._layer._layerEl.extent.zoom.maxZoom);\n    }\n\n    set max(val) {\n      var parsedVal = parseInt(val,10);\n      if (!isNaN(parsedVal)) {\n        if (parsedVal >= this._layer._layerEl.extent.minZoom && parsedVal <= this._layer._layerEl.extent.zoom.maxZoom) {          \n          this.setAttribute('max', parsedVal);\n        } else {\n          this.setAttribute('max', this._layer._layerEl.extent.zoom.maxZoom);\n        }\n      }\n    }\n\n    get extent() {\n      if (this.isConnected) {\n        // if the feature extent is the first time to be calculated or the feature extent is changed (by changing\n        // the innertext of map-coordinates), then calculate feature extent by invoking the getFeatureExtent function\n        if (!this._getFeatureExtent) {this._getFeatureExtent = this._memoizeExtent();}\n        return this._getFeatureExtent();\n      }\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n      switch (name) {\n        case 'zoom': {\n          if (oldValue !== newValue && this._layer) {\n            let layer = this._layer,\n            layerEl = layer._layerEl,\n            mapmlvectors = layer._mapmlvectors;\n            // if the vector layer only has static features, should update zoom bounds when zoom attribute is changed\n            if (mapmlvectors?._staticFeature) {\n              this._removeInFeatureList(oldValue);\n              let native = this._getNativeZoomAndCS(layer._content);\n              mapmlvectors.zoomBounds = mapmlvectors._getZoomBounds(layerEl.shadowRoot || layerEl, native.zoom);\n            }\n            this._removeFeature();\n            this._updateFeature();\n          }\n          break;\n        }\n        case 'onfocus': \n        case 'onclick':\n        case 'onblur':\n          if (this._groupEl) {\n            // \"synchronize\" the onevent properties (i.e. onfocus, onclick, onblur)\n            // between the mapFeature and its associated <g> element\n            this._groupEl[name] = this[name];\n            break;\n          }\n      }\n    }\n\n    constructor() {\n      // Always call super first in constructor\n      super();\n    }\n\n    connectedCallback() {\n      // if mapFeature element is not connected to layer- or layer-'s shadowroot,\n      // or the parent layer- element has a \"data-moving\" attribute\n      if ((this.parentNode.nodeType !== document.DOCUMENT_FRAGMENT_NODE && this.parentNode.nodeName.toLowerCase() !== 'layer-') || \n          (this.parentNode.nodeType === document.DOCUMENT_FRAGMENT_NODE && this.parentNode.host.hasAttribute('data-moving')) ||\n          (this.parentNode.nodeName.toLowerCase() === 'layer-' && this.parentNode.hasAttribute('data-moving'))) {\n          return;\n      }\n      // set up the map-feature object properties\n      this._addFeature();\n      // use observer to monitor the changes in mapFeature's subtree \n      // (i.e. map-properties, map-featurecaption, map-coordinates)\n      this._observer = new MutationObserver((mutationList) => {\n        for (let mutation of mutationList) {\n          // the attributes changes of <map-feature> element should be handled by attributeChangedCallback()\n          if (mutation.type === 'attributes' && mutation.target === this) {\n            return;\n          }\n          // re-render feature if there is any observed change\n          this._removeFeature();\n          this._updateFeature();\n        }\n      });\n      this._observer.observe(this, { \n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeOldValue: true,\n        characterData: true\n      });\n    }\n      \n    disconnectedCallback() {\n      if(this._layer._layerEl.hasAttribute(\"data-moving\")) return;\n      this._removeFeature();\n      this._observer.disconnect();\n    }\n\n    _removeFeature() {\n      // if the <layer- > el is disconnected\n      // the <g> el has already got removed at this point\n      if (this._groupEl?.isConnected) {\n        this._groupEl.remove();\n      }\n      // if the <layer- > el has already been disconnected,\n      // then _map.removeLayer(layerEl._layer) has already been invoked (inside layerEl.disconnectedCallback())\n      // this._featureGroup has already got removed at this point\n      if (this._featureGroup?._map){\n        this._featureGroup._map.removeLayer(this._featureGroup);\n        let mapmlvectors = this._layer._mapmlvectors;\n        if (mapmlvectors) {\n          if (mapmlvectors._staticFeature) {\n            if (mapmlvectors._features[this.zoom]) {\n              this._removeInFeatureList(this.zoom);\n            }\n            let container = this._layer.shadowRoot || this._layer._layerEl;\n            // update zoom bounds of vector layer\n            mapmlvectors.zoomBounds = mapmlvectors._getZoomBounds(container, this._getNativeZoomAndCS().zoom);\n          }\n          mapmlvectors.options.properties = null;\n          delete mapmlvectors._layers[this._featureGroup._leaflet_id];\n        }\n      }\n      delete this._featureGroup;\n      delete this._groupEl;\n      // ensure that feature extent can be re-calculated everytime that map-feature element is updated / re-added\n      if (this._getFeatureExtent) delete this._getFeatureExtent;\n    }\n\n    _addFeature() {\n      // this._layer: the leaflet layer object associated with the <layer- > element\n      //              that the <map-feature> attaches\n      // case 1: the <map-feature> el directly attaches to the <layer- > el\n      // case 2: the <map-feature> el is originally in a <mapml- > document (<layer- src=\"...mapml\">)\n      //         and attaches to the shadowRoot of the <layer- > element\n      this._layer = this.parentNode._layer ? this.parentNode._layer : this.parentNode.host._layer;\n      // if the parent layer- el has not yet added to the map, wait until it is added\n      if (!this._layer._map) {\n        this._layer.once('add', function () {\n          this._map = this._layer._map;\n        }, this);\n      } else {\n        this._map = this._layer._map;\n      }\n      // \"synchronize\" the event handlers between map-feature and <g>\n      if (!this._layer._mapmlvectors) {\n        // if vector layer has not yet created (i.e. the layer- is not yet rendered on the map)\n        this._layer.once('add', this._setUpEvents, this);\n        return;\n      } else if (!this._featureGroup) {\n        // if the map-feature el or its subtree is updated\n        // this._featureGroup has been free in this._removeFeature()\n        this._updateFeature();\n      } else {\n        this._setUpEvents();\n      }\n    }\n\n    _updateFeature() {\n      let mapmlvectors = this._layer._mapmlvectors;\n      // if the parent layer has not yet rendered on the map\n      if (!mapmlvectors) return;\n      // if the <layer- > is not removed, then regenerate featureGroup and update the mapmlvectors accordingly\n      let native = this._getNativeZoomAndCS(this._layer._content);\n      this._featureGroup = mapmlvectors.addData(this, native.cs, native.zoom);\n      mapmlvectors._layers[this._featureGroup._leaflet_id] = this._featureGroup;\n      this._groupEl = this._featureGroup.options.group;\n      if (mapmlvectors._staticFeature) {\n        let container = this._layer.shadowRoot || this._layer._layerEl;\n        // update zoom bounds of vector layer\n        mapmlvectors.zoomBounds = mapmlvectors._getZoomBounds(container, this._getNativeZoomAndCS().zoom);\n        // add feature layers to map\n        mapmlvectors._resetFeatures();\n        // update map's zoom limit\n        this._map._addZoomLimit(mapmlvectors);\n        L.extend(mapmlvectors.options, mapmlvectors.zoomBounds);\n      }\n      this._setUpEvents();\n    }\n\n    _setUpEvents() {\n      ['click','focus','blur'].forEach(name => {\n        // onevent properties & onevent attributes\n        if (this[`on${name}`] && typeof this[`on${name}`] === \"function\") this._groupEl[`on${name}`] = this[`on${name}`];\n        // event listeners\n        this._groupEl.addEventListener(name, (e) => {\n          // this === mapFeature\n          // store onEvent handler of mapFeature if there is any to ensure\n          // it will not be invoked when the mouseevent is dispatched\n          const handler = this[`on${name}`];\n          this[`on${name}`] = null;\n          if (name === 'click') {\n            this.dispatchEvent(new MouseEvent (name, {...e.options}));\n          } else {\n            this.dispatchEvent(new FocusEvent (name, {...e.options}));\n          }\n          if (handler) this[`on${name}`] = handler;\n        });\n      });\n    }\n\n    _getNativeZoomAndCS(content) {\n      // content: layer- || mapml file in src\n      let nativeZoom, nativeCS;\n      if (!content || content.nodeName.toUpperCase() === \"LAYER-\") {\n        let layerEl = this._layer._layerEl;\n        let zoomMeta = layerEl.querySelectorAll('map-meta[name=zoom]'),\n            zoomLength = zoomMeta?.length;\n        nativeZoom = zoomLength ? +(zoomMeta[zoomLength - 1].getAttribute('content')?.split(',').find(str => str.includes(\"value\"))?.split('=')[1]) : 0;\n\n        let csMeta = layerEl.querySelectorAll(\"map-meta[name=cs]\"),\n            csLength = csMeta?.length;\n        nativeCS = csLength ? csMeta[csLength - 1].getAttribute('content') : 'pcrs';\n        return {zoom: nativeZoom, cs: nativeCS};\n      } else if (content.nodeType === Node.DOCUMENT_NODE) {\n        // if the map-feature originally migrates from mapml file\n        // set the native according to the map-meta[name=zoom / cs] in mapml file\n        return this._layer._mapmlvectors._getNativeVariables(content);\n      }\n    }\n\n    // Util functions:\n    // internal method to calculate the extent of the feature and store it in cache for the first time\n    // and return cache when feature's extent is repeatedly requested\n    // for .extent\n    _memoizeExtent () {\n      // memoize calculated extent\n      let extentCache;\n      return function () {\n        if (extentCache && this._getFeatureExtent) {\n          // if the extent has already been calculated and is not updated, return stored extent\n          return extentCache;\n        } else {\n          // calculate feature extent\n          let map = this._map,\n              geometry = this.querySelector('map-geometry'),\n              native = this._getNativeZoomAndCS(this._layer._content),\n              cs = geometry.getAttribute('cs') || native.cs,\n              // zoom level that the feature rendered at\n              zoom = this.zoom || native.zoom,\n              shapes = geometry.querySelectorAll(\"map-point, map-linestring, map-polygon, map-multipoint, map-multilinestring\"),\n              bboxExtent = [Infinity, Infinity, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];\n          for (let shape of shapes) {\n            let coord = shape.querySelectorAll('map-coordinates');\n            for (let i = 0; i < coord.length; ++i) {\n              bboxExtent = _updateExtent(shape, coord[i], bboxExtent);\n            }\n          }\n          let topLeft = L.point(bboxExtent[0], bboxExtent[1]);\n          let bottomRight = L.point(bboxExtent[2], bboxExtent[3]);\n          let pcrsBound = M.boundsToPCRSBounds(L.bounds(topLeft, bottomRight), zoom, map.options.projection, cs);\n          if (shapes.length === 1 && shapes[0].tagName.toUpperCase() === \"MAP-POINT\") {\n            let projection = map.options.projection,\n                maxZoom = this.hasAttribute('max') ? +this.getAttribute('max') : M[projection].options.resolutions.length - 1,\n                tileCenter = M[projection].options.crs.tile.bounds.getCenter(),\n                pixel = M[projection].transformation.transform(pcrsBound.min, M[projection].scale(+this.zoom || maxZoom));\n            pcrsBound = M.pixelToPCRSBounds(L.bounds(pixel.subtract(tileCenter), pixel.add(tileCenter)), this.zoom || maxZoom, projection);\n          }\n          let result = M._convertAndFormatPCRS(pcrsBound, map);\n          // memoize calculated result\n          extentCache = result;\n          return result;\n        }\n      };\n\n      // update the bboxExtent\n      function _updateExtent(shape, coord, bboxExtent) {\n        let data = coord.innerHTML.trim().replace(/<[^>]+>/g, '').replace(/\\s+/g, ' ').split(/[<>\\ ]/g);\n        switch (shape.tagName) {\n          case \"MAP-POINT\":\n            bboxExtent = M._updateExtent(bboxExtent, +data[0], +data[1]);\n            break;\n          case \"MAP-LINESTRING\":\n          case \"MAP-POLYGON\":\n          case \"MAP-MULTIPOINT\":\n          case \"MAP-MULTILINESTRING\":\n            for (let i = 0; i < data.length; i += 2) {\n              bboxExtent = M._updateExtent(bboxExtent, +data[i], +data[i + 1]);\n            }\n            break;\n          default:\n            break;\n        }\n        return bboxExtent;\n      }\n    }\n\n    // find and remove the feature from mapmlvectors._features if vector layer only contains static features, helper function\n    //      prevent it from being rendered again when zooming in / out (mapmlvectors.resetFeature() is invoked) \n    _removeInFeatureList(zoom) {\n      let mapmlvectors = this._layer._mapmlvectors;\n      for (let i = 0; i < mapmlvectors._features[zoom].length; ++i) {\n        let feature = mapmlvectors._features[zoom][i];\n        if (feature._leaflet_id === this._featureGroup._leaflet_id) {\n          mapmlvectors._features[zoom].splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    // internal support for returning a GeoJSON representation of <map-feature> geometry\n    // The options object can contain the following:\n    //      propertyFunction   - function(<map-properties>), A function that maps the features' <map-properties> element to a GeoJSON \"properties\" member.\n    //      transform          - Bool, Transform coordinates to gcrs values, defaults to True\n    // mapml2geojson: <map-feature> Object -> GeoJSON\n    mapml2geojson(options) {\n      let defaults = {\n        propertyFunction: null,\n        transform: true\n      };\n      // assign default values for undefined options\n      options = Object.assign({}, defaults, options);\n\n      let json = {\n        type: \"Feature\",\n        properties: {},\n        geometry: {}\n      };\n      let el = this.querySelector('map-properties');\n      if (!el) {\n        json.properties = null;\n      } else if (typeof options.propertyFunction === \"function\") {\n        json.properties = options.propertyFunction(el);\n      } else if (el.querySelector('table')) { \n        // setting properties when table presented\n        let table = (el.querySelector('table')).cloneNode(true);\n        json.properties = M._table2properties(table);\n      } else {\n        // when no table present, strip any possible html tags to only get text\n        json.properties = {prop0: (el.innerHTML).replace(/(<([^>]+)>)/ig, '').replace(/\\s/g, '')};\n      }\n\n      // transform to gcrs if options.transform = true (default)\n      let source = null, dest = null;\n      if (options.transform) {\n        source = new proj4.Proj(this._map.options.crs.code);\n        dest = new proj4.Proj('EPSG:4326');\n        if (this._map.options.crs.code === \"EPSG:3857\" || this._map.options.crs.code  === \"EPSG:4326\") {\n          options.transform = false;\n        }\n      }\n\n      let collection = this.querySelector(\"map-geometry\").querySelector(\"map-geometrycollection\"),\n          shapes = this.querySelector(\"map-geometry\").querySelectorAll(\"map-point, map-polygon, map-linestring, map-multipoint, map-multipolygon, map-multilinestring\");\n\n      if (collection) {\n        json.geometry.type = \"GeometryCollection\";\n        json.geometry.geometries = [];\n        for (let shape of shapes) {\n          json.geometry.geometries.push(M._geometry2geojson(shape, source, dest, options.transform));\n        }\n      } else {\n        json.geometry = M._geometry2geojson(shapes[0], source, dest, options.transform);\n      }\n      return json;\n    }\n\n    // a method that simulates a click, or invoking the user-defined click event\n    //      event (optional): a MouseEvent object, can be passed as an argument of the user-defined click event handlers\n    click(event) {\n      let g = this._groupEl,\n          rect = g.getBoundingClientRect();\n      if (!event) {\n        event = new MouseEvent (\"click\", {\n          clientX: rect.x + rect.width / 2,\n          clientY: rect.y + rect.height / 2,\n          button: 0\n        });\n      }\n      if (typeof this.onclick === 'function') {\n        this.onclick.call(this, event);\n        return;\n      } else {\n        let properties = this.querySelector('map-properties');\n        if (g.getAttribute('role') === 'link') {\n          for (let path of g.children) {\n            path.mousedown.call(this._featureGroup, event);\n            path.mouseup.call(this._featureGroup, event);\n          }\n        }\n        // for custom projection, layer- element may disconnect and re-attach to the map after the click\n        // so check whether map-feature element is still connected before any further operations\n        if (properties && this.isConnected) {\n          let featureGroup = this._featureGroup,\n              shapes = featureGroup._layers;\n          // close popup if the popup is currently open\n          for (let id in shapes) {\n            if (shapes[id].isPopupOpen()) {\n              shapes[id].closePopup();\n            }\n          }\n          if (featureGroup.isPopupOpen()) {\n            featureGroup.closePopup();\n          } else {\n            featureGroup.openPopup();\n          }\n        }\n      }\n    }\n    \n    // a method that sets the current focus to the <g> element, or invoking the user-defined focus event\n    //      event (optional): a FocusEvent object, can be passed as an argument of the user-defined focus event handlers\n    //      options (optional): as options parameter for native HTMLelemnt \n    //                          https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus\n    focus(event, options) {\n      let g = this._groupEl;\n      if (typeof this.onfocus === 'function') {\n        this.onfocus.call(this, event);\n        return;\n      } else {\n        g.focus(options);\n      }\n    }\n\n    // a method that makes the <g> element lose focus, or invoking the user-defined blur event\n    //      event (optional): a FocusEvent object, can be passed as an argument of the user-defined blur event handlers\n    blur(event) {\n      if (typeof this.onblur === 'function') {\n        this.onblur.call(this, event);\n      } else if (document.activeElement.shadowRoot?.activeElement === this._groupEl || \n                 document.activeElement.shadowRoot?.activeElement.parentNode === this._groupEl) {\n        this._groupEl.blur();\n        // set focus to the map container\n        this._map._container.focus();\n      }\n    }\n\n    // a method that can the viewport to be centred on the feature's extent\n    zoomTo() {\n      let extent = this.extent,\n          map = this._map;\n      let tL = extent.topLeft.pcrs,\n          bR = extent.bottomRight.pcrs,\n          bound = L.bounds(L.point(tL.horizontal, tL.vertical), L.point(bR.horizontal, bR.vertical)),\n          center = map.options.crs.unproject(bound.getCenter(true));\n      let projection = map.options.projection,\n          layerZoomBounds = this._layer._layerEl.extent.zoom,\n          minZoom = layerZoomBounds.minZoom ? layerZoomBounds.minZoom : 0,\n          maxZoom = layerZoomBounds.maxZoom ? layerZoomBounds.maxZoom : M[projection].options.resolutions.length - 1;\n      let newZoom;\n      if (this.hasAttribute('zoom')) {\n        // if there is a zoom attribute set to the map-feature, zoom to the zoom attribute value\n        newZoom = this.zoom;\n      } else {\n        // if not, calculate the maximum zoom level that can show the feature completely\n        newZoom = M.getMaxZoom(bound, map, minZoom, maxZoom);\n        if (this.max < newZoom) {\n          // if the calculated zoom is greater than the value of max zoom attribute, go with max zoom attribute\n          newZoom = this.max;\n        } else if (this.min > newZoom) {\n          // if the calculated zoom is less than the value of min zoom attribute, go with min zoom attribute\n          newZoom = this.min;\n        }\n      }\n      // prevent overzooming / underzooming\n      if (newZoom < minZoom) {\n        newZoom = minZoom;\n      } else if (newZoom > maxZoom) {\n        newZoom = maxZoom;\n      }\n      map.setView(center, newZoom, {animate: false});\n    }\n  }"],"names":["MapFeature","HTMLElement","observedAttributes","zoom","this","hasAttribute","getAttribute","val","parsedVal","parseInt","isNaN","min","max","setAttribute","_layer","_layerEl","extent","minZoom","maxZoom","isConnected","_getFeatureExtent","_memoizeExtent","attributeChangedCallback","name","oldValue","newValue","let","layer","layerEl","mapmlvectors","_mapmlvectors","native","_staticFeature","_removeInFeatureList","_getNativeZoomAndCS","_content","zoomBounds","_getZoomBounds","shadowRoot","_removeFeature","_updateFeature","_groupEl","constructor","super","connectedCallback","parentNode","nodeType","document","DOCUMENT_FRAGMENT_NODE","nodeName","toLowerCase","host","_addFeature","_observer","MutationObserver","mutation","mutationList","type","target","observe","childList","subtree","attributes","attributeOldValue","characterData","disconnectedCallback","disconnect","remove","_featureGroup","_map","removeLayer","container","_features","options","properties","_layers","_leaflet_id","once","_setUpEvents","addData","cs","group","_resetFeatures","_addZoomLimit","L","extend","forEach","addEventListener","handler","dispatchEvent","MouseEvent","e","FocusEvent","content","nativeZoom","toUpperCase","zoomMeta","querySelectorAll","zoomLength","length","split","find","str","includes","csMeta","csLength","Node","DOCUMENT_NODE","_getNativeVariables","extentCache","map","geometry","querySelector","shapes","bboxExtent","Infinity","Number","NEGATIVE_INFINITY","shape","coord","i","data","innerHTML","trim","replace","tagName","M","_updateExtent","topLeft","point","bottomRight","pcrsBound","boundsToPCRSBounds","bounds","projection","resolutions","tileCenter","crs","tile","getCenter","pixel","transformation","transform","scale","pixelToPCRSBounds","subtract","add","result","_convertAndFormatPCRS","splice","mapml2geojson","Object","assign","propertyFunction","json","el","table","cloneNode","_table2properties","prop0","source","dest","proj4","Proj","code","collection","geometries","push","_geometry2geojson","click","event","g","rect","getBoundingClientRect","clientX","x","width","clientY","y","height","button","onclick","call","path","children","mousedown","mouseup","featureGroup","id","isPopupOpen","closePopup","openPopup","focus","onfocus","blur","onblur","activeElement","_container","zoomTo","tL","pcrs","bR","bound","horizontal","vertical","center","unproject","layerZoomBounds","newZoom","getMaxZoom","setView","animate"],"mappings":"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"}